<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">AtNode API</div></div>
</div><!--header-->
<div class="contents">

<p>Creation, manipulation and operation with Arnold nodes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtNode.html">AtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a node in Arnold.  <a href="structAtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AtNode Methods</h2></td></tr>
<tr class="memitem:ga0ec954bbf54e8e47e0f3706c49a174fe"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe">AiNode</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const <a class="el" href="classAtString.html">AtString</a> nentry_name, const <a class="el" href="classAtString.html">AtString</a> name=<a class="el" href="classAtString.html">AtString</a>(), const <a class="el" href="structAtNode.html">AtNode</a> *parent=NULL)</td></tr>
<tr class="memdesc:ga0ec954bbf54e8e47e0f3706c49a174fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fresh instantiation of a node in a specific Arnold universe.  <a href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe">More...</a><br /></td></tr>
<tr class="separator:ga0ec954bbf54e8e47e0f3706c49a174fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b657ef8a7105bdf0712c75ed7f6b160"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga8b657ef8a7105bdf0712c75ed7f6b160">AiNodeLookUpByName</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const <a class="el" href="classAtString.html">AtString</a> name, const <a class="el" href="structAtNode.html">AtNode</a> *parent=NULL)</td></tr>
<tr class="memdesc:ga8b657ef8a7105bdf0712c75ed7f6b160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a specific node in the given universe using the specified name string (which can be a simple name, a relative path or an absolute path).  <a href="group__ai__nodes.html#ga8b657ef8a7105bdf0712c75ed7f6b160">More...</a><br /></td></tr>
<tr class="separator:ga8b657ef8a7105bdf0712c75ed7f6b160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d046358c6879a4df2059471e3f9774"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gad6d046358c6879a4df2059471e3f9774">AiNodeDeclare</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, const char *declaration)</td></tr>
<tr class="memdesc:gad6d046358c6879a4df2059471e3f9774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a user-defined parameter for this node.  <a href="group__ai__nodes.html#gad6d046358c6879a4df2059471e3f9774">More...</a><br /></td></tr>
<tr class="separator:gad6d046358c6879a4df2059471e3f9774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54b5ce10ad037c6695b96d5d0d43c93"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const AtUserParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gac54b5ce10ad037c6695b96d5d0d43c93">AiNodeLookUpUserParameter</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="memdesc:gac54b5ce10ad037c6695b96d5d0d43c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the user-defined parameter entry that matches a given name.  <a href="group__ai__nodes.html#gac54b5ce10ad037c6695b96d5d0d43c93">More...</a><br /></td></tr>
<tr class="separator:gac54b5ce10ad037c6695b96d5d0d43c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga381a67c1d5f60c6c4e882b02f16db845"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga381a67c1d5f60c6c4e882b02f16db845">AiNodeIs</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="classAtString.html">AtString</a> str)</td></tr>
<tr class="memdesc:ga381a67c1d5f60c6c4e882b02f16db845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the node type against a string.  <a href="group__ai__nodes.html#ga381a67c1d5f60c6c4e882b02f16db845">More...</a><br /></td></tr>
<tr class="separator:ga381a67c1d5f60c6c4e882b02f16db845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d76161e6f07e3fa223a22be630027c"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gaf6d76161e6f07e3fa223a22be630027c">AiNodeReset</a> (<a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gaf6d76161e6f07e3fa223a22be630027c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all node parameters to their default values and remove any input links.  <a href="group__ai__nodes.html#gaf6d76161e6f07e3fa223a22be630027c">More...</a><br /></td></tr>
<tr class="separator:gaf6d76161e6f07e3fa223a22be630027c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c7ca08e70f9decb61721ca54d5a84e"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gae1c7ca08e70f9decb61721ca54d5a84e">AiNodeResetParameter</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="memdesc:gae1c7ca08e70f9decb61721ca54d5a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a node parameter to its default value and remove any links to that parameter.  <a href="group__ai__nodes.html#gae1c7ca08e70f9decb61721ca54d5a84e">More...</a><br /></td></tr>
<tr class="separator:gae1c7ca08e70f9decb61721ca54d5a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e95fdfff32591fd9566e55a177e676"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gad4e95fdfff32591fd9566e55a177e676">AiNodeClone</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> new_name=<a class="el" href="classAtString.html">AtString</a>(), const <a class="el" href="structAtNode.html">AtNode</a> *parent=NULL)</td></tr>
<tr class="memdesc:gad4e95fdfff32591fd9566e55a177e676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an exact clone of a source node.  <a href="group__ai__nodes.html#gad4e95fdfff32591fd9566e55a177e676">More...</a><br /></td></tr>
<tr class="separator:gad4e95fdfff32591fd9566e55a177e676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd01eee197f9d9ecaa4f5be7e2b86997"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gadd01eee197f9d9ecaa4f5be7e2b86997">AiNodeDestroy</a> (<a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gadd01eee197f9d9ecaa4f5be7e2b86997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an existing node.  <a href="group__ai__nodes.html#gadd01eee197f9d9ecaa4f5be7e2b86997">More...</a><br /></td></tr>
<tr class="separator:gadd01eee197f9d9ecaa4f5be7e2b86997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ab90cfd37e69041a016acf6f739ce9"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga80ab90cfd37e69041a016acf6f739ce9">AiNodeReplace</a> (<a class="el" href="structAtNode.html">AtNode</a> *old_node, <a class="el" href="structAtNode.html">AtNode</a> *new_node, bool remove)</td></tr>
<tr class="memdesc:ga80ab90cfd37e69041a016acf6f739ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an existing node with another, updating all references to that node.  <a href="group__ai__nodes.html#ga80ab90cfd37e69041a016acf6f739ce9">More...</a><br /></td></tr>
<tr class="separator:ga80ab90cfd37e69041a016acf6f739ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3876ae3182815a38bfc42b887be30aca"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga3876ae3182815a38bfc42b887be30aca">AiNodeLink</a> (<a class="el" href="structAtNode.html">AtNode</a> *src, const char *input, <a class="el" href="structAtNode.html">AtNode</a> *target)</td></tr>
<tr class="memdesc:ga3876ae3182815a38bfc42b887be30aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a connection between two shader nodes.  <a href="group__ai__nodes.html#ga3876ae3182815a38bfc42b887be30aca">More...</a><br /></td></tr>
<tr class="separator:ga3876ae3182815a38bfc42b887be30aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72e639812bd02840e606c7ff82c397d"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gae72e639812bd02840e606c7ff82c397d">AiNodeLinkOutput</a> (<a class="el" href="structAtNode.html">AtNode</a> *src, const char *output, <a class="el" href="structAtNode.html">AtNode</a> *target, const char *input)</td></tr>
<tr class="memdesc:gae72e639812bd02840e606c7ff82c397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a connection between two shader nodes.  <a href="group__ai__nodes.html#gae72e639812bd02840e606c7ff82c397d">More...</a><br /></td></tr>
<tr class="separator:gae72e639812bd02840e606c7ff82c397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga248aed9226fa7f05f8adc1f5908bfe82"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga248aed9226fa7f05f8adc1f5908bfe82">AiNodeUnlink</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *input)</td></tr>
<tr class="memdesc:ga248aed9226fa7f05f8adc1f5908bfe82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a connection from a node input parameter.  <a href="group__ai__nodes.html#ga248aed9226fa7f05f8adc1f5908bfe82">More...</a><br /></td></tr>
<tr class="separator:ga248aed9226fa7f05f8adc1f5908bfe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4673335ba3656e365b936028c9e2a7dd"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga4673335ba3656e365b936028c9e2a7dd">AiNodeIsLinked</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *input)</td></tr>
<tr class="memdesc:ga4673335ba3656e365b936028c9e2a7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input parameter is linked.  <a href="group__ai__nodes.html#ga4673335ba3656e365b936028c9e2a7dd">More...</a><br /></td></tr>
<tr class="separator:ga4673335ba3656e365b936028c9e2a7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38baef77c53b7e9ad150b4e82ac4fb9a"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga38baef77c53b7e9ad150b4e82ac4fb9a">AiNodeGetLink</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *input, int *comp=NULL)</td></tr>
<tr class="memdesc:ga38baef77c53b7e9ad150b4e82ac4fb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node connected to a given node input parameter.  <a href="group__ai__nodes.html#ga38baef77c53b7e9ad150b4e82ac4fb9a">More...</a><br /></td></tr>
<tr class="separator:ga38baef77c53b7e9ad150b4e82ac4fb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c748b8742d07a9ccca668c1afea695a"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga1c748b8742d07a9ccca668c1afea695a">AiNodeGetLinkOutput</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *input, int &amp;output_param, int &amp;output_comp)</td></tr>
<tr class="memdesc:ga1c748b8742d07a9ccca668c1afea695a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node, node output, and output component connected to a given node input parameter.  <a href="group__ai__nodes.html#ga1c748b8742d07a9ccca668c1afea695a">More...</a><br /></td></tr>
<tr class="separator:ga1c748b8742d07a9ccca668c1afea695a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31dddf920dac4c97ffd9cbf8729fa439"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga31dddf920dac4c97ffd9cbf8729fa439">AiNodeGetName</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga31dddf920dac4c97ffd9cbf8729fa439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node's name.  <a href="group__ai__nodes.html#ga31dddf920dac4c97ffd9cbf8729fa439">More...</a><br /></td></tr>
<tr class="separator:ga31dddf920dac4c97ffd9cbf8729fa439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0965ba1e70eff1b1b116bad8ced4b76"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gae0965ba1e70eff1b1b116bad8ced4b76">AiNodeGetNodeEntry</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gae0965ba1e70eff1b1b116bad8ced4b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node entry for this node.  <a href="group__ai__nodes.html#gae0965ba1e70eff1b1b116bad8ced4b76">More...</a><br /></td></tr>
<tr class="separator:gae0965ba1e70eff1b1b116bad8ced4b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14b08ec849a8698ac88ad330bfc874"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga9f14b08ec849a8698ac88ad330bfc874">AiNodeGetLocalData</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga9f14b08ec849a8698ac88ad330bfc874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the local data in the node.  <a href="group__ai__nodes.html#ga9f14b08ec849a8698ac88ad330bfc874">More...</a><br /></td></tr>
<tr class="separator:ga9f14b08ec849a8698ac88ad330bfc874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135f3592edf54e580a3f407b852c0c84"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga135f3592edf54e580a3f407b852c0c84">AiNodeSetLocalData</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, void *data)</td></tr>
<tr class="memdesc:ga135f3592edf54e580a3f407b852c0c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets local data pointer in the node.  <a href="group__ai__nodes.html#ga135f3592edf54e580a3f407b852c0c84">More...</a><br /></td></tr>
<tr class="separator:ga135f3592edf54e580a3f407b852c0c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5fef1a357dfd74afcffe331421770bd"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gad5fef1a357dfd74afcffe331421770bd">AiNodeGetPluginData</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gad5fef1a357dfd74afcffe331421770bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the per plugin data for the node type, as created in the <code>node_plugin_initialize</code> method.  <a href="group__ai__nodes.html#gad5fef1a357dfd74afcffe331421770bd">More...</a><br /></td></tr>
<tr class="separator:gad5fef1a357dfd74afcffe331421770bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f05192761af99df9394bb663eb05d2"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gaf6f05192761af99df9394bb663eb05d2">AiNodeSetDisabled</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, bool disabled)</td></tr>
<tr class="memdesc:gaf6f05192761af99df9394bb663eb05d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or enable any node in the scene.  <a href="group__ai__nodes.html#gaf6f05192761af99df9394bb663eb05d2">More...</a><br /></td></tr>
<tr class="separator:gaf6f05192761af99df9394bb663eb05d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410116942a4075d359acb392b6552cf1"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga410116942a4075d359acb392b6552cf1">AiNodeIsDisabled</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga410116942a4075d359acb392b6552cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a node has been disabled or not.  <a href="group__ai__nodes.html#ga410116942a4075d359acb392b6552cf1">More...</a><br /></td></tr>
<tr class="separator:ga410116942a4075d359acb392b6552cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e308e23e90a4d5c39a26e7799bfb2ad"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga1e308e23e90a4d5c39a26e7799bfb2ad">AiNodeGetParent</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga1e308e23e90a4d5c39a26e7799bfb2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the procedural parent of a node.  <a href="group__ai__nodes.html#ga1e308e23e90a4d5c39a26e7799bfb2ad">More...</a><br /></td></tr>
<tr class="separator:ga1e308e23e90a4d5c39a26e7799bfb2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7389d6e8b410dddcfbbaa05496b07d6f"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga7389d6e8b410dddcfbbaa05496b07d6f">AiNodeGetUniverse</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga7389d6e8b410dddcfbbaa05496b07d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the universe a node belongs to.  <a href="group__ai__nodes.html#ga7389d6e8b410dddcfbbaa05496b07d6f">More...</a><br /></td></tr>
<tr class="separator:ga7389d6e8b410dddcfbbaa05496b07d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d08cf1441332cccd0ff2c5a6ba52796"><td class="memItemLeft" align="right" valign="top">AI_API AtUserParamIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga6d08cf1441332cccd0ff2c5a6ba52796">AiNodeGetUserParamIterator</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga6d08cf1441332cccd0ff2c5a6ba52796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new AtUserParamIterator for this node.  <a href="group__ai__nodes.html#ga6d08cf1441332cccd0ff2c5a6ba52796">More...</a><br /></td></tr>
<tr class="separator:ga6d08cf1441332cccd0ff2c5a6ba52796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148e0e2ccca3d95026d27cf21b6d92a5"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga148e0e2ccca3d95026d27cf21b6d92a5">AiNodeGetProcessedGeometry</a> (<a class="el" href="structAtNode.html">AtNode</a> *source_node, <a class="el" href="structAtUniverse.html">AtUniverse</a> *dest_universe)</td></tr>
<tr class="memdesc:ga148e0e2ccca3d95026d27cf21b6d92a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node representing the final processed/baked geometry which Arnold renders.  <a href="group__ai__nodes.html#ga148e0e2ccca3d95026d27cf21b6d92a5">More...</a><br /></td></tr>
<tr class="separator:ga148e0e2ccca3d95026d27cf21b6d92a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582714e01e61c5441e472e59f3c1b53c"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga582714e01e61c5441e472e59f3c1b53c">AiNodeAddDependencyParam</a> (<a class="el" href="structAtNode.html">AtNode</a> *consumer, const <a class="el" href="structAtNode.html">AtNode</a> *producer, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="memdesc:ga582714e01e61c5441e472e59f3c1b53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use AiNodeAddDependency instead.  <a href="group__ai__nodes.html#ga582714e01e61c5441e472e59f3c1b53c">More...</a><br /></td></tr>
<tr class="separator:ga582714e01e61c5441e472e59f3c1b53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f24f17347975bc830b2990545a58c1e"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a> (<a class="el" href="structAtNode.html">AtNode</a> *consumer, const <a class="el" href="structAtNode.html">AtNode</a> *producer)</td></tr>
<tr class="memdesc:ga8f24f17347975bc830b2990545a58c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of the AiNodeAddDependency API is deprecated.  <a href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">More...</a><br /></td></tr>
<tr class="separator:ga8f24f17347975bc830b2990545a58c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce8ee2d69d5247d59f6bbeab425dc1d"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga0ce8ee2d69d5247d59f6bbeab425dc1d">AiNodeClearDependency</a> (<a class="el" href="structAtNode.html">AtNode</a> *consumer, const <a class="el" href="structAtNode.html">AtNode</a> *producer)</td></tr>
<tr class="memdesc:ga0ce8ee2d69d5247d59f6bbeab425dc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any update dependency between a specific consumer and producer nodes.  <a href="group__ai__nodes.html#ga0ce8ee2d69d5247d59f6bbeab425dc1d">More...</a><br /></td></tr>
<tr class="separator:ga0ce8ee2d69d5247d59f6bbeab425dc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868ea65a2635f286604407f5d151b9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga868ea65a2635f286604407f5d151b9ce">AiNodeAddDependency</a> (<a class="el" href="structAtNode.html">AtNode</a> *consumer, const <a class="el" href="structAtNode.html">AtNode</a> *producer, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="memdesc:ga868ea65a2635f286604407f5d151b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an update dependency between two nodes.  <a href="group__ai__nodes.html#ga868ea65a2635f286604407f5d151b9ce">More...</a><br /></td></tr>
<tr class="separator:ga868ea65a2635f286604407f5d151b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4c592f4e47640ae6972782137dc604"><td class="memItemLeft" align="right" valign="top"><a id="ga7c4c592f4e47640ae6972782137dc604" name="ga7c4c592f4e47640ae6972782137dc604"></a>
AI_DEPRECATED <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNode</b> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const char *nentry_name, const char *name=&quot;&quot;, const <a class="el" href="structAtNode.html">AtNode</a> *parent=NULL)</td></tr>
<tr class="separator:ga7c4c592f4e47640ae6972782137dc604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ab9ae14ef734da5e3cd989d98550ff"><td class="memItemLeft" align="right" valign="top"><a id="gae5ab9ae14ef734da5e3cd989d98550ff" name="gae5ab9ae14ef734da5e3cd989d98550ff"></a>
AI_DEPRECATED <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeLookUpByName</b> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const char *name, const <a class="el" href="structAtNode.html">AtNode</a> *parent=NULL)</td></tr>
<tr class="separator:gae5ab9ae14ef734da5e3cd989d98550ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6999e4ef9bda05e67737ae87eb564d64"><td class="memItemLeft" align="right" valign="top"><a id="ga6999e4ef9bda05e67737ae87eb564d64" name="ga6999e4ef9bda05e67737ae87eb564d64"></a>
AI_DEPRECATED bool&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeDeclare</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, const char *declaration)</td></tr>
<tr class="separator:ga6999e4ef9bda05e67737ae87eb564d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4564f47dda97831319efe6029576f6bb"><td class="memItemLeft" align="right" valign="top"><a id="ga4564f47dda97831319efe6029576f6bb" name="ga4564f47dda97831319efe6029576f6bb"></a>
AI_DEPRECATED const AtUserParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeLookUpUserParameter</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga4564f47dda97831319efe6029576f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AtUserParamIterator Methods</h2></td></tr>
<tr class="memitem:ga99220879684ee0fb865828ee2e858bbf"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga99220879684ee0fb865828ee2e858bbf">AiUserParamIteratorDestroy</a> (AtUserParamIterator *iter)</td></tr>
<tr class="memdesc:ga99220879684ee0fb865828ee2e858bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a user param iterator when it is no longer needed.  <a href="group__ai__nodes.html#ga99220879684ee0fb865828ee2e858bbf">More...</a><br /></td></tr>
<tr class="separator:ga99220879684ee0fb865828ee2e858bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348292f37f9869e971f8dd95f06a592d"><td class="memItemLeft" align="right" valign="top">AI_API const AtUserParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga348292f37f9869e971f8dd95f06a592d">AiUserParamIteratorGetNext</a> (AtUserParamIterator *iter)</td></tr>
<tr class="memdesc:ga348292f37f9869e971f8dd95f06a592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current user param entry and points user param iterator to the next one.  <a href="group__ai__nodes.html#ga348292f37f9869e971f8dd95f06a592d">More...</a><br /></td></tr>
<tr class="separator:ga348292f37f9869e971f8dd95f06a592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430023603648a06e146128f0d05fd50d"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga430023603648a06e146128f0d05fd50d">AiUserParamIteratorFinished</a> (const AtUserParamIterator *iter)</td></tr>
<tr class="memdesc:ga430023603648a06e146128f0d05fd50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more user parameters to iterate over.  <a href="group__ai__nodes.html#ga430023603648a06e146128f0d05fd50d">More...</a><br /></td></tr>
<tr class="separator:ga430023603648a06e146128f0d05fd50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Parameter Writers</h2></td></tr>
<tr class="memitem:ga3825758b367cc712d370d793cc1b0599"><td class="memItemLeft" align="right" valign="top"><a id="ga3825758b367cc712d370d793cc1b0599" name="ga3825758b367cc712d370d793cc1b0599"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetByte</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, uint8_t val)</td></tr>
<tr class="separator:ga3825758b367cc712d370d793cc1b0599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf754b5c63bd3da78b8122f028718887d"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gaf754b5c63bd3da78b8122f028718887d">AiNodeSetInt</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, int val)</td></tr>
<tr class="memdesc:gaf754b5c63bd3da78b8122f028718887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an integer parameter.  <a href="group__ai__nodes.html#gaf754b5c63bd3da78b8122f028718887d">More...</a><br /></td></tr>
<tr class="separator:gaf754b5c63bd3da78b8122f028718887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dbf46d97a5faf5ddb49e92049cbccf8"><td class="memItemLeft" align="right" valign="top"><a id="ga6dbf46d97a5faf5ddb49e92049cbccf8" name="ga6dbf46d97a5faf5ddb49e92049cbccf8"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetUInt</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, unsigned int val)</td></tr>
<tr class="separator:ga6dbf46d97a5faf5ddb49e92049cbccf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2250a63603d749117d2fd7c04e8c64"><td class="memItemLeft" align="right" valign="top"><a id="ga3c2250a63603d749117d2fd7c04e8c64" name="ga3c2250a63603d749117d2fd7c04e8c64"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetBool</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, bool val)</td></tr>
<tr class="separator:ga3c2250a63603d749117d2fd7c04e8c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394ed52c310c41a4e51e865ba0a2d665"><td class="memItemLeft" align="right" valign="top"><a id="ga394ed52c310c41a4e51e865ba0a2d665" name="ga394ed52c310c41a4e51e865ba0a2d665"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetFlt</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, float val)</td></tr>
<tr class="separator:ga394ed52c310c41a4e51e865ba0a2d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb525da66104a1e7c70da0272c962b68"><td class="memItemLeft" align="right" valign="top"><a id="gacb525da66104a1e7c70da0272c962b68" name="gacb525da66104a1e7c70da0272c962b68"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetPtr</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, void *val)</td></tr>
<tr class="separator:gacb525da66104a1e7c70da0272c962b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741cf9ef691f29948c9a248ea22d1e6a"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga741cf9ef691f29948c9a248ea22d1e6a">AiNodeSetArray</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, AtArray *val)</td></tr>
<tr class="memdesc:ga741cf9ef691f29948c9a248ea22d1e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an array parameter.  <a href="group__ai__nodes.html#ga741cf9ef691f29948c9a248ea22d1e6a">More...</a><br /></td></tr>
<tr class="separator:ga741cf9ef691f29948c9a248ea22d1e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fd7ee49b0da7a8cfc637dc20d94c7a"><td class="memItemLeft" align="right" valign="top"><a id="ga63fd7ee49b0da7a8cfc637dc20d94c7a" name="ga63fd7ee49b0da7a8cfc637dc20d94c7a"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetMatrix</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, <a class="el" href="structAtMatrix.html">AtMatrix</a> val)</td></tr>
<tr class="separator:ga63fd7ee49b0da7a8cfc637dc20d94c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1792711a3a9816617443fd4539678692"><td class="memItemLeft" align="right" valign="top"><a id="ga1792711a3a9816617443fd4539678692" name="ga1792711a3a9816617443fd4539678692"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetStr</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, const <a class="el" href="classAtString.html">AtString</a> str)</td></tr>
<tr class="separator:ga1792711a3a9816617443fd4539678692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cbc7ee11aad4711877c4f4377836c8a"><td class="memItemLeft" align="right" valign="top"><a id="ga6cbc7ee11aad4711877c4f4377836c8a" name="ga6cbc7ee11aad4711877c4f4377836c8a"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetRGB</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, float r, float g, float b)</td></tr>
<tr class="separator:ga6cbc7ee11aad4711877c4f4377836c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ea8f806d658f17eb28e5489042a373"><td class="memItemLeft" align="right" valign="top"><a id="gab0ea8f806d658f17eb28e5489042a373" name="gab0ea8f806d658f17eb28e5489042a373"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetRGBA</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, float r, float g, float b, float a)</td></tr>
<tr class="separator:gab0ea8f806d658f17eb28e5489042a373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdea31e96a52bf6c9234f7ec2cca088d"><td class="memItemLeft" align="right" valign="top"><a id="gabdea31e96a52bf6c9234f7ec2cca088d" name="gabdea31e96a52bf6c9234f7ec2cca088d"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetVec</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, float x, float y, float z)</td></tr>
<tr class="separator:gabdea31e96a52bf6c9234f7ec2cca088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd074415864d4bcb3f4557974799262"><td class="memItemLeft" align="right" valign="top"><a id="ga0bd074415864d4bcb3f4557974799262" name="ga0bd074415864d4bcb3f4557974799262"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetVec2</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param, float x, float y)</td></tr>
<tr class="separator:ga0bd074415864d4bcb3f4557974799262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb55e0a5a5d89c43b7af1d7240bf016"><td class="memItemLeft" align="right" valign="top"><a id="gaacb55e0a5a5d89c43b7af1d7240bf016" name="gaacb55e0a5a5d89c43b7af1d7240bf016"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetByte</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, uint8_t val)</td></tr>
<tr class="separator:gaacb55e0a5a5d89c43b7af1d7240bf016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c71d04f18cedb43777a506c64d18be1"><td class="memItemLeft" align="right" valign="top"><a id="ga6c71d04f18cedb43777a506c64d18be1" name="ga6c71d04f18cedb43777a506c64d18be1"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetInt</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, int val)</td></tr>
<tr class="separator:ga6c71d04f18cedb43777a506c64d18be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76c62b2ea88da2f0729677b24803730"><td class="memItemLeft" align="right" valign="top"><a id="gac76c62b2ea88da2f0729677b24803730" name="gac76c62b2ea88da2f0729677b24803730"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetUInt</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, unsigned int val)</td></tr>
<tr class="separator:gac76c62b2ea88da2f0729677b24803730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac355ec9b229c1ea539c1fc5868cf7912"><td class="memItemLeft" align="right" valign="top"><a id="gac355ec9b229c1ea539c1fc5868cf7912" name="gac355ec9b229c1ea539c1fc5868cf7912"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetBool</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, bool val)</td></tr>
<tr class="separator:gac355ec9b229c1ea539c1fc5868cf7912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916e35821d53f0797431754eec99acd5"><td class="memItemLeft" align="right" valign="top"><a id="ga916e35821d53f0797431754eec99acd5" name="ga916e35821d53f0797431754eec99acd5"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetFlt</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, float val)</td></tr>
<tr class="separator:ga916e35821d53f0797431754eec99acd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24881bbe234e673db78a9f589993c5f6"><td class="memItemLeft" align="right" valign="top"><a id="ga24881bbe234e673db78a9f589993c5f6" name="ga24881bbe234e673db78a9f589993c5f6"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetPtr</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, void *val)</td></tr>
<tr class="separator:ga24881bbe234e673db78a9f589993c5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a9986162766c9f71b9724c57faf1655"><td class="memItemLeft" align="right" valign="top"><a id="ga5a9986162766c9f71b9724c57faf1655" name="ga5a9986162766c9f71b9724c57faf1655"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetArray</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, AtArray *val)</td></tr>
<tr class="separator:ga5a9986162766c9f71b9724c57faf1655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93037bf449cb83ec331947a1dab1c5e5"><td class="memItemLeft" align="right" valign="top"><a id="ga93037bf449cb83ec331947a1dab1c5e5" name="ga93037bf449cb83ec331947a1dab1c5e5"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetMatrix</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, <a class="el" href="structAtMatrix.html">AtMatrix</a> val)</td></tr>
<tr class="separator:ga93037bf449cb83ec331947a1dab1c5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab220301f0b210ff49f827c5b69395be4"><td class="memItemLeft" align="right" valign="top"><a id="gab220301f0b210ff49f827c5b69395be4" name="gab220301f0b210ff49f827c5b69395be4"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetStr</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, const char *str)</td></tr>
<tr class="separator:gab220301f0b210ff49f827c5b69395be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206f3758af08ff5b81e4ce04c65760fc"><td class="memItemLeft" align="right" valign="top"><a id="ga206f3758af08ff5b81e4ce04c65760fc" name="ga206f3758af08ff5b81e4ce04c65760fc"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetRGB</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, float r, float g, float b)</td></tr>
<tr class="separator:ga206f3758af08ff5b81e4ce04c65760fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78cbe0642887432c67d1df40c126cab"><td class="memItemLeft" align="right" valign="top"><a id="gae78cbe0642887432c67d1df40c126cab" name="gae78cbe0642887432c67d1df40c126cab"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetRGBA</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, float r, float g, float b, float a)</td></tr>
<tr class="separator:gae78cbe0642887432c67d1df40c126cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5649006f65ab6615ac0eb8944b80f9"><td class="memItemLeft" align="right" valign="top"><a id="ga3a5649006f65ab6615ac0eb8944b80f9" name="ga3a5649006f65ab6615ac0eb8944b80f9"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetVec</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, float x, float y, float z)</td></tr>
<tr class="separator:ga3a5649006f65ab6615ac0eb8944b80f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3097fc2f6c572e8261918c15736c07"><td class="memItemLeft" align="right" valign="top"><a id="ga6a3097fc2f6c572e8261918c15736c07" name="ga6a3097fc2f6c572e8261918c15736c07"></a>
AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeSetVec2</b> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *param, float x, float y)</td></tr>
<tr class="separator:ga6a3097fc2f6c572e8261918c15736c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea2265cc975443b3d78286f15e7d3e4"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga7ea2265cc975443b3d78286f15e7d3e4">AiNodeSetAttributes</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char *attributes)</td></tr>
<tr class="memdesc:ga7ea2265cc975443b3d78286f15e7d3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parameters of a node through an attributes string.  <a href="group__ai__nodes.html#ga7ea2265cc975443b3d78286f15e7d3e4">More...</a><br /></td></tr>
<tr class="separator:ga7ea2265cc975443b3d78286f15e7d3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Parameter Readers</h2></td></tr>
<tr class="memitem:gab8a639d749840b2bf536f29577b0777c"><td class="memItemLeft" align="right" valign="top"><a id="gab8a639d749840b2bf536f29577b0777c" name="gab8a639d749840b2bf536f29577b0777c"></a>
AI_API uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetByte</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:gab8a639d749840b2bf536f29577b0777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967aad6520c2658fe90b14b713ddc702"><td class="memItemLeft" align="right" valign="top">AI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga967aad6520c2658fe90b14b713ddc702">AiNodeGetInt</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="memdesc:ga967aad6520c2658fe90b14b713ddc702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of an integer parameter.  <a href="group__ai__nodes.html#ga967aad6520c2658fe90b14b713ddc702">More...</a><br /></td></tr>
<tr class="separator:ga967aad6520c2658fe90b14b713ddc702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96469ae24600f070e37de992d50bc1f"><td class="memItemLeft" align="right" valign="top"><a id="gaa96469ae24600f070e37de992d50bc1f" name="gaa96469ae24600f070e37de992d50bc1f"></a>
AI_API unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetUInt</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:gaa96469ae24600f070e37de992d50bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e34addffb83b240b7b6ea8f4132100"><td class="memItemLeft" align="right" valign="top"><a id="ga22e34addffb83b240b7b6ea8f4132100" name="ga22e34addffb83b240b7b6ea8f4132100"></a>
AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetBool</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga22e34addffb83b240b7b6ea8f4132100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b12753165f7935f521b12a2372bbad5"><td class="memItemLeft" align="right" valign="top"><a id="ga2b12753165f7935f521b12a2372bbad5" name="ga2b12753165f7935f521b12a2372bbad5"></a>
AI_API float&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetFlt</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga2b12753165f7935f521b12a2372bbad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190c72a123c879c50ad551f1556418e6"><td class="memItemLeft" align="right" valign="top"><a id="ga190c72a123c879c50ad551f1556418e6" name="ga190c72a123c879c50ad551f1556418e6"></a>
AI_API <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetRGB</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga190c72a123c879c50ad551f1556418e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc046fde4ab6a853293ece4ce28c46c"><td class="memItemLeft" align="right" valign="top"><a id="ga6cc046fde4ab6a853293ece4ce28c46c" name="ga6cc046fde4ab6a853293ece4ce28c46c"></a>
AI_API <a class="el" href="structAtRGBA.html">AtRGBA</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetRGBA</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga6cc046fde4ab6a853293ece4ce28c46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc55a2a1eb8e4961fa87d33ebb323fa1"><td class="memItemLeft" align="right" valign="top"><a id="gacc55a2a1eb8e4961fa87d33ebb323fa1" name="gacc55a2a1eb8e4961fa87d33ebb323fa1"></a>
AI_API <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetVec</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:gacc55a2a1eb8e4961fa87d33ebb323fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c7337d710ee266ccf2e2fd9243657a9"><td class="memItemLeft" align="right" valign="top"><a id="ga4c7337d710ee266ccf2e2fd9243657a9" name="ga4c7337d710ee266ccf2e2fd9243657a9"></a>
AI_API <a class="el" href="structAtVector2.html">AtVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetVec2</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga4c7337d710ee266ccf2e2fd9243657a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc2700181024436ad01a640a1a96222"><td class="memItemLeft" align="right" valign="top"><a id="gaddc2700181024436ad01a640a1a96222" name="gaddc2700181024436ad01a640a1a96222"></a>
AI_API <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetStr</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:gaddc2700181024436ad01a640a1a96222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2478dfe4f7338996fd7f09a68547c896"><td class="memItemLeft" align="right" valign="top"><a id="ga2478dfe4f7338996fd7f09a68547c896" name="ga2478dfe4f7338996fd7f09a68547c896"></a>
AI_API void *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetPtr</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga2478dfe4f7338996fd7f09a68547c896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c95eb0e30d35c894ac094c4dd2377b"><td class="memItemLeft" align="right" valign="top"><a id="ga19c95eb0e30d35c894ac094c4dd2377b" name="ga19c95eb0e30d35c894ac094c4dd2377b"></a>
AI_API AtArray *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetArray</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga19c95eb0e30d35c894ac094c4dd2377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d7b36fa7a131fbfc1a1c244e12dd88"><td class="memItemLeft" align="right" valign="top"><a id="gab8d7b36fa7a131fbfc1a1c244e12dd88" name="gab8d7b36fa7a131fbfc1a1c244e12dd88"></a>
AI_API <a class="el" href="structAtMatrix.html">AtMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetMatrix</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:gab8d7b36fa7a131fbfc1a1c244e12dd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa982cefaf2f829101a4d2ab81b4fd129"><td class="memItemLeft" align="right" valign="top"><a id="gaa982cefaf2f829101a4d2ab81b4fd129" name="gaa982cefaf2f829101a4d2ab81b4fd129"></a>
AI_DEPRECATED uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetByte</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gaa982cefaf2f829101a4d2ab81b4fd129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62943904f5db3bedbe9637317ae94e44"><td class="memItemLeft" align="right" valign="top"><a id="ga62943904f5db3bedbe9637317ae94e44" name="ga62943904f5db3bedbe9637317ae94e44"></a>
AI_DEPRECATED int&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetInt</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga62943904f5db3bedbe9637317ae94e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49e99f9d1c7336fe955036db74c8c16"><td class="memItemLeft" align="right" valign="top"><a id="gaf49e99f9d1c7336fe955036db74c8c16" name="gaf49e99f9d1c7336fe955036db74c8c16"></a>
AI_DEPRECATED unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetUInt</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gaf49e99f9d1c7336fe955036db74c8c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeedd20c4502033a9ce15e2668037e683"><td class="memItemLeft" align="right" valign="top"><a id="gaeedd20c4502033a9ce15e2668037e683" name="gaeedd20c4502033a9ce15e2668037e683"></a>
AI_DEPRECATED bool&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetBool</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gaeedd20c4502033a9ce15e2668037e683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161da778df5b0b5a8f769c53c31c89db"><td class="memItemLeft" align="right" valign="top"><a id="ga161da778df5b0b5a8f769c53c31c89db" name="ga161da778df5b0b5a8f769c53c31c89db"></a>
AI_DEPRECATED float&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetFlt</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga161da778df5b0b5a8f769c53c31c89db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7c1cc5cfdc25a42374bcf5a1a4fceb"><td class="memItemLeft" align="right" valign="top"><a id="ga8e7c1cc5cfdc25a42374bcf5a1a4fceb" name="ga8e7c1cc5cfdc25a42374bcf5a1a4fceb"></a>
AI_DEPRECATED <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetRGB</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga8e7c1cc5cfdc25a42374bcf5a1a4fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbea7ef01e8790ab310b94e184816d7c"><td class="memItemLeft" align="right" valign="top"><a id="gacbea7ef01e8790ab310b94e184816d7c" name="gacbea7ef01e8790ab310b94e184816d7c"></a>
AI_DEPRECATED <a class="el" href="structAtRGBA.html">AtRGBA</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetRGBA</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gacbea7ef01e8790ab310b94e184816d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0199167bb7d4dfa66355eea60bc32c"><td class="memItemLeft" align="right" valign="top"><a id="gaec0199167bb7d4dfa66355eea60bc32c" name="gaec0199167bb7d4dfa66355eea60bc32c"></a>
AI_DEPRECATED <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetVec</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gaec0199167bb7d4dfa66355eea60bc32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004e614b09f9587ea71b14205f8b9ef2"><td class="memItemLeft" align="right" valign="top"><a id="ga004e614b09f9587ea71b14205f8b9ef2" name="ga004e614b09f9587ea71b14205f8b9ef2"></a>
AI_DEPRECATED <a class="el" href="structAtVector2.html">AtVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetVec2</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga004e614b09f9587ea71b14205f8b9ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29863b0852ccf64fa2b9787ac398b01d"><td class="memItemLeft" align="right" valign="top"><a id="ga29863b0852ccf64fa2b9787ac398b01d" name="ga29863b0852ccf64fa2b9787ac398b01d"></a>
AI_DEPRECATED <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetStr</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga29863b0852ccf64fa2b9787ac398b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fdafa877dc354d8962c44a56e0c452"><td class="memItemLeft" align="right" valign="top"><a id="gaf1fdafa877dc354d8962c44a56e0c452" name="gaf1fdafa877dc354d8962c44a56e0c452"></a>
AI_DEPRECATED void *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetPtr</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gaf1fdafa877dc354d8962c44a56e0c452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aabfec345fe63ec90e9c3c57dea2d8f"><td class="memItemLeft" align="right" valign="top"><a id="ga3aabfec345fe63ec90e9c3c57dea2d8f" name="ga3aabfec345fe63ec90e9c3c57dea2d8f"></a>
AI_DEPRECATED AtArray *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetArray</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:ga3aabfec345fe63ec90e9c3c57dea2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64ee8274028f7088aa2963118cf9c00"><td class="memItemLeft" align="right" valign="top"><a id="gab64ee8274028f7088aa2963118cf9c00" name="gab64ee8274028f7088aa2963118cf9c00"></a>
AI_DEPRECATED <a class="el" href="structAtMatrix.html">AtMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeGetMatrix</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node, const char *param)</td></tr>
<tr class="separator:gab64ee8274028f7088aa2963118cf9c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db8c3d9ecd9ebf658b33370ca2060ff"><td class="memItemLeft" align="right" valign="top"><a id="ga4db8c3d9ecd9ebf658b33370ca2060ff" name="ga4db8c3d9ecd9ebf658b33370ca2060ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeDeclareGPULocalData</b>(type)&#160;&#160;&#160;namespace {}</td></tr>
<tr class="separator:ga4db8c3d9ecd9ebf658b33370ca2060ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Method Declarations</h2></td></tr>
<tr class="memitem:gadec5d9ecd55d964c1a30151fffa8e575"><td class="memItemLeft" align="right" valign="top"><a id="gadec5d9ecd55d964c1a30151fffa8e575" name="gadec5d9ecd55d964c1a30151fffa8e575"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>node_parameters</b>&#160;&#160;&#160;static void Parameters(AtList* params, <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a>* nentry)</td></tr>
<tr class="memdesc:gadec5d9ecd55d964c1a30151fffa8e575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter declaration method. <br /></td></tr>
<tr class="separator:gadec5d9ecd55d964c1a30151fffa8e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e7ca61d8e5db95c074795fcd97bd1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga39e7ca61d8e5db95c074795fcd97bd1a">node_plugin_initialize</a></td></tr>
<tr class="memdesc:ga39e7ca61d8e5db95c074795fcd97bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node plugin initialize method (optional)  <a href="group__ai__nodes.html#ga39e7ca61d8e5db95c074795fcd97bd1a">More...</a><br /></td></tr>
<tr class="separator:ga39e7ca61d8e5db95c074795fcd97bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab937c0e0ce06a5ef75a4118bbd4c6648"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gab937c0e0ce06a5ef75a4118bbd4c6648">node_plugin_cleanup</a></td></tr>
<tr class="memdesc:gab937c0e0ce06a5ef75a4118bbd4c6648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node plugin cleanup method (optional)  <a href="group__ai__nodes.html#gab937c0e0ce06a5ef75a4118bbd4c6648">More...</a><br /></td></tr>
<tr class="separator:gab937c0e0ce06a5ef75a4118bbd4c6648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e40576b04f6465c5fafbb009e4ba19f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga8e40576b04f6465c5fafbb009e4ba19f">node_initialize</a>&#160;&#160;&#160;static void Initialize(AtRenderSession* render_session, <a class="el" href="structAtNode.html">AtNode</a>* node)</td></tr>
<tr class="memdesc:ga8e40576b04f6465c5fafbb009e4ba19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node initialization method.  <a href="group__ai__nodes.html#ga8e40576b04f6465c5fafbb009e4ba19f">More...</a><br /></td></tr>
<tr class="separator:ga8e40576b04f6465c5fafbb009e4ba19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e12b100dbc0a1f44d32bf529d3e1df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga88e12b100dbc0a1f44d32bf529d3e1df">node_update</a>&#160;&#160;&#160;static void Update(AtRenderSession* render_session, <a class="el" href="structAtNode.html">AtNode</a>* node)</td></tr>
<tr class="memdesc:ga88e12b100dbc0a1f44d32bf529d3e1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node update method.  <a href="group__ai__nodes.html#ga88e12b100dbc0a1f44d32bf529d3e1df">More...</a><br /></td></tr>
<tr class="separator:ga88e12b100dbc0a1f44d32bf529d3e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d66d14d02ac60ccd46bb952ac7c6695"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga1d66d14d02ac60ccd46bb952ac7c6695">node_finish</a>&#160;&#160;&#160;static void Finish(<a class="el" href="structAtNode.html">AtNode</a>* node)</td></tr>
<tr class="memdesc:ga1d66d14d02ac60ccd46bb952ac7c6695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node de-initialization method.  <a href="group__ai__nodes.html#ga1d66d14d02ac60ccd46bb952ac7c6695">More...</a><br /></td></tr>
<tr class="separator:ga1d66d14d02ac60ccd46bb952ac7c6695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2910e1d5da254d1aa2ce6f8c49520a"><td class="memItemLeft" align="right" valign="top"><a id="gaef2910e1d5da254d1aa2ce6f8c49520a" name="gaef2910e1d5da254d1aa2ce6f8c49520a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>node_loader</b>&#160;&#160;&#160;<a class="el" href="group__ai__plugins.html#ga95e724cd6a8385c2cea8d7fddc3a5d28">AI_EXPORT_LIB</a> bool NodeLoader(int i, <a class="el" href="structAtNodeLib.html">AtNodeLib</a>* node)</td></tr>
<tr class="memdesc:gaef2910e1d5da254d1aa2ce6f8c49520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node loading method (for plugin nodes in dynamic libraries) <br /></td></tr>
<tr class="separator:gaef2910e1d5da254d1aa2ce6f8c49520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad84d7f2f4a9b8374cba1702e81f68a64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#gad84d7f2f4a9b8374cba1702e81f68a64">AI_INSTANCE_COMMON_METHODS</a></td></tr>
<tr class="memdesc:gad84d7f2f4a9b8374cba1702e81f68a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exporter for common methods.  <a href="group__ai__nodes.html#gad84d7f2f4a9b8374cba1702e81f68a64">More...</a><br /></td></tr>
<tr class="separator:gad84d7f2f4a9b8374cba1702e81f68a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a43213a510e19f14c2ba8413ab7793"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__nodes.html#ga61a43213a510e19f14c2ba8413ab7793">AI_INSTANCE_COMMON_SHAPE_METHODS</a></td></tr>
<tr class="memdesc:ga61a43213a510e19f14c2ba8413ab7793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exporter for common shape methods.  <a href="group__ai__nodes.html#ga61a43213a510e19f14c2ba8413ab7793">More...</a><br /></td></tr>
<tr class="separator:ga61a43213a510e19f14c2ba8413ab7793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Creation, manipulation and operation with Arnold nodes. </p>
<p >Arnold has a pluggable node-management system for the standard primitives such as lights, cameras, geometry, shaders, filters, drivers, etc. Each node type has a set of associated methods (member functions) and parameters. Like C++'s objects, Arnold's node system allows new nodes to inherit both parameters and methods from the "parent" node. For example, all nodes have a "name" parameter and a "node_initialize{}" method (among others) because they are declared in the base node from which all nodes inherit.</p>
<p >In addition to these standard methods and parameters, derived nodes may have their own type-specific parameters and methods. For example, all shaders have a "shader_evaluate{}" method and all driver nodes have a "driver_write_bucket{}" method (among others). User-derived nodes may have their own new parameters but are not permitted to add new methods.</p>
<p >Optional "node_plugin_initialize{}" and "node_plugin_cleanup{}" methods can be used for initializing a plugin, if there is some initialization or data to be shared between nodes of the same type. These methods are only called if a node of this type is created. <a class="el" href="group__ai__nodes.html#gad5fef1a357dfd74afcffe331421770bd">AiNodeGetPluginData()</a> can be used to retrieve the plugin data.</p>
<p >Two of the important data-structures in this object-oriented-like system are: </p><ul>
<li><a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> &ndash; this contains the "description" of a particular node type ("polymesh", "persp_camera", etc.) </li>
<li><a class="el" href="structAtNode.html" title="This represents a node in Arnold.">AtNode</a> &ndash; this contains the "instantiation" of a particular node type </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga39e7ca61d8e5db95c074795fcd97bd1a" name="ga39e7ca61d8e5db95c074795fcd97bd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39e7ca61d8e5db95c074795fcd97bd1a">&#9670;&nbsp;</a></span>node_plugin_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define node_plugin_initialize</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> PluginInitialize(<span class="keywordtype">void</span>** plugin_data);            \</div>
<div class="line">AI_OPTIONAL_METHOD_INSTALL(ai_common_mtds, PluginInitialize) \</div>
<div class="line">static <span class="keywordtype">bool</span> PluginInitialize(<span class="keywordtype">void</span>** plugin_data)</div>
</div><!-- fragment -->
<p>Node plugin initialize method (optional) </p>

</div>
</div>
<a id="gab937c0e0ce06a5ef75a4118bbd4c6648" name="gab937c0e0ce06a5ef75a4118bbd4c6648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab937c0e0ce06a5ef75a4118bbd4c6648">&#9670;&nbsp;</a></span>node_plugin_cleanup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define node_plugin_cleanup</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> PluginCleanup(<span class="keywordtype">void</span>* plugin_data);             \</div>
<div class="line">AI_OPTIONAL_METHOD_INSTALL(ai_common_mtds, PluginCleanup) \</div>
<div class="line">static <span class="keywordtype">void</span> PluginCleanup(<span class="keywordtype">void</span>* plugin_data)</div>
</div><!-- fragment -->
<p>Node plugin cleanup method (optional) </p>

</div>
</div>
<a id="ga8e40576b04f6465c5fafbb009e4ba19f" name="ga8e40576b04f6465c5fafbb009e4ba19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e40576b04f6465c5fafbb009e4ba19f">&#9670;&nbsp;</a></span>node_initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define node_initialize&#160;&#160;&#160;static void Initialize(AtRenderSession* render_session, <a class="el" href="structAtNode.html">AtNode</a>* node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node initialization method. </p>
<p >This function can be used to allocate and/or initialize any data required by the node during rendering. Those allocations should be released in <a class="el" href="group__ai__nodes.html#ga1d66d14d02ac60ccd46bb952ac7c6695">node_finish</a>.</p>
<p >This function is called once when the scene is initialized, and will only be called again if the node is interactively reloaded.</p>
<p >An example could be allocating space for matrices, lookup tables or any kind of cached values that only needs to happen once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_session</td><td>render session where this node will be used for rendering </td></tr>
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88e12b100dbc0a1f44d32bf529d3e1df" name="ga88e12b100dbc0a1f44d32bf529d3e1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88e12b100dbc0a1f44d32bf529d3e1df">&#9670;&nbsp;</a></span>node_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define node_update&#160;&#160;&#160;static void Update(AtRenderSession* render_session, <a class="el" href="structAtNode.html">AtNode</a>* node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node update method. </p>
<p >Unlike the <a class="el" href="group__ai__nodes.html#ga8e40576b04f6465c5fafbb009e4ba19f">node_initialize</a> function, which usually is called just once, this will be called every time a render pass is executed. This is where data derived from modifiable node parameters should be precomputed for later use during rendering. Computation that only needs to happen once should be moved to node_initialization so that there is less overhead during IPR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_session</td><td>render session where this node will be used for rendering </td></tr>
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d66d14d02ac60ccd46bb952ac7c6695" name="ga1d66d14d02ac60ccd46bb952ac7c6695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d66d14d02ac60ccd46bb952ac7c6695">&#9670;&nbsp;</a></span>node_finish</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define node_finish&#160;&#160;&#160;static void Finish(<a class="el" href="structAtNode.html">AtNode</a>* node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node de-initialization method. </p>
<p >This function is used to revert the actions performed in <a class="el" href="group__ai__nodes.html#ga8e40576b04f6465c5fafbb009e4ba19f">node_initialize</a>, such as releasing memory allocated by node_init and bringing the node back to its initial state.</p>
<p >This is called when a node is destroyed, and when it is reverted to its initial value, which could happen when interactively modifying a value for a parameter that has the <code>_triggers_reinitialize</code> metadata set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad84d7f2f4a9b8374cba1702e81f68a64" name="gad84d7f2f4a9b8374cba1702e81f68a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad84d7f2f4a9b8374cba1702e81f68a64">&#9670;&nbsp;</a></span>AI_INSTANCE_COMMON_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_INSTANCE_COMMON_METHODS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a>;                           \</div>
<div class="line">node_initialize;                           \</div>
<div class="line">node_update;                               \</div>
<div class="line">node_finish;                               \</div>
<div class="line">static <a class="code hl_struct" href="structAtCommonMethods.html">AtCommonMethods</a> ai_common_mtds = {  \</div>
<div class="line">   NULL,                                   \</div>
<div class="line">   NULL,                                   \</div>
<div class="line">   Parameters,                             \</div>
<div class="line">   Initialize,                             \</div>
<div class="line">   Update,                                 \</div>
<div class="line">   Finish                                  \</div>
<div class="line">};</div>
<div class="ttc" id="agroup__ai__nodes_html_gadec5d9ecd55d964c1a30151fffa8e575"><div class="ttname"><a href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a></div><div class="ttdeci">#define node_parameters</div><div class="ttdoc">Parameter declaration method.</div><div class="ttdef"><b>Definition:</b> ai_nodes.h:72</div></div>
<div class="ttc" id="astructAtCommonMethods_html"><div class="ttname"><a href="structAtCommonMethods.html">AtCommonMethods</a></div><div class="ttdoc">Methods common to all nodes.</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:73</div></div>
</div><!-- fragment -->
<p>Exporter for common methods. </p>

</div>
</div>
<a id="ga61a43213a510e19f14c2ba8413ab7793" name="ga61a43213a510e19f14c2ba8413ab7793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a43213a510e19f14c2ba8413ab7793">&#9670;&nbsp;</a></span>AI_INSTANCE_COMMON_SHAPE_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_INSTANCE_COMMON_SHAPE_METHODS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a>;                           \</div>
<div class="line">static <a class="code hl_struct" href="structAtCommonMethods.html">AtCommonMethods</a> ai_common_mtds = {  \</div>
<div class="line">   NULL,                                   \</div>
<div class="line">   NULL,                                   \</div>
<div class="line">   Parameters,                             \</div>
<div class="line">   NULL,                                   \</div>
<div class="line">   NULL,                                   \</div>
<div class="line">   NULL                                    \</div>
<div class="line">};</div>
</div><!-- fragment -->
<p>Exporter for common shape methods. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0ec954bbf54e8e47e0f3706c49a174fe" name="ga0ec954bbf54e8e47e0f3706c49a174fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ec954bbf54e8e47e0f3706c49a174fe">&#9670;&nbsp;</a></span>AiNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>nentry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fresh instantiation of a node in a specific Arnold universe. </p>
<p >Arnold-based apps would call this function to populate a universe with nodes. Node instantiations can be created out of built-in nodes (such as "sphere" or "lambert"), manually-installed nodes (using <a class="el" href="group__ai__node__entry.html#ga000f6845aff3227c1091cf979e1666ce" title="Install a new node in the system.">AiNodeEntryInstall()</a>), or plug-in nodes contained in a .so/.dll dynamic library (using <a class="el" href="group__ai__plugins.html#ga7e86f048a5f08dce2b96b894eb6e94e6" title="Dynamically load plug-ins from a list of libraries.">AiLoadPlugins()</a>).</p>
<p >The system automatically destroys all nodes at <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a> time prior to shutdown, or when a universe is explicitly destroyed.</p>
<dl class="section note"><dt>Note</dt><dd>When creating a node that will be contained in a procedural node, it is CRITICAL that the proper parent procedural pointer is given through the "parent" parameter. Failure to do so will result in some issues due to incomplete node initialization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe where the node is to be created (NULL for default universe) </td></tr>
    <tr><td class="paramname">nentry_name</td><td>name of the type of node to be created ("polymesh", etc) </td></tr>
    <tr><td class="paramname">name</td><td>name of the new node to be created </td></tr>
    <tr><td class="paramname">parent</td><td>parent of the new node, or NULL for none (global scope) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a new <a class="el" href="structAtNode.html" title="This represents a node in Arnold.">AtNode</a> of the requested type, or NULL if the node could not be created (the node wasn't previously installed, or it was in the ignore list) </dd></dl>

</div>
</div>
<a id="ga8b657ef8a7105bdf0712c75ed7f6b160" name="ga8b657ef8a7105bdf0712c75ed7f6b160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b657ef8a7105bdf0712c75ed7f6b160">&#9670;&nbsp;</a></span>AiNodeLookUpByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> * AiNodeLookUpByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a specific node in the given universe using the specified name string (which can be a simple name, a relative path or an absolute path). </p>
<p >Performs a recursive search for the given name string, starting from the contents of the specified parent node, then continuing up towards the root of the scene, until the node is found. If the parent given is null, the search is performed only at the root level.</p>
<p >The name string could be one a simple name, a relative path (with parent names separated by '^' followed by the node name, or an absolute path, with a similar syntax to relative paths, but starting with '^'). These are some examples: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8b657ef8a7105bdf0712c75ed7f6b160">AiNodeLookUpByName</a>(<span class="stringliteral">&quot;myshader&quot;</span>, myprocedural);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8b657ef8a7105bdf0712c75ed7f6b160">AiNodeLookUpByName</a>(<span class="stringliteral">&quot;materials^wood^cherry&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8b657ef8a7105bdf0712c75ed7f6b160">AiNodeLookUpByName</a>(<span class="stringliteral">&quot;^myproc^mymesh&quot;</span>);</div>
<div class="ttc" id="agroup__ai__nodes_html_ga8b657ef8a7105bdf0712c75ed7f6b160"><div class="ttname"><a href="group__ai__nodes.html#ga8b657ef8a7105bdf0712c75ed7f6b160">AiNodeLookUpByName</a></div><div class="ttdeci">AI_API AI_PURE AtNode * AiNodeLookUpByName(const AtUniverse *universe, const AtString name, const AtNode *parent=NULL)</div><div class="ttdoc">Search for a specific node in the given universe using the specified name string (which can be a simp...</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:56</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe to search for this node (NULL for default universe) </td></tr>
    <tr><td class="paramname">name</td><td>node path to look up </td></tr>
    <tr><td class="paramname">parent</td><td>if not null, search will begin within the contents of this node, then it will continue recursively up towards the root of the scene. If null, search will be limited to nodes in the root level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a node whose "name" parameter matches the given name string, or NULL if there are no nodes with that name </dd></dl>

</div>
</div>
<a id="gad6d046358c6879a4df2059471e3f9774" name="gad6d046358c6879a4df2059471e3f9774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d046358c6879a4df2059471e3f9774">&#9670;&nbsp;</a></span>AiNodeDeclare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiNodeDeclare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a user-defined parameter for this node. </p>
<p >Adds new parameter of type 'declaration' to the specified node instantiation. <em>declaration</em> is a string of the form "class type", where:</p><ul>
<li>class := { <code>constant</code>, <code>uniform</code>, <code>varying</code> }</li>
<li>type := { <code>BYTE</code>, <code>INT</code>, <code>BOOL</code>, <code>FLOAT</code>, <code>RGB</code>, <code>POINT</code>, <code>STRING</code>, etc. }</li>
</ul>
<p >The scope of the different classes is: <br  />
</p><ul>
<li><code>constant</code> values exist on a per-object basis</li>
<li><code>uniform</code> values exist on a per-face basis</li>
<li><code>varying</code> values exist on a per-vertex basis</li>
</ul>
<p >In the case where the type is <code>ARRAY</code>, then the user should also supply the array <em>type</em> as well.</p>
<p >In the following example, we are declaring two user-defined parameters, "bar" and "heatmap", for one specific polymesh node whose name is "mymesh":</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structAtNode.html">AtNode</a> *mymesh = <a class="code hl_function" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe">AiNode</a>(<span class="stringliteral">&quot;polymesh&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#gad6d046358c6879a4df2059471e3f9774">AiNodeDeclare</a>(mymesh, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;bar&quot;</span>), <span class="stringliteral">&quot;constant BOOL&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#gad6d046358c6879a4df2059471e3f9774">AiNodeDeclare</a>(mymesh, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;heatmap&quot;</span>), <span class="stringliteral">&quot;constant ARRAY RGB&quot;</span>);</div>
<div class="ttc" id="aclassAtString_html"><div class="ttname"><a href="classAtString.html">AtString</a></div><div class="ttdoc">Arnold String allows for fast string comparisons.</div><div class="ttdef"><b>Definition:</b> ai_string.h:54</div></div>
<div class="ttc" id="agroup__ai__nodes_html_ga0ec954bbf54e8e47e0f3706c49a174fe"><div class="ttname"><a href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe">AiNode</a></div><div class="ttdeci">AI_API AtNode * AiNode(AtUniverse *universe, const AtString nentry_name, const AtString name=AtString(), const AtNode *parent=NULL)</div><div class="ttdoc">Create a fresh instantiation of a node in a specific Arnold universe.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:281</div></div>
<div class="ttc" id="agroup__ai__nodes_html_gad6d046358c6879a4df2059471e3f9774"><div class="ttname"><a href="group__ai__nodes.html#gad6d046358c6879a4df2059471e3f9774">AiNodeDeclare</a></div><div class="ttdeci">AI_API bool AiNodeDeclare(AtNode *node, const AtString param, const char *declaration)</div><div class="ttdoc">Declare a user-defined parameter for this node.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:720</div></div>
<div class="ttc" id="astructAtNode_html"><div class="ttname"><a href="structAtNode.html">AtNode</a></div><div class="ttdoc">This represents a node in Arnold.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
    <tr><td class="paramname">name</td><td>name of the new parameter </td></tr>
    <tr><td class="paramname">declaration</td><td>declaration string for the <code>class</code> and <code>type</code> of the new parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parameter could be succesfully added: it didn't already exist and the declaration string wasn't malformed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__userdef.html">User-Data API</a> </dd></dl>

</div>
</div>
<a id="gac54b5ce10ad037c6695b96d5d0d43c93" name="gac54b5ce10ad037c6695b96d5d0d43c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac54b5ce10ad037c6695b96d5d0d43c93">&#9670;&nbsp;</a></span>AiNodeLookUpUserParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const AtUserParamEntry * AiNodeLookUpUserParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the user-defined parameter entry that matches a given name. </p>
<p >This function searches the user-defined parameter entries of a given node looking for a parameter that matches the given string. If found, returns a pointer to the parameter entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
    <tr><td class="paramname">param</td><td>the parameter we are looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the user-defined parameter entry whose name matches the given string, or NULL if not found</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__userdef.html">User-Data API</a> </dd></dl>

</div>
</div>
<a id="ga381a67c1d5f60c6c4e882b02f16db845" name="ga381a67c1d5f60c6c4e882b02f16db845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga381a67c1d5f60c6c4e882b02f16db845">&#9670;&nbsp;</a></span>AiNodeIs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeIs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the node type against a string. </p>
<p >This is a useful helper function that allows one to write code like: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__ai__nodes.html#ga381a67c1d5f60c6c4e882b02f16db845">AiNodeIs</a>(mynode,<a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;lambert&quot;</span>)))</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// do something exciting that only applies to lambert nodes</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__ai__nodes_html_ga381a67c1d5f60c6c4e882b02f16db845"><div class="ttname"><a href="group__ai__nodes.html#ga381a67c1d5f60c6c4e882b02f16db845">AiNodeIs</a></div><div class="ttdeci">AI_API AI_PURE bool AiNodeIs(const AtNode *node, AtString str)</div><div class="ttdoc">Compare the node type against a string.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:542</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to a node whose type is to be compared </td></tr>
    <tr><td class="paramname">string</td><td>the name of an existing node type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node type's name matches the given string </dd></dl>

</div>
</div>
<a id="gaf6d76161e6f07e3fa223a22be630027c" name="gaf6d76161e6f07e3fa223a22be630027c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d76161e6f07e3fa223a22be630027c">&#9670;&nbsp;</a></span>AiNodeReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all node parameters to their default values and remove any input links. </p>
<dl class="section note"><dt>Note</dt><dd>If the node is a procedural, any parameter that had a explicit value was overriding the values on the children. Resetting these parameters will remove those overrides.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to a node to be reset (if the pointer is NULL, the function will simply return) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1c7ca08e70f9decb61721ca54d5a84e" name="gae1c7ca08e70f9decb61721ca54d5a84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c7ca08e70f9decb61721ca54d5a84e">&#9670;&nbsp;</a></span>AiNodeResetParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeResetParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a node parameter to its default value and remove any links to that parameter. </p>
<dl class="section note"><dt>Note</dt><dd>If you reset a declared user parameter, it will be removed and will not exist anymore. You will need to re-declare it later if you wish to use that particular user parameter.</dd></dl>
<p>\node If the node is a procedural, this parameter could have been overriding values on the nodes contained in it. This override will disappear once the parameter is reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to a node (if the pointer is NULL, the function will simply return) </td></tr>
    <tr><td class="paramname">param</td><td>name of the parameter to be reset to its default value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4e95fdfff32591fd9566e55a177e676" name="gad4e95fdfff32591fd9566e55a177e676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e95fdfff32591fd9566e55a177e676">&#9670;&nbsp;</a></span>AiNodeClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiNodeClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an exact clone of a source node. </p>
<p >Note that this performs a "deep" copy of all of the node's parameters, including strings and arrays.</p>
<dl class="section note"><dt>Note</dt><dd>the value of the "parent" parameter is the same as if the node was being created as new with the <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode</a> function. A node that will be contained in a procedural should be created with the proper parent, regardless of where the original node is coming from (root level, another procedural or even the same procedural).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the source node to be cloned </td></tr>
    <tr><td class="paramname">new_name</td><td>the name given to the cloned node </td></tr>
    <tr><td class="paramname">parent</td><td>parent of the cloned node, or NULL for none (global scope) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a clone of the source node, or <code>NULL</code> if the source was <code>NULL</code> or was non-clonable (like the options node) </dd></dl>

</div>
</div>
<a id="gadd01eee197f9d9ecaa4f5be7e2b86997" name="gadd01eee197f9d9ecaa4f5be7e2b86997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd01eee197f9d9ecaa4f5be7e2b86997">&#9670;&nbsp;</a></span>AiNodeDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiNodeDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an existing node. </p>
<p >This function releases all resources associated with an existing node, including all of its memory, parameters, arrays, etc. Attempts to access a destroyed node will cause undefined behaviour.</p>
<p >For now, this function will do nothing if called during rendering.</p>
<dl class="section note"><dt>Note</dt><dd>This function is intended for a single node or very few nodes, created and destroyed during an interactive session. It has an overhead due to memory release and update of data structures, so don't apply this to a large number of nodes, and never to the whole scene. All nodes in the scene are released efficiently during <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node was destroyed, false otherwise </dd></dl>

</div>
</div>
<a id="ga80ab90cfd37e69041a016acf6f739ce9" name="ga80ab90cfd37e69041a016acf6f739ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ab90cfd37e69041a016acf6f739ce9">&#9670;&nbsp;</a></span>AiNodeReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>old_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an existing node with another, updating all references to that node. </p>
<p >For now, this function will do nothing if called during rendering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
    <tr><td class="paramname">new_node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
    <tr><td class="paramname">remove</td><td>true if the old_node should be destroyed after replacing references </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3876ae3182815a38bfc42b887be30aca" name="ga3876ae3182815a38bfc42b887be30aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3876ae3182815a38bfc42b887be30aca">&#9670;&nbsp;</a></span>AiNodeLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiNodeLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a connection between two shader nodes. </p>
<p >This is just a convenience function for linking shaders when the whole default output of the source shader is used. It maintains the previous API for linking. Everything else is the same as in AiNodeLinkOutput.</p>
<p >So, this: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga3876ae3182815a38bfc42b887be30aca">AiNodeLink</a>(source, <span class="stringliteral">&quot;parameter&quot;</span>, target);</div>
<div class="ttc" id="agroup__ai__nodes_html_ga3876ae3182815a38bfc42b887be30aca"><div class="ttname"><a href="group__ai__nodes.html#ga3876ae3182815a38bfc42b887be30aca">AiNodeLink</a></div><div class="ttdeci">AI_API bool AiNodeLink(AtNode *src, const char *input, AtNode *target)</div><div class="ttdoc">Creates a connection between two shader nodes.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:349</div></div>
</div><!-- fragment --><p> is equivalent to: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#gae72e639812bd02840e606c7ff82c397d">AiNodeLinkOutput</a>(source, <span class="stringliteral">&quot;&quot;</span>, target, <span class="stringliteral">&quot;parameter&quot;</span>);</div>
<div class="ttc" id="agroup__ai__nodes_html_gae72e639812bd02840e606c7ff82c397d"><div class="ttname"><a href="group__ai__nodes.html#gae72e639812bd02840e606c7ff82c397d">AiNodeLinkOutput</a></div><div class="ttdeci">AI_API bool AiNodeLinkOutput(AtNode *src, const char *output, AtNode *target, const char *input)</div><div class="ttdoc">Creates a connection between two shader nodes.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:408</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__nodes.html#gae72e639812bd02840e606c7ff82c397d">AiNodeLinkOutput</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>a non-NULL pointer to the source node, to be connected to the target node </td></tr>
    <tr><td class="paramname">input</td><td>the input parameter specification in the target node, which can optionally include a component specification (e.g. "Kd.r", "dir.x"), an array element index (e.g. "colors[1]") or both (e.g. "colors[1].r"). </td></tr>
    <tr><td class="paramname">target</td><td>a non-NULL pointer to the target node whose input parameter will be connected to the output of the source node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was performed successfully, false otherwise </dd></dl>

</div>
</div>
<a id="gae72e639812bd02840e606c7ff82c397d" name="gae72e639812bd02840e606c7ff82c397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae72e639812bd02840e606c7ff82c397d">&#9670;&nbsp;</a></span>AiNodeLinkOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiNodeLinkOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a connection between two shader nodes. </p>
<p >This function is used to build shader networks. It links output of the source node to one of the input parameters in the target node.</p>
<p >A specific component can be selected for certain types, both in the source output and the target input, so that the connection would only affect that component (the other components can be linked independently).</p>
<p >For input parameters of array type, a specific element can be selected, so that the link affects only that element. Same as with components, the other array elements can be linked independently. Additionally, a specific component can be selected for the array element.</p>
<p >A check is made for "link-compatibility" between the source and the target of the connection, so it cannot be performed if they are not compatible. This includes resolution of array types (when using array linking) and takes into account separate component linking.</p>
<p >Node parameters can be explicitly flagged as non-linkable by setting the following boolean metadata: </p><div class="fragment"><div class="line"><a class="code hl_define" href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a></div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">   AiMetaDataSetBool(nentry, <span class="stringliteral">&quot;parameter_name&quot;</span>, <span class="stringliteral">&quot;linkable&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Attempts to use <a class="el" href="group__ai__nodes.html#ga3876ae3182815a38bfc42b887be30aca" title="Creates a connection between two shader nodes.">AiNodeLink()</a> / <a class="el" href="group__ai__nodes.html#gae72e639812bd02840e606c7ff82c397d" title="Creates a connection between two shader nodes.">AiNodeLinkOutput()</a> on a parameter that has been flagged as non-linkable will produce a warning but otherwise have no effect.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__nodes.html#ga3876ae3182815a38bfc42b887be30aca">AiNodeLink</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>a non-NULL pointer to the source node, to be connected to the target node </td></tr>
    <tr><td class="paramname">output</td><td>a selection of a specific node output (e.g "output_A", "output_B", ...), a specific component of the default output (e.g "r", "g", ...), a specific component of a specific output (e.g "output_A.g", "output_B.z", ...), or the full default node output when left unspecified (using "") </td></tr>
    <tr><td class="paramname">target</td><td>a non-NULL pointer to the target node whose input parameter will be connected to the output of the source node </td></tr>
    <tr><td class="paramname">input</td><td>the input parameter specification in the target node, which can optionally include a component specification (e.g. "Kd.r", "dir.x"), an array element index (e.g. "colors[1]") or both (e.g. "colors[1].r"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was performed successfully, false otherwise </dd></dl>

</div>
</div>
<a id="ga248aed9226fa7f05f8adc1f5908bfe82" name="ga248aed9226fa7f05f8adc1f5908bfe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga248aed9226fa7f05f8adc1f5908bfe82">&#9670;&nbsp;</a></span>AiNodeUnlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiNodeUnlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a connection from a node input parameter. </p>
<p >Using this function you can disconnect, or unlink, a shader input that has been previously linked. If the specified parameter wasn't already linked, this function won't do anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a non-NULL pointer to a node </td></tr>
    <tr><td class="paramname">input</td><td>the input parameter specification in the target node, which can optionally include a component specification (e.g. "Kd.r", "dir.x"), an array element index (e.g. "colors[1]") or both (e.g. "colors[1].r"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the disconnection was performed successfully, false otherwise </dd></dl>

</div>
</div>
<a id="ga4673335ba3656e365b936028c9e2a7dd" name="ga4673335ba3656e365b936028c9e2a7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4673335ba3656e365b936028c9e2a7dd">&#9670;&nbsp;</a></span>AiNodeIsLinked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeIsLinked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the input parameter is linked. </p>
<p >It will also check for the parameter to be an array, and check if there is any array element connection, and also check for any separate component linking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to be queried </td></tr>
    <tr><td class="paramname">input</td><td>the input parameter specification in the given node, which can optionally include a component specification (e.g. "Kd_color.r", "dir.x"), an array element index (e.g. "colors[1]") or both (e.g. "colors[1].r"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the input specification (or any of its components) is explicitly linked, e.g. querying for "Kd_color" will return true if either "Kd_color" or any of its R, G, or B components are linked, but querying for "Kd_color.r" will return true only if the R component has been explicitly linked) </dd></dl>

</div>
</div>
<a id="ga38baef77c53b7e9ad150b4e82ac4fb9a" name="ga38baef77c53b7e9ad150b4e82ac4fb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38baef77c53b7e9ad150b4e82ac4fb9a">&#9670;&nbsp;</a></span>AiNodeGetLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiNodeGetLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the node connected to a given node input parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to be queried </td></tr>
    <tr><td class="paramname">input</td><td>the input parameter specification in the target node, which can optionally include a component specification (e.g. "Kd_color.r", "dir.x"), an array element index (e.g. "colors[1]") or both (e.g. "colors[1].r"). </td></tr>
    <tr><td class="paramname">comp</td><td>if not NULL, the specific component selected on the source node output (-1 for the whole output, [0..3] for a single component) will be returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the connected node, or NULL if the parameter or component is not linked </dd></dl>

</div>
</div>
<a id="ga1c748b8742d07a9ccca668c1afea695a" name="ga1c748b8742d07a9ccca668c1afea695a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c748b8742d07a9ccca668c1afea695a">&#9670;&nbsp;</a></span>AiNodeGetLinkOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiNodeGetLinkOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>output_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>output_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the node, node output, and output component connected to a given node input parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to be queried </td></tr>
    <tr><td class="paramname">input</td><td>the input parameter specification in the target node, which can optionally include a component specification (e.g. "Kd_color.r", "dir.x"), an array element index (e.g. "colors[1]") or both (e.g. "colors[1].r"). </td></tr>
    <tr><td class="paramname">output_param</td><td>the index of the output parameter to which the input is linked (-1 for the default node output, 0 or greater otherwise) will be returned here, undefined when function returns NULL </td></tr>
    <tr><td class="paramname">output_comp</td><td>the index of the output parameter components to which the input is linked (-1 for the whole output, [0..3] for a single component) will be returned here, undefined when function returns NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the connected node, or NULL if the parameter or component is not linked </dd></dl>

</div>
</div>
<a id="ga31dddf920dac4c97ffd9cbf8729fa439" name="ga31dddf920dac4c97ffd9cbf8729fa439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31dddf920dac4c97ffd9cbf8729fa439">&#9670;&nbsp;</a></span>AiNodeGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiNodeGetName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node's name. </p>
<p >This is both faster and easier to use than the equivalent call: </p><div class="fragment"><div class="line">AiNodeGetStr(node, <span class="stringliteral">&quot;name&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node name string, or NULL if the input node was NULL </dd></dl>

</div>
</div>
<a id="gae0965ba1e70eff1b1b116bad8ced4b76" name="gae0965ba1e70eff1b1b116bad8ced4b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0965ba1e70eff1b1b116bad8ced4b76">&#9670;&nbsp;</a></span>AiNodeGetNodeEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> * AiNodeGetNodeEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node entry for this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node entry for this node, or NULL if the input node was NULL </dd></dl>

</div>
</div>
<a id="ga9f14b08ec849a8698ac88ad330bfc874" name="ga9f14b08ec849a8698ac88ad330bfc874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f14b08ec849a8698ac88ad330bfc874">&#9670;&nbsp;</a></span>AiNodeGetLocalData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE void * AiNodeGetLocalData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the local data in the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to local data </dd></dl>

</div>
</div>
<a id="ga135f3592edf54e580a3f407b852c0c84" name="ga135f3592edf54e580a3f407b852c0c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga135f3592edf54e580a3f407b852c0c84">&#9670;&nbsp;</a></span>AiNodeSetLocalData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeSetLocalData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets local data pointer in the node. </p>
<p >This can be used to store custom data managed by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
    <tr><td class="paramname">data</td><td>pointer to new local data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5fef1a357dfd74afcffe331421770bd" name="gad5fef1a357dfd74afcffe331421770bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5fef1a357dfd74afcffe331421770bd">&#9670;&nbsp;</a></span>AiNodeGetPluginData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE void * AiNodeGetPluginData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the per plugin data for the node type, as created in the <code>node_plugin_initialize</code> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>input node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to plugin data </dd></dl>

</div>
</div>
<a id="gaf6f05192761af99df9394bb663eb05d2" name="gaf6f05192761af99df9394bb663eb05d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f05192761af99df9394bb663eb05d2">&#9670;&nbsp;</a></span>AiNodeSetDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeSetDisabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable or enable any node in the scene. </p>
<p >Disabled nodes won't take part in the rendering process and the resulting effect will depend on the type of node:</p>
<ul>
<li>shape : it is simply excluded from the render</li>
<li>procedural : all its contained objects are excluded from render</li>
<li>shader : a disabled shader is replaced with the default shader</li>
<li>light : disabled lights are not used during rendering</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
    <tr><td class="paramname">disabled</td><td>true to disable this node, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga410116942a4075d359acb392b6552cf1" name="ga410116942a4075d359acb392b6552cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410116942a4075d359acb392b6552cf1">&#9670;&nbsp;</a></span>AiNodeIsDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeIsDisabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a node has been disabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is disabled, false otherwise </dd></dl>

</div>
</div>
<a id="ga1e308e23e90a4d5c39a26e7799bfb2ad" name="ga1e308e23e90a4d5c39a26e7799bfb2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e308e23e90a4d5c39a26e7799bfb2ad">&#9670;&nbsp;</a></span>AiNodeGetParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> * AiNodeGetParent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the procedural parent of a node. </p>
<p >This function returns the "procedural" geometry node that originally created the given node. See <a class="el" href="group__ai__procedurals.html">Procedural API</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Although this will work in the majority of cases, it doesn't support a few corner cases, such as automatic procedural instancing as used by the procedural .ass cache, where the first procedural that was loaded will be returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>procedural parent node, or NULL if the node does not come from one </dd></dl>

</div>
</div>
<a id="ga7389d6e8b410dddcfbbaa05496b07d6f" name="ga7389d6e8b410dddcfbbaa05496b07d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7389d6e8b410dddcfbbaa05496b07d6f">&#9670;&nbsp;</a></span>AiNodeGetUniverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtUniverse.html">AtUniverse</a> * AiNodeGetUniverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the universe a node belongs to. </p>
<p >This function returns the "universe" in which the node was created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to an existing node, generally coming from <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>universe the node belongs to </dd></dl>

</div>
</div>
<a id="ga6d08cf1441332cccd0ff2c5a6ba52796" name="ga6d08cf1441332cccd0ff2c5a6ba52796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d08cf1441332cccd0ff2c5a6ba52796">&#9670;&nbsp;</a></span>AiNodeGetUserParamIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtUserParamIterator * AiNodeGetUserParamIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new AtUserParamIterator for this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node whose user parameters will be iterated over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over all user parameters on this node </dd></dl>

</div>
</div>
<a id="ga148e0e2ccca3d95026d27cf21b6d92a5" name="ga148e0e2ccca3d95026d27cf21b6d92a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e0e2ccca3d95026d27cf21b6d92a5">&#9670;&nbsp;</a></span>AiNodeGetProcessedGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiNodeGetProcessedGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>source_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>dest_universe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a node representing the final processed/baked geometry which Arnold renders. </p>
<p >This returns a node representing the final geometry after a given original node is processed, e.g. after subdivision, displacement, etc. If the destination universe is the same that the original node belongs to, this will replace the original node and keep its lighting and shader settings intact. This should only be called in an interactive session, e.g. use <a class="el" href="group__ai__render.html#gga15b6311c4a75fdc524b73260268be8faaf4dd10adeffcfa088903a34d2a1409ca">AI_SESSION_INTERACTIVE</a> when calling <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> and when creating any render session if you intend to get processed geometry.</p>
<dl class="section note"><dt>Note</dt><dd>This currently only gives anything meaningful for polymesh or nurbs nodes.</dd>
<dd>
This should not be run in parallel for the same universe.</dd>
<dd>
If source_node depends on other nodes that have been modified after rendering/baking, you will need to manually re-render so that all nodes are re-initialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_node</td><td>an existing node to be processed </td></tr>
    <tr><td class="paramname">dest_universe</td><td>universe in which to deposit the new node representing the processed geometry, if this is the same universe as the source node, the source node will be replaced with the node representing the processed geometry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shape node representing the processed geometry, or NULL if no processed geometry was possible </dd></dl>

</div>
</div>
<a id="ga582714e01e61c5441e472e59f3c1b53c" name="ga582714e01e61c5441e472e59f3c1b53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582714e01e61c5441e472e59f3c1b53c">&#9670;&nbsp;</a></span>AiNodeAddDependencyParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeAddDependencyParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use AiNodeAddDependency instead. </p>
<dl class="section note"><dt>Note</dt><dd>AiNodeAddDependencyParam is a temporary intermediate function used to avoid breaking the API. It should NOT be used directly, as it will disappear from this API in a future release. </dd></dl>

</div>
</div>
<a id="ga8f24f17347975bc830b2990545a58c1e" name="ga8f24f17347975bc830b2990545a58c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f24f17347975bc830b2990545a58c1e">&#9670;&nbsp;</a></span>AiNodeAddDependency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEPRECATED void AiNodeAddDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of the AiNodeAddDependency API is deprecated. </p>
<p >If a full node dependency is needed (consumer depends on any parameter change on the producer), it can still be created by passing an empty or null string:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(consumer, producer, <a class="code hl_class" href="classAtString.html">AtString</a>());</div>
<div class="ttc" id="agroup__ai__nodes_html_ga8f24f17347975bc830b2990545a58c1e"><div class="ttname"><a href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a></div><div class="ttdeci">AI_API AI_DEPRECATED void AiNodeAddDependency(AtNode *consumer, const AtNode *producer)</div><div class="ttdoc">This version of the AiNodeAddDependency API is deprecated.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:1161</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga0ce8ee2d69d5247d59f6bbeab425dc1d" name="ga0ce8ee2d69d5247d59f6bbeab425dc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce8ee2d69d5247d59f6bbeab425dc1d">&#9670;&nbsp;</a></span>AiNodeClearDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeClearDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any update dependency between a specific consumer and producer nodes. </p>
<p >This dependency will be removed regardless of the number of parameters specified when created</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>consumer node of the dependency to remove </td></tr>
    <tr><td class="paramname">producer</td><td>producer node of the dependency to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga868ea65a2635f286604407f5d151b9ce" name="ga868ea65a2635f286604407f5d151b9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868ea65a2635f286604407f5d151b9ce">&#9670;&nbsp;</a></span>AiNodeAddDependency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AiNodeAddDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares an update dependency between two nodes. </p>
<p >This update dependency is needed when a node uses data from another node during its <code>node_update</code>. This commonly occurs with shaders reading from the options node or the render camera. These cases require manually creating an update dependency between this node and the options or camera node.</p>
<p >In order to minimize update overhead and improve efficiency, we normally declare these dependencies on a parameter basis. So, e.g. a node using "xres" and "yres" from the options node, could declare them like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* options = <a class="code hl_function" href="group__ai__universe.html#ga3d1062096c1ab6712e2e1aa087efea3b">AiUniverseGetOptions</a>(<a class="code hl_function" href="group__ai__nodes.html#ga7389d6e8b410dddcfbbaa05496b07d6f">AiNodeGetUniverse</a>(node));</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(node, options, USTR::xres);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(node, options, USTR::yres);</div>
<div class="ttc" id="agroup__ai__nodes_html_ga7389d6e8b410dddcfbbaa05496b07d6f"><div class="ttname"><a href="group__ai__nodes.html#ga7389d6e8b410dddcfbbaa05496b07d6f">AiNodeGetUniverse</a></div><div class="ttdeci">AI_API AI_PURE AtUniverse * AiNodeGetUniverse(const AtNode *node)</div><div class="ttdoc">Returns the universe a node belongs to.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:1010</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga3d1062096c1ab6712e2e1aa087efea3b"><div class="ttname"><a href="group__ai__universe.html#ga3d1062096c1ab6712e2e1aa087efea3b">AiUniverseGetOptions</a></div><div class="ttdeci">AI_API AI_PURE AtNode * AiUniverseGetOptions(const AtUniverse *universe)</div><div class="ttdoc">Fetches the global options node for a specific Arnold universe.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:124</div></div>
</div><!-- fragment --><p >Note that dependency on the universe options won't detect internal changes to the render options. For that, the user should declare a dependency on the render options instead, which will detect changes like "AA_samples" adjustment during progressive render. Be aware that this dependency might generate a higher number of update calls.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* render_options = <a class="code hl_function" href="group__ai__render.html#ga856368a186af6c55a0e1f86e341936ec">AiRenderSessionGetOptions</a>(render_session);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(node, render_options, USTR::AA_samples);</div>
<div class="ttc" id="agroup__ai__render_html_ga856368a186af6c55a0e1f86e341936ec"><div class="ttname"><a href="group__ai__render.html#ga856368a186af6c55a0e1f86e341936ec">AiRenderSessionGetOptions</a></div><div class="ttdeci">AI_API AI_PURE const AtNode * AiRenderSessionGetOptions(const AtRenderSession *render_session)</div><div class="ttdoc">Get the render options node used by a given render session.</div><div class="ttdef"><b>Definition:</b> ai_render.cpp:1094</div></div>
</div><!-- fragment --><p >Finally, using the empty or null string as the parameter specification, will create a dependency between a consumer and a producer node that includes any parameter change on the producer node. This should be use as a last resort, since it might result in interactive render overhead.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(my_node, another_node, <a class="code hl_class" href="classAtString.html">AtString</a>());</div>
</div><!-- fragment --><p >The best place to call this new API would be the <code>node_initialize</code> function. For example, if you are writing a custom shader that relies on information from the options node during its <code>node_update</code> function, you could call this function in <code>node_initialize</code>, so that it is known and taken into account during a scene update: any changes in the options node will cause this node to be updated.</p>
<p >Regardless of that, you might also clear and recreate dependencies during <code>node_update</code>, for cases where the dependencies change dynamically (like shaders that switch between using a custom camera or the render camera as input). For cases like these, you might need to remove existing dependencies between two nodes, and then create new dependencies. Those new dependencies might not be taken into account until the next render call.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga0ce8ee2d69d5247d59f6bbeab425dc1d">AiNodeClearDependency</a>(node, old_camera);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(node, new_camera, USTR::screen_window_min);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e">AiNodeAddDependency</a>(node, new_camera, USTR::screen_window_max);</div>
<div class="ttc" id="agroup__ai__nodes_html_ga0ce8ee2d69d5247d59f6bbeab425dc1d"><div class="ttname"><a href="group__ai__nodes.html#ga0ce8ee2d69d5247d59f6bbeab425dc1d">AiNodeClearDependency</a></div><div class="ttdeci">AI_API void AiNodeClearDependency(AtNode *consumer, const AtNode *producer)</div><div class="ttdoc">Removes any update dependency between a specific consumer and producer nodes.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:1174</div></div>
</div><!-- fragment --><p >Summarizing, you can read "AiNodeAddDependency(A, B, P)" as "node A depends on parameter P of 
node B". In the alternative case, "AiNodeAddDependency(A, B, AtString())" can be read as "node
A depends on any parameter changes in node B".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumer</td><td>node for which we declare a dependency node </td></tr>
    <tr><td class="paramname">producer</td><td>this node is a dependency for the previous node </td></tr>
    <tr><td class="paramname">param</td><td>modification of this parameter causes this dependency to trigger update &lt;empty or null string&gt; means consumer depends on any parameter of producer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99220879684ee0fb865828ee2e858bbf" name="ga99220879684ee0fb865828ee2e858bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99220879684ee0fb865828ee2e858bbf">&#9670;&nbsp;</a></span>AiUserParamIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiUserParamIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtUserParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a user param iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>user param iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga348292f37f9869e971f8dd95f06a592d" name="ga348292f37f9869e971f8dd95f06a592d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga348292f37f9869e971f8dd95f06a592d">&#9670;&nbsp;</a></span>AiUserParamIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const AtUserParamEntry * AiUserParamIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtUserParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current user param entry and points user param iterator to the next one. </p>
<p >This function is designed to be used inside a loop, as illustrated by the following example, which prints all the user-defined parameters of a given <a class="el" href="structAtNode.html" title="This represents a node in Arnold.">AtNode</a>:</p>
<div class="fragment"><div class="line">AtUserParamIterator *iter = <a class="code hl_function" href="group__ai__nodes.html#ga6d08cf1441332cccd0ff2c5a6ba52796">AiNodeGetUserParamIterator</a>(node);</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__nodes.html#ga430023603648a06e146128f0d05fd50d">AiUserParamIteratorFinished</a>(iter))</div>
<div class="line">{</div>
<div class="line">   AtUserParamEntry *upentry = <a class="code hl_function" href="group__ai__nodes.html#ga348292f37f9869e971f8dd95f06a592d">AiUserParamIteratorGetNext</a>(iter);</div>
<div class="line">   printf(<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code hl_function" href="group__ai__params.html#ga6808d5bdfe8eb2b480611797c11b9e30">AiUserParamGetName</a>(upentry));</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga99220879684ee0fb865828ee2e858bbf">AiUserParamIteratorDestroy</a>(iter);</div>
<div class="ttc" id="agroup__ai__nodes_html_ga348292f37f9869e971f8dd95f06a592d"><div class="ttname"><a href="group__ai__nodes.html#ga348292f37f9869e971f8dd95f06a592d">AiUserParamIteratorGetNext</a></div><div class="ttdeci">AI_API const AtUserParamEntry * AiUserParamIteratorGetNext(AtUserParamIterator *iter)</div><div class="ttdoc">Returns current user param entry and points user param iterator to the next one.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:164</div></div>
<div class="ttc" id="agroup__ai__nodes_html_ga430023603648a06e146128f0d05fd50d"><div class="ttname"><a href="group__ai__nodes.html#ga430023603648a06e146128f0d05fd50d">AiUserParamIteratorFinished</a></div><div class="ttdeci">AI_API bool AiUserParamIteratorFinished(const AtUserParamIterator *iter)</div><div class="ttdoc">Returns true if there are no more user parameters to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:175</div></div>
<div class="ttc" id="agroup__ai__nodes_html_ga6d08cf1441332cccd0ff2c5a6ba52796"><div class="ttname"><a href="group__ai__nodes.html#ga6d08cf1441332cccd0ff2c5a6ba52796">AiNodeGetUserParamIterator</a></div><div class="ttdeci">AI_API AtUserParamIterator * AiNodeGetUserParamIterator(const AtNode *node)</div><div class="ttdoc">Creates and returns a new AtUserParamIterator for this node.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:123</div></div>
<div class="ttc" id="agroup__ai__nodes_html_ga99220879684ee0fb865828ee2e858bbf"><div class="ttname"><a href="group__ai__nodes.html#ga99220879684ee0fb865828ee2e858bbf">AiUserParamIteratorDestroy</a></div><div class="ttdeci">AI_API void AiUserParamIteratorDestroy(AtUserParamIterator *iter)</div><div class="ttdoc">Destroys a user param iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:133</div></div>
<div class="ttc" id="agroup__ai__params_html_ga6808d5bdfe8eb2b480611797c11b9e30"><div class="ttname"><a href="group__ai__params.html#ga6808d5bdfe8eb2b480611797c11b9e30">AiUserParamGetName</a></div><div class="ttdeci">AI_API AI_DEVICE AI_PURE const char * AiUserParamGetName(const AtUserParamEntry *upentry)</div><div class="ttdoc">Look-up user-declared parameter name.</div><div class="ttdef"><b>Definition:</b> ai_userdefs.cpp:12</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If this is an instance, the iterator will NOT include user parameters that were declared in the reference node, even though <a class="el" href="group__ai__nodes.html#gac54b5ce10ad037c6695b96d5d0d43c93" title="Return the user-defined parameter entry that matches a given name.">AiNodeLookUpUserParameter()</a> would find such user parameters in the instance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a user param iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current user param entry pointed by the iterator, or <code>NULL</code> if there are no more user parameters to iterate over </dd></dl>

</div>
</div>
<a id="ga430023603648a06e146128f0d05fd50d" name="ga430023603648a06e146128f0d05fd50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga430023603648a06e146128f0d05fd50d">&#9670;&nbsp;</a></span>AiUserParamIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiUserParamIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtUserParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more user parameters to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a user param iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the user param iterator has moved past the last user parameter </dd></dl>

</div>
</div>
<a id="gaf754b5c63bd3da78b8122f028718887d" name="gaf754b5c63bd3da78b8122f028718887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf754b5c63bd3da78b8122f028718887d">&#9670;&nbsp;</a></span>AiNodeSetInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeSetInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an integer parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
    <tr><td class="paramname">param_name</td><td>name of the parameter to set </td></tr>
    <tr><td class="paramname">value</td><td>new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga741cf9ef691f29948c9a248ea22d1e6a" name="ga741cf9ef691f29948c9a248ea22d1e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741cf9ef691f29948c9a248ea22d1e6a">&#9670;&nbsp;</a></span>AiNodeSetArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeSetArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtArray *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an array parameter. </p>
<p >Note that to avoid a memory leak when setting a node's array successive times, the existing array (if any) is deallocated before it's overwritten with the new value; you don't need to call <a class="el" href="group__ai__array.html#ga55714e69cb5bf0e5b99542ab644d7c02" title="Deallocate an array object.">AiArrayDestroy()</a> on the old array, and in fact doing so will probably cause a crash because of a double deallocation.</p>
<p >NOTE: The new array will be unmap'ed automatically before being set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
    <tr><td class="paramname">param_name</td><td>name of the parameter to set </td></tr>
    <tr><td class="paramname">array</td><td>new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ea2265cc975443b3d78286f15e7d3e4" name="ga7ea2265cc975443b3d78286f15e7d3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea2265cc975443b3d78286f15e7d3e4">&#9670;&nbsp;</a></span>AiNodeSetAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeSetAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the parameters of a node through an attributes string. </p>
<p >Given a node, this API can be used to set a number of its attributes in one go, as shown in the following examples:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga7ea2265cc975443b3d78286f15e7d3e4">AiNodeSetAttributes</a>(myoptions, <span class="stringliteral">&quot;threads 32&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga7ea2265cc975443b3d78286f15e7d3e4">AiNodeSetAttributes</a>(myoptions, <span class="stringliteral">&quot;GI_diffuse_samples 3 GI_diffuse_depth 1&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__ai__nodes.html#ga7ea2265cc975443b3d78286f15e7d3e4">AiNodeSetAttributes</a>(mylambert, <span class="stringliteral">&quot;Kd 0.7\nKd_color 0.5 0.5 0.5&quot;</span>);</div>
<div class="ttc" id="agroup__ai__nodes_html_ga7ea2265cc975443b3d78286f15e7d3e4"><div class="ttname"><a href="group__ai__nodes.html#ga7ea2265cc975443b3d78286f15e7d3e4">AiNodeSetAttributes</a></div><div class="ttdeci">AI_API void AiNodeSetAttributes(AtNode *node, const char *attributes)</div><div class="ttdoc">Set the parameters of a node through an attributes string.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:946</div></div>
</div><!-- fragment --><p >This is helpful if you need to use an attribute of a newer version of the Arnold core from an old version of a host 3D application whose UI does not expose this particular attribute yet; the user could enable new or experimental features in the renderer by typing a carefully crafted string in a text field of the UI, which the host app would simply pass through to the renderer. The string is later parsed with the same exact code that is used for parsing node attributes in an .ass file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
    <tr><td class="paramname">attributes</td><td>string containing any number of parameter/value pairs separated by whitespace (spaces, tabs, newlines) as found in .ass files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga967aad6520c2658fe90b14b713ddc702" name="ga967aad6520c2658fe90b14b713ddc702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967aad6520c2658fe90b14b713ddc702">&#9670;&nbsp;</a></span>AiNodeGetInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API int AiNodeGetInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>param_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of an integer parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the node </td></tr>
    <tr><td class="paramname">param_name</td><td>name of the parameter to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of parameter </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
