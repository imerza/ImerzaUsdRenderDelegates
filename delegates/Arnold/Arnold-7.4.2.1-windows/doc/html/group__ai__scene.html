<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Scene File API</div></div>
</div><!--header-->
<div class="contents">

<p>Scene file loading and writing using multiple formats.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows iterating over the list of supported scene formats.  <a href="structAtSceneFormatIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows iterating over the list of supported extensions for a given scene format.  <a href="structAtSceneFormatExtensionIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to information about the scene format.  <a href="structAtSceneFormatData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e29f1899cabe03a9df6a86f27bc6eba"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga0e29f1899cabe03a9df6a86f27bc6eba">AiSceneLoad</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const char *filename, const AtParamValueMap *params=nullptr)</td></tr>
<tr class="memdesc:ga0e29f1899cabe03a9df6a86f27bc6eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all nodes from a scene file into a specific Arnold universe.  <a href="group__ai__scene.html#ga0e29f1899cabe03a9df6a86f27bc6eba">More...</a><br /></td></tr>
<tr class="separator:ga0e29f1899cabe03a9df6a86f27bc6eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d7a8fd4348c653339408a922fdaf85"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga44d7a8fd4348c653339408a922fdaf85">AiSceneWrite</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const char *filename, const AtParamValueMap *params=nullptr, const <a class="el" href="structAtMetadataStore.html">AtMetadataStore</a> *mds=NULL)</td></tr>
<tr class="memdesc:ga44d7a8fd4348c653339408a922fdaf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all nodes in the given universe to a scene file.  <a href="group__ai__scene.html#ga44d7a8fd4348c653339408a922fdaf85">More...</a><br /></td></tr>
<tr class="separator:ga44d7a8fd4348c653339408a922fdaf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416647a4f6a3318abd659938dbeba7d0"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga416647a4f6a3318abd659938dbeba7d0">AiSceneFormatSupported</a> (const char *extension)</td></tr>
<tr class="memdesc:ga416647a4f6a3318abd659938dbeba7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the scene format corresponding to a given filename extension is supported.  <a href="group__ai__scene.html#ga416647a4f6a3318abd659938dbeba7d0">More...</a><br /></td></tr>
<tr class="separator:ga416647a4f6a3318abd659938dbeba7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Iterator API</h2></td></tr>
<tr class="memitem:ga80e17f38863b192efb9f229699758692"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga80e17f38863b192efb9f229699758692">AiSceneFormatIterator</a> ()</td></tr>
<tr class="memdesc:ga80e17f38863b192efb9f229699758692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get new scene format iterator.  <a href="group__ai__scene.html#ga80e17f38863b192efb9f229699758692">More...</a><br /></td></tr>
<tr class="separator:ga80e17f38863b192efb9f229699758692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ba3cf20dff4a89ecd9f6b6ed40405e"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#gac9ba3cf20dff4a89ecd9f6b6ed40405e">AiSceneFormatIteratorDestroy</a> (<a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *iter)</td></tr>
<tr class="memdesc:gac9ba3cf20dff4a89ecd9f6b6ed40405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys scene format iterator and releases any allocated memory.  <a href="group__ai__scene.html#gac9ba3cf20dff4a89ecd9f6b6ed40405e">More...</a><br /></td></tr>
<tr class="separator:gac9ba3cf20dff4a89ecd9f6b6ed40405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18b9e7b95f60a0486c63bc04e76d119"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#gac18b9e7b95f60a0486c63bc04e76d119">AiSceneFormatIteratorGetNext</a> (<a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *iter)</td></tr>
<tr class="memdesc:gac18b9e7b95f60a0486c63bc04e76d119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next supported scene format.  <a href="group__ai__scene.html#gac18b9e7b95f60a0486c63bc04e76d119">More...</a><br /></td></tr>
<tr class="separator:gac18b9e7b95f60a0486c63bc04e76d119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeedc9e06a381c2b84203b55737db0681"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#gaeedc9e06a381c2b84203b55737db0681">AiSceneFormatIteratorFinished</a> (const <a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *iter)</td></tr>
<tr class="memdesc:gaeedc9e06a381c2b84203b55737db0681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are more scene formats to iterate over.  <a href="group__ai__scene.html#gaeedc9e06a381c2b84203b55737db0681">More...</a><br /></td></tr>
<tr class="separator:gaeedc9e06a381c2b84203b55737db0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff162b32562ce9f0172bfd39eaed3b83"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#gaff162b32562ce9f0172bfd39eaed3b83">AiSceneFormatGetExtensionIterator</a> (const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *format_data)</td></tr>
<tr class="memdesc:gaff162b32562ce9f0172bfd39eaed3b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over all supported extensions for this scene format.  <a href="group__ai__scene.html#gaff162b32562ce9f0172bfd39eaed3b83">More...</a><br /></td></tr>
<tr class="separator:gaff162b32562ce9f0172bfd39eaed3b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5afa9c6087fc499d8406df347069b688"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga5afa9c6087fc499d8406df347069b688">AiSceneFormatExtensionIteratorDestroy</a> (<a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *iter)</td></tr>
<tr class="memdesc:ga5afa9c6087fc499d8406df347069b688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys scene format extension iterator and releases any allocated memory.  <a href="group__ai__scene.html#ga5afa9c6087fc499d8406df347069b688">More...</a><br /></td></tr>
<tr class="separator:ga5afa9c6087fc499d8406df347069b688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45979ee95de82fd3295cfd754827358"><td class="memItemLeft" align="right" valign="top">AI_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#gad45979ee95de82fd3295cfd754827358">AiSceneFormatExtensionIteratorGetNext</a> (<a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *iter)</td></tr>
<tr class="memdesc:gad45979ee95de82fd3295cfd754827358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next supported scene format extension.  <a href="group__ai__scene.html#gad45979ee95de82fd3295cfd754827358">More...</a><br /></td></tr>
<tr class="separator:gad45979ee95de82fd3295cfd754827358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga453a1c54c2940df8518d0bf4403efc9b"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga453a1c54c2940df8518d0bf4403efc9b">AiSceneFormatExtensionIteratorFinished</a> (const <a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *iter)</td></tr>
<tr class="memdesc:ga453a1c54c2940df8518d0bf4403efc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are more scene formats extensions to iterate over.  <a href="group__ai__scene.html#ga453a1c54c2940df8518d0bf4403efc9b">More...</a><br /></td></tr>
<tr class="separator:ga453a1c54c2940df8518d0bf4403efc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5540cf1fdb2942c38a4728e917f62e"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga4f5540cf1fdb2942c38a4728e917f62e">AiSceneFormatGetName</a> (const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *format_data)</td></tr>
<tr class="memdesc:ga4f5540cf1fdb2942c38a4728e917f62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the scene format.  <a href="group__ai__scene.html#ga4f5540cf1fdb2942c38a4728e917f62e">More...</a><br /></td></tr>
<tr class="separator:ga4f5540cf1fdb2942c38a4728e917f62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461ef8a7ae07d8e95cdaad26c5ad6625"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga461ef8a7ae07d8e95cdaad26c5ad6625">AiSceneFormatGetDescription</a> (const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *format_data)</td></tr>
<tr class="memdesc:ga461ef8a7ae07d8e95cdaad26c5ad6625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of the scene format.  <a href="group__ai__scene.html#ga461ef8a7ae07d8e95cdaad26c5ad6625">More...</a><br /></td></tr>
<tr class="separator:ga461ef8a7ae07d8e95cdaad26c5ad6625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db26d4a88c82592a69369fadf401752"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga4db26d4a88c82592a69369fadf401752">AiSceneFormatSupportsReading</a> (const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *format_data)</td></tr>
<tr class="memdesc:ga4db26d4a88c82592a69369fadf401752"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the scene format supports reading from file.  <a href="group__ai__scene.html#ga4db26d4a88c82592a69369fadf401752">More...</a><br /></td></tr>
<tr class="separator:ga4db26d4a88c82592a69369fadf401752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c69e9d7b21db98b64bf25d13f9ee70"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga07c69e9d7b21db98b64bf25d13f9ee70">AiSceneFormatSupportsWriting</a> (const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *format_data)</td></tr>
<tr class="memdesc:ga07c69e9d7b21db98b64bf25d13f9ee70"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the scene format supports writing to a file.  <a href="group__ai__scene.html#ga07c69e9d7b21db98b64bf25d13f9ee70">More...</a><br /></td></tr>
<tr class="separator:ga07c69e9d7b21db98b64bf25d13f9ee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b3ce949256bb65e6352ce46f296ea2e"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtMetadataStore.html">AtMetadataStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__scene.html#ga9b3ce949256bb65e6352ce46f296ea2e">AiSceneFormatGetMetadataStore</a> (const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *format_data)</td></tr>
<tr class="memdesc:ga9b3ce949256bb65e6352ce46f296ea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get metadata for the scene format and its optional parameters.  <a href="group__ai__scene.html#ga9b3ce949256bb65e6352ce46f296ea2e">More...</a><br /></td></tr>
<tr class="separator:ga9b3ce949256bb65e6352ce46f296ea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Scene file loading and writing using multiple formats. </p>
<p >The implementation of each specific scene format will determine how to load nodes into an Arnold universe or how to store the contents of an Arnold universe into a scene file. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0e29f1899cabe03a9df6a86f27bc6eba" name="ga0e29f1899cabe03a9df6a86f27bc6eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e29f1899cabe03a9df6a86f27bc6eba">&#9670;&nbsp;</a></span>AiSceneLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiSceneLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all nodes from a scene file into a specific Arnold universe. </p>
<p >If the filename is "-", it reads data from stdin (assuming ASS format)</p>
<p >This example code loads all node types from a scene file: </p><div class="fragment"><div class="line">AtParamValueMap* params = <a class="code hl_function" href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a>();</div>
<div class="line">AiParamValueMapSetInt(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;mask&quot;</span>), <a class="code hl_define" href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a>);</div>
<div class="line"><a class="code hl_function" href="group__ai__scene.html#ga0e29f1899cabe03a9df6a86f27bc6eba">AiSceneLoad</a>(universe, <span class="stringliteral">&quot;scene.ass&quot;</span>, params); </div>
<div class="line"><a class="code hl_function" href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a>(params);</div>
<div class="ttc" id="aclassAtString_html"><div class="ttname"><a href="classAtString.html">AtString</a></div><div class="ttdoc">Arnold String allows for fast string comparisons.</div><div class="ttdef"><b>Definition:</b> ai_string.h:54</div></div>
<div class="ttc" id="agroup__ai__map_html_ga79ba0a87866541a1029201b9df5bddf1"><div class="ttname"><a href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a></div><div class="ttdeci">AI_API AtParamValueMap * AiParamValueMap()</div><div class="ttdoc">Creates a new map.</div><div class="ttdef"><b>Definition:</b> ai_map.cpp:46</div></div>
<div class="ttc" id="agroup__ai__map_html_gab06bffff6c01ce8b403d107e4325052e"><div class="ttname"><a href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a></div><div class="ttdeci">AI_API void AiParamValueMapDestroy(AtParamValueMap *map)</div><div class="ttdoc">Destroys a map object.</div><div class="ttdef"><b>Definition:</b> ai_map.cpp:55</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gaaf029c124baf82592ee04a8a303be9d8"><div class="ttname"><a href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a></div><div class="ttdeci">#define AI_NODE_ALL</div><div class="ttdoc">Bitmask including all node types, used by AiSceneWrite()</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:49</div></div>
<div class="ttc" id="agroup__ai__scene_html_ga0e29f1899cabe03a9df6a86f27bc6eba"><div class="ttname"><a href="group__ai__scene.html#ga0e29f1899cabe03a9df6a86f27bc6eba">AiSceneLoad</a></div><div class="ttdeci">AI_API bool AiSceneLoad(AtUniverse *universe, const char *filename, const AtParamValueMap *params=nullptr)</div><div class="ttdoc">Load all nodes from a scene file into a specific Arnold universe.</div><div class="ttdef"><b>Definition:</b> ai_scene.cpp:6</div></div>
</div><!-- fragment --><p >Supported format specific params:</p>
<table class="doxtable">
<tr>
<th>Scene format</th><th colspan="3">Supported load parameters </th></tr>
<tr>
<td>ASS</td><td><b>mask</b></td><td><em>INTEGER</em></td><td>Only node types matching this mask will be loaded </td></tr>
<tr>
<td rowspan="2">USD</td><td><b>mask</b></td><td><em>INTEGER</em></td><td>Only node types matching this mask will be loaded </td></tr>
<tr>
<td><b>frame</b></td><td><em>FLOAT</em></td><td>Load a given frame from the USD file </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe where the nodes will be created (NULL for default universe) </td></tr>
    <tr><td class="paramname">filename</td><td>input filename (extension will be used to determine scene format) </td></tr>
    <tr><td class="paramname">params</td><td>list of arbitrary params which will be interpreted by the specific scene format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was loaded succesfully, false otherwise </dd></dl>

</div>
</div>
<a id="ga44d7a8fd4348c653339408a922fdaf85" name="ga44d7a8fd4348c653339408a922fdaf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d7a8fd4348c653339408a922fdaf85">&#9670;&nbsp;</a></span>AiSceneWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiSceneWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtMetadataStore.html">AtMetadataStore</a> *&#160;</td>
          <td class="paramname"><em>mds</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write all nodes in the given universe to a scene file. </p>
<p >This function can selectively write all nodes in a given universe to a scene file, which format will be determined from the filename extension.</p>
<p >An arbitrary list of attributes can be passed, and these attributes can be used by specific file formats. For example, the .ass file format supports "mask", "binary" and "open_procs" attributes. Note these attributes might not work on other file formats.</p>
<p >For example, to write light nodes and camera nodes only, use: </p><div class="fragment"><div class="line">AtParamValueMap* params = <a class="code hl_function" href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a>();</div>
<div class="line">AiParamValueMapSetInt(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;mask&quot;</span>), <a class="code hl_define" href="group__ai__node__entry.html#gaf09bae1a8d33f8394318cd7960984b82">AI_NODE_LIGHT</a> + <a class="code hl_define" href="group__ai__node__entry.html#ga857f664c28910030841a774bf1898d0a">AI_NODE_CAMERA</a>);</div>
<div class="line"><a class="code hl_function" href="group__ai__scene.html#ga44d7a8fd4348c653339408a922fdaf85">AiSceneWrite</a>(universe, <span class="stringliteral">&quot;lightsncams.ass&quot;</span>, params);</div>
<div class="line"><a class="code hl_function" href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a>(params);</div>
<div class="ttc" id="agroup__ai__node__entry_html_ga857f664c28910030841a774bf1898d0a"><div class="ttname"><a href="group__ai__node__entry.html#ga857f664c28910030841a774bf1898d0a">AI_NODE_CAMERA</a></div><div class="ttdeci">#define AI_NODE_CAMERA</div><div class="ttdoc">Camera nodes (persp_camera, fisheye_camera, etc)</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:39</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gaf09bae1a8d33f8394318cd7960984b82"><div class="ttname"><a href="group__ai__node__entry.html#gaf09bae1a8d33f8394318cd7960984b82">AI_NODE_LIGHT</a></div><div class="ttdeci">#define AI_NODE_LIGHT</div><div class="ttdoc">Light source nodes (spot_light, etc)</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:40</div></div>
<div class="ttc" id="agroup__ai__scene_html_ga44d7a8fd4348c653339408a922fdaf85"><div class="ttname"><a href="group__ai__scene.html#ga44d7a8fd4348c653339408a922fdaf85">AiSceneWrite</a></div><div class="ttdeci">AI_API bool AiSceneWrite(AtUniverse *universe, const char *filename, const AtParamValueMap *params=nullptr, const AtMetadataStore *mds=NULL)</div><div class="ttdoc">Write all nodes in the given universe to a scene file.</div><div class="ttdef"><b>Definition:</b> ai_scene.cpp:18</div></div>
</div><!-- fragment --><p >To write all nodes of all types, use: </p><div class="fragment"><div class="line">AtParamValueMap* params = <a class="code hl_function" href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a>();</div>
<div class="line">AiParamValueMapSetInt(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;mask&quot;</span>), <a class="code hl_define" href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a>);</div>
<div class="line"><a class="code hl_function" href="group__ai__scene.html#ga44d7a8fd4348c653339408a922fdaf85">AiSceneWrite</a>(universe, <span class="stringliteral">&quot;everything.ass&quot;</span>, params); </div>
<div class="line"><a class="code hl_function" href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a>(params);</div>
</div><!-- fragment --><p >Supported format specific params:</p>
<table class="doxtable">
<tr>
<th>Scene format</th><th colspan="3">Supported write parameters </th></tr>
<tr>
<td rowspan="3">ASS</td><td><b>mask</b></td><td><em>INTEGER</em></td><td>Only node types matching this mask will be written </td></tr>
<tr>
<td><b>binary</b></td><td><em>BOOLEAN</em></td><td>Allow binary encoding in .ass files </td></tr>
<tr>
<td><b>open_procs</b></td><td><em>BOOLEAN</em></td><td>Procedurals will be expanded before writing </td></tr>
<tr>
<td>USD</td><td><b>mask</b></td><td><em>INTEGER</em></td><td>Only node types matching this mask will be written </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe whose contents will be written to the scene file (NULL for default universe) </td></tr>
    <tr><td class="paramname">filename</td><td>output filename (extension will be used to select scene format) </td></tr>
    <tr><td class="paramname">params</td><td>list of arbitrary params which will be interpreted by the specific scene format </td></tr>
    <tr><td class="paramname">mds</td><td>optional metadata store for writing metadata into the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was written succesfully, false otherwise </dd></dl>

</div>
</div>
<a id="ga416647a4f6a3318abd659938dbeba7d0" name="ga416647a4f6a3318abd659938dbeba7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga416647a4f6a3318abd659938dbeba7d0">&#9670;&nbsp;</a></span>AiSceneFormatSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiSceneFormatSupported </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the scene format corresponding to a given filename extension is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>scene file extension to check for support (should start with ".") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the format is supported, false otherwise </dd></dl>

</div>
</div>
<a id="ga80e17f38863b192efb9f229699758692" name="ga80e17f38863b192efb9f229699758692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e17f38863b192efb9f229699758692">&#9670;&nbsp;</a></span>AiSceneFormatIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> * AiSceneFormatIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get new scene format iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>New scene format iterator </dd></dl>

</div>
</div>
<a id="gac9ba3cf20dff4a89ecd9f6b6ed40405e" name="gac9ba3cf20dff4a89ecd9f6b6ed40405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ba3cf20dff4a89ecd9f6b6ed40405e">&#9670;&nbsp;</a></span>AiSceneFormatIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiSceneFormatIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys scene format iterator and releases any allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Scene format iterator to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac18b9e7b95f60a0486c63bc04e76d119" name="gac18b9e7b95f60a0486c63bc04e76d119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18b9e7b95f60a0486c63bc04e76d119">&#9670;&nbsp;</a></span>AiSceneFormatIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> * AiSceneFormatIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next supported scene format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Scene format iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about the next supported scene format </dd></dl>

</div>
</div>
<a id="gaeedc9e06a381c2b84203b55737db0681" name="gaeedc9e06a381c2b84203b55737db0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeedc9e06a381c2b84203b55737db0681">&#9670;&nbsp;</a></span>AiSceneFormatIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiSceneFormatIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatIterator.html">AtSceneFormatIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are more scene formats to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Scene format iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the iterator reached the last supported scene format </dd></dl>

</div>
</div>
<a id="gaff162b32562ce9f0172bfd39eaed3b83" name="gaff162b32562ce9f0172bfd39eaed3b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff162b32562ce9f0172bfd39eaed3b83">&#9670;&nbsp;</a></span>AiSceneFormatGetExtensionIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> * AiSceneFormatGetExtensionIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td>
          <td class="paramname"><em>format_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator over all supported extensions for this scene format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_data</td><td>Scene format data returned by <code>AiSceneFormatIteratorGetNext</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator </dd></dl>

</div>
</div>
<a id="ga5afa9c6087fc499d8406df347069b688" name="ga5afa9c6087fc499d8406df347069b688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5afa9c6087fc499d8406df347069b688">&#9670;&nbsp;</a></span>AiSceneFormatExtensionIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiSceneFormatExtensionIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys scene format extension iterator and releases any allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Scene format extension iterator to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad45979ee95de82fd3295cfd754827358" name="gad45979ee95de82fd3295cfd754827358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad45979ee95de82fd3295cfd754827358">&#9670;&nbsp;</a></span>AiSceneFormatExtensionIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const char * AiSceneFormatExtensionIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next supported scene format extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Scene format extension iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next supported extension </dd></dl>

</div>
</div>
<a id="ga453a1c54c2940df8518d0bf4403efc9b" name="ga453a1c54c2940df8518d0bf4403efc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga453a1c54c2940df8518d0bf4403efc9b">&#9670;&nbsp;</a></span>AiSceneFormatExtensionIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiSceneFormatExtensionIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatExtensionIterator.html">AtSceneFormatExtensionIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are more scene formats extensions to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Scene format extension iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the iterator reached the last supported scene format extension </dd></dl>

</div>
</div>
<a id="ga4f5540cf1fdb2942c38a4728e917f62e" name="ga4f5540cf1fdb2942c38a4728e917f62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5540cf1fdb2942c38a4728e917f62e">&#9670;&nbsp;</a></span>AiSceneFormatGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiSceneFormatGetName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td>
          <td class="paramname"><em>format_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the scene format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_data</td><td>Scene format data returned by <code>AiSceneFormatIteratorGetNext</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the scene format </dd></dl>

</div>
</div>
<a id="ga461ef8a7ae07d8e95cdaad26c5ad6625" name="ga461ef8a7ae07d8e95cdaad26c5ad6625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga461ef8a7ae07d8e95cdaad26c5ad6625">&#9670;&nbsp;</a></span>AiSceneFormatGetDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiSceneFormatGetDescription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td>
          <td class="paramname"><em>format_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a description of the scene format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_data</td><td>Scene format data returned by <code>AiSceneFormatIteratorGetNext</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Description of the scene format </dd></dl>

</div>
</div>
<a id="ga4db26d4a88c82592a69369fadf401752" name="ga4db26d4a88c82592a69369fadf401752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4db26d4a88c82592a69369fadf401752">&#9670;&nbsp;</a></span>AiSceneFormatSupportsReading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiSceneFormatSupportsReading </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td>
          <td class="paramname"><em>format_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the scene format supports reading from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_data</td><td>Scene format data returned by <code>AiSceneFormatIteratorGetNext</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can be read from file, false otherwise </dd></dl>

</div>
</div>
<a id="ga07c69e9d7b21db98b64bf25d13f9ee70" name="ga07c69e9d7b21db98b64bf25d13f9ee70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c69e9d7b21db98b64bf25d13f9ee70">&#9670;&nbsp;</a></span>AiSceneFormatSupportsWriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiSceneFormatSupportsWriting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td>
          <td class="paramname"><em>format_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the scene format supports writing to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_data</td><td>Scene format data returned by <code>AiSceneFormatIteratorGetNext</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can be written to a file, false otherwise </dd></dl>

</div>
</div>
<a id="ga9b3ce949256bb65e6352ce46f296ea2e" name="ga9b3ce949256bb65e6352ce46f296ea2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b3ce949256bb65e6352ce46f296ea2e">&#9670;&nbsp;</a></span>AiSceneFormatGetMetadataStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtMetadataStore.html">AtMetadataStore</a> * AiSceneFormatGetMetadataStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtSceneFormatData.html">AtSceneFormatData</a> *&#160;</td>
          <td class="paramname"><em>format_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get metadata for the scene format and its optional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_data</td><td>Scene format data returned by <code>AiSceneFormatIteratorGetNext</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Metadata store with all metadata for the scene format and its optional parameters </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
