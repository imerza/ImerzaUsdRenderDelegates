<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Shader Utility API</div></div>
</div><!--header-->
<div class="contents">

<p>Various utility functions for shader writers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Utility Helper Types</h2></td></tr>
<tr class="memitem:ga91ed48a428cd8774c8c39f4761448d07"><td class="memItemLeft" align="right" valign="top">typedef float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">AtFloatBumpEvaluator</a>) (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, void *data)</td></tr>
<tr class="memdesc:ga91ed48a428cd8774c8c39f4761448d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pointer points to float-based bump-mapping function for use by <a class="el" href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0" title="Computes and returns a normal based on the current shading point and the specified bump-function.">AiShaderGlobalsEvaluateBump()</a>.  <a href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">More...</a><br /></td></tr>
<tr class="separator:ga91ed48a428cd8774c8c39f4761448d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Lighting Functions</h2></td></tr>
<tr class="memitem:ga5510f32973d38f1009bdf0bf820269e8"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_GPU_FORCE_INLINE <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga5510f32973d38f1009bdf0bf820269e8">AiOcclusion</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Ng, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float mint, float maxt, float spread, float falloff, const <a class="el" href="structAtSampler.html">AtSampler</a> *sampler, <a class="el" href="structAtVector.html">AtVector</a> *Nbent)</td></tr>
<tr class="memdesc:ga5510f32973d38f1009bdf0bf820269e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ambient occlusion at a shading point.  <a href="group__ai__shader__util.html#ga5510f32973d38f1009bdf0bf820269e8">More...</a><br /></td></tr>
<tr class="separator:ga5510f32973d38f1009bdf0bf820269e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ff27830f5300c8d6fcb0a99aa9104b"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_GPU_FORCE_INLINE <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga86ff27830f5300c8d6fcb0a99aa9104b">AiSelfOcclusion</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Ng, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float mint, float maxt, float spread, float falloff, const <a class="el" href="structAtSampler.html">AtSampler</a> *sampler, <a class="el" href="structAtVector.html">AtVector</a> *Nbent)</td></tr>
<tr class="memdesc:ga86ff27830f5300c8d6fcb0a99aa9104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ambient occlusion at a shading point, only considering the same object.  <a href="group__ai__shader__util.html#ga86ff27830f5300c8d6fcb0a99aa9104b">More...</a><br /></td></tr>
<tr class="separator:ga86ff27830f5300c8d6fcb0a99aa9104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37d5953c115eb2b513776c0eff7770c"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad37d5953c115eb2b513776c0eff7770c">AiDirectDiffuse</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gad37d5953c115eb2b513776c0eff7770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direct-lighting component of the irradiance at a shading point.  <a href="group__ai__shader__util.html#gad37d5953c115eb2b513776c0eff7770c">More...</a><br /></td></tr>
<tr class="separator:gad37d5953c115eb2b513776c0eff7770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ed7745714b0f8c4a6f29e08fe7481a"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gac4ed7745714b0f8c4a6f29e08fe7481a">AiIndirectDiffuse</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight)</td></tr>
<tr class="memdesc:gac4ed7745714b0f8c4a6f29e08fe7481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indirect-lighting component of the irradiance at a shading point.  <a href="group__ai__shader__util.html#gac4ed7745714b0f8c4a6f29e08fe7481a">More...</a><br /></td></tr>
<tr class="separator:gac4ed7745714b0f8c4a6f29e08fe7481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">BSDF Utility Functions</h2></td></tr>
<tr class="memitem:ga5d3fd3f45289ec21865239fdc3a2a713"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga5d3fd3f45289ec21865239fdc3a2a713">AiReflect</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;I, const <a class="el" href="structAtVector.html">AtVector</a> &amp;N)</td></tr>
<tr class="memdesc:ga5d3fd3f45289ec21865239fdc3a2a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specular direction from incident direction I and normal N.  <a href="group__ai__shader__util.html#ga5d3fd3f45289ec21865239fdc3a2a713">More...</a><br /></td></tr>
<tr class="separator:ga5d3fd3f45289ec21865239fdc3a2a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42939b2d6257d96ce4fbd8c92bf0f6b"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtVectorDv.html">AtVectorDv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gae42939b2d6257d96ce4fbd8c92bf0f6b">AiReflectWithDerivs</a> (const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;I, const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;N)</td></tr>
<tr class="memdesc:gae42939b2d6257d96ce4fbd8c92bf0f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specular direction from incident direction I and normal N, with derivatives.  <a href="group__ai__shader__util.html#gae42939b2d6257d96ce4fbd8c92bf0f6b">More...</a><br /></td></tr>
<tr class="separator:gae42939b2d6257d96ce4fbd8c92bf0f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff019cef650c51ae54883146dc1a0ec2"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaff019cef650c51ae54883146dc1a0ec2">AiReflectSafe</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;I, const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Ng)</td></tr>
<tr class="memdesc:gaff019cef650c51ae54883146dc1a0ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specular direction from incident direction I and normal N.  <a href="group__ai__shader__util.html#gaff019cef650c51ae54883146dc1a0ec2">More...</a><br /></td></tr>
<tr class="separator:gaff019cef650c51ae54883146dc1a0ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4ba727b9897d1ef0cf8a02f539a3f8"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga9e4ba727b9897d1ef0cf8a02f539a3f8">AiRefract</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;I, const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, <a class="el" href="structAtVector.html">AtVector</a> &amp;T, float n1, float n2)</td></tr>
<tr class="memdesc:ga9e4ba727b9897d1ef0cf8a02f539a3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transmitted direction T from incident direction I and normal N.  <a href="group__ai__shader__util.html#ga9e4ba727b9897d1ef0cf8a02f539a3f8">More...</a><br /></td></tr>
<tr class="separator:ga9e4ba727b9897d1ef0cf8a02f539a3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879c5b7bdbed8b37ceeee63645f7e1fe"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga879c5b7bdbed8b37ceeee63645f7e1fe">AiRefractWithDerivs</a> (const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;I, const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;N, <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;T, float n1, float n2)</td></tr>
<tr class="memdesc:ga879c5b7bdbed8b37ceeee63645f7e1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transmitted direction T from incident direction I and normal N, with derivatives.  <a href="group__ai__shader__util.html#ga879c5b7bdbed8b37ceeee63645f7e1fe">More...</a><br /></td></tr>
<tr class="separator:ga879c5b7bdbed8b37ceeee63645f7e1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548a97409a1ffe3bd26de96b90e09546"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_CONST float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga548a97409a1ffe3bd26de96b90e09546">AiSchlickFresnel</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Rd, float Krn)</td></tr>
<tr class="memdesc:ga548a97409a1ffe3bd26de96b90e09546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors.  <a href="group__ai__shader__util.html#ga548a97409a1ffe3bd26de96b90e09546">More...</a><br /></td></tr>
<tr class="separator:ga548a97409a1ffe3bd26de96b90e09546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec31a65cd1f89eeee97a71fa54872156"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaec31a65cd1f89eeee97a71fa54872156">AiSchlickFresnelRGB</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Rd, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;Krn)</td></tr>
<tr class="memdesc:gaec31a65cd1f89eeee97a71fa54872156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized version of <a class="el" href="group__ai__shader__util.html#ga548a97409a1ffe3bd26de96b90e09546" title="Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors.">AiSchlickFresnel()</a> for RGB reflectance.  <a href="group__ai__shader__util.html#gaec31a65cd1f89eeee97a71fa54872156">More...</a><br /></td></tr>
<tr class="separator:gaec31a65cd1f89eeee97a71fa54872156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8422a2ea7f4a6e171e5e4bb01885dfbb"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga8422a2ea7f4a6e171e5e4bb01885dfbb">AiConductorFresnel</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Rd, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;n, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;k)</td></tr>
<tr class="memdesc:ga8422a2ea7f4a6e171e5e4bb01885dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Fresnel reflectance at a conductor interface for given normal and viewing vectors.  <a href="group__ai__shader__util.html#ga8422a2ea7f4a6e171e5e4bb01885dfbb">More...</a><br /></td></tr>
<tr class="separator:ga8422a2ea7f4a6e171e5e4bb01885dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82697e53c99313be8059575898ba611"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad82697e53c99313be8059575898ba611">AiDielectricFresnel</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;Rd, float eta)</td></tr>
<tr class="memdesc:gad82697e53c99313be8059575898ba611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Fresnel reflectance at a dielectric interface for given normal and viewing vectors.  <a href="group__ai__shader__util.html#gad82697e53c99313be8059575898ba611">More...</a><br /></td></tr>
<tr class="separator:gad82697e53c99313be8059575898ba611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a899fa26dc24016d26c9e592713ba08"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga7a899fa26dc24016d26c9e592713ba08">AiArtisticToConductorFresnel</a> (const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;reflectivity, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;edgetint, <a class="el" href="structAtRGB.html">AtRGB</a> &amp;n, <a class="el" href="structAtRGB.html">AtRGB</a> &amp;k)</td></tr>
<tr class="memdesc:ga7a899fa26dc24016d26c9e592713ba08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert artist friendly metallic Fresnel parameters to complex refractive indices for conductor Fresnel.  <a href="group__ai__shader__util.html#ga7a899fa26dc24016d26c9e592713ba08">More...</a><br /></td></tr>
<tr class="separator:ga7a899fa26dc24016d26c9e592713ba08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343b5e1c87d7905a2508761def4704e"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga7343b5e1c87d7905a2508761def4704e">AiFaceForward</a> (<a class="el" href="structAtVector.html">AtVector</a> &amp;N, const <a class="el" href="structAtVector.html">AtVector</a> &amp;I)</td></tr>
<tr class="memdesc:ga7343b5e1c87d7905a2508761def4704e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a normal vector face forward with respect to a given vector.  <a href="group__ai__shader__util.html#ga7343b5e1c87d7905a2508761def4704e">More...</a><br /></td></tr>
<tr class="separator:ga7343b5e1c87d7905a2508761def4704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Utility Functions</h2></td></tr>
<tr class="memitem:gaacc36a9b01af18da13e4044363b1619c"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaacc36a9b01af18da13e4044363b1619c">AiShaderGlobalsGetTriangle</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int key, <a class="el" href="structAtVector.html">AtVector</a> p[3])</td></tr>
<tr class="memdesc:gaacc36a9b01af18da13e4044363b1619c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get triangle vertices at a given motion key.  <a href="group__ai__shader__util.html#gaacc36a9b01af18da13e4044363b1619c">More...</a><br /></td></tr>
<tr class="separator:gaacc36a9b01af18da13e4044363b1619c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe9f856c030b56833996c2b25e8c797"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gacbe9f856c030b56833996c2b25e8c797">AiShaderGlobalsGetVertexNormals</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int key, <a class="el" href="structAtVector.html">AtVector</a> n[3])</td></tr>
<tr class="memdesc:gacbe9f856c030b56833996c2b25e8c797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get normal vectors for all triangle vertices.  <a href="group__ai__shader__util.html#gacbe9f856c030b56833996c2b25e8c797">More...</a><br /></td></tr>
<tr class="separator:gacbe9f856c030b56833996c2b25e8c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d7b514ebfbecef56e5d15ecd0e4ca"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga7e0d7b514ebfbecef56e5d15ecd0e4ca">AiShaderGlobalsGetVertexUVs</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="classAtString.html">AtString</a> uvset, <a class="el" href="structAtVector2.html">AtVector2</a> uv[3])</td></tr>
<tr class="memdesc:ga7e0d7b514ebfbecef56e5d15ecd0e4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UV coordinates for all triangle vertices.  <a href="group__ai__shader__util.html#ga7e0d7b514ebfbecef56e5d15ecd0e4ca">More...</a><br /></td></tr>
<tr class="separator:ga7e0d7b514ebfbecef56e5d15ecd0e4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b6a79b8ed49f68991434975594554e"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga48b6a79b8ed49f68991434975594554e">AiShaderGlobalsGetPolygon</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int key, <a class="el" href="structAtVector.html">AtVector</a> *p)</td></tr>
<tr class="memdesc:ga48b6a79b8ed49f68991434975594554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get polygon vertices at a given motion key.  <a href="group__ai__shader__util.html#ga48b6a79b8ed49f68991434975594554e">More...</a><br /></td></tr>
<tr class="separator:ga48b6a79b8ed49f68991434975594554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c80b10a3079e6c11891410346cfe3e6"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga3c80b10a3079e6c11891410346cfe3e6">AiShaderGlobalsGetUniformID</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga3c80b10a3079e6c11891410346cfe3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get unique per face, subdivision patch, curve or point ID.  <a href="group__ai__shader__util.html#ga3c80b10a3079e6c11891410346cfe3e6">More...</a><br /></td></tr>
<tr class="separator:ga3c80b10a3079e6c11891410346cfe3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e258595f6d98d14d6b71e8df621aee2"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga5e258595f6d98d14d6b71e8df621aee2">AiShaderGlobalsGetPositionAtTime</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float time, <a class="el" href="structAtVector.html">AtVector</a> &amp;P, <a class="el" href="structAtVector.html">AtVector</a> *N, <a class="el" href="structAtVector.html">AtVector</a> *Ng, <a class="el" href="structAtVector.html">AtVector</a> *Ns)</td></tr>
<tr class="memdesc:ga5e258595f6d98d14d6b71e8df621aee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reproject the shading point to a different time.  <a href="group__ai__shader__util.html#ga5e258595f6d98d14d6b71e8df621aee2">More...</a><br /></td></tr>
<tr class="separator:ga5e258595f6d98d14d6b71e8df621aee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283f55eaa4b258f0aaa769aa86cd7281"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_PURE <a class="el" href="structAtVector2.html">AtVector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga283f55eaa4b258f0aaa769aa86cd7281">AiShaderGlobalsGetPixelMotionVector</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float time0, float time1)</td></tr>
<tr class="memdesc:ga283f55eaa4b258f0aaa769aa86cd7281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute motion vector.  <a href="group__ai__shader__util.html#ga283f55eaa4b258f0aaa769aa86cd7281">More...</a><br /></td></tr>
<tr class="separator:ga283f55eaa4b258f0aaa769aa86cd7281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d559c4e509744f650a33fb43d2e33d"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gab9d559c4e509744f650a33fb43d2e33d">AiShaderGlobalsGetBBoxLocal</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gab9d559c4e509744f650a33fb43d2e33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object-space bounds of the current object.  <a href="group__ai__shader__util.html#gab9d559c4e509744f650a33fb43d2e33d">More...</a><br /></td></tr>
<tr class="separator:gab9d559c4e509744f650a33fb43d2e33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae317950ce946a0e301697bea55a43381"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gae317950ce946a0e301697bea55a43381">AiShaderGlobalsGetBBoxWorld</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gae317950ce946a0e301697bea55a43381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the world-space bounds of the current object.  <a href="group__ai__shader__util.html#gae317950ce946a0e301697bea55a43381">More...</a><br /></td></tr>
<tr class="separator:gae317950ce946a0e301697bea55a43381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9182468f4405d7d585ef2d0fca53df1f"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga9182468f4405d7d585ef2d0fca53df1f">AiShaderGlobalsGetShader</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga9182468f4405d7d585ef2d0fca53df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get shader assigned to the object at the current shading point.  <a href="group__ai__shader__util.html#ga9182468f4405d7d585ef2d0fca53df1f">More...</a><br /></td></tr>
<tr class="separator:ga9182468f4405d7d585ef2d0fca53df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50cb069f746f284d97ca756a2ea7d0a"><td class="memItemLeft" align="right" valign="top"><a id="gac50cb069f746f284d97ca756a2ea7d0a" name="gac50cb069f746f284d97ca756a2ea7d0a"></a>
AI_API AI_DEVICE int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsGetSelectedOutput</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="separator:gac50cb069f746f284d97ca756a2ea7d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88824abcb778dd086b92b095e7a0c3d8"><td class="memItemLeft" align="right" valign="top"><a id="ga88824abcb778dd086b92b095e7a0c3d8" name="ga88824abcb778dd086b92b095e7a0c3d8"></a>
AI_API AI_DEVICE AI_PURE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsTransformNormal</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtVector.html">AtVector</a> N, int space)</td></tr>
<tr class="separator:ga88824abcb778dd086b92b095e7a0c3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4a9ee8a046f81a42083efb50159343"><td class="memItemLeft" align="right" valign="top"><a id="ga0e4a9ee8a046f81a42083efb50159343" name="ga0e4a9ee8a046f81a42083efb50159343"></a>
AI_API AI_DEVICE AI_PURE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsTransformPoint</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtVector.html">AtVector</a> P, int space)</td></tr>
<tr class="separator:ga0e4a9ee8a046f81a42083efb50159343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7d747367d6f935d12db2f86cab3d90"><td class="memItemLeft" align="right" valign="top"><a id="gade7d747367d6f935d12db2f86cab3d90" name="gade7d747367d6f935d12db2f86cab3d90"></a>
AI_API AI_DEVICE AI_PURE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsTransformVector</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtVector.html">AtVector</a> V, int space)</td></tr>
<tr class="separator:gade7d747367d6f935d12db2f86cab3d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5dc706765ddc743175dc6191a0b79a2"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gae5dc706765ddc743175dc6191a0b79a2">AiShaderGlobalsSetTraceSet</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="classAtString.html">AtString</a> set, bool inclusive)</td></tr>
<tr class="memdesc:gae5dc706765ddc743175dc6191a0b79a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a trace-set string and assigns it to the shader globals.  <a href="group__ai__shader__util.html#gae5dc706765ddc743175dc6191a0b79a2">More...</a><br /></td></tr>
<tr class="separator:gae5dc706765ddc743175dc6191a0b79a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127a2210ba0cbde40e1d22b496a4fe04"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga127a2210ba0cbde40e1d22b496a4fe04">AiShaderGlobalsUnsetTraceSet</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga127a2210ba0cbde40e1d22b496a4fe04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the trace-set for this shader globals.  <a href="group__ai__shader__util.html#ga127a2210ba0cbde40e1d22b496a4fe04">More...</a><br /></td></tr>
<tr class="separator:ga127a2210ba0cbde40e1d22b496a4fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19de6ea88d0a25a21441f25f541766e"><td class="memItemLeft" align="right" valign="top">AI_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gac19de6ea88d0a25a21441f25f541766e">AiShaderGlobalsQuickAlloc</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, uint32_t size)</td></tr>
<tr class="memdesc:gac19de6ea88d0a25a21441f25f541766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates temporary memory for this ray-tree.  <a href="group__ai__shader__util.html#gac19de6ea88d0a25a21441f25f541766e">More...</a><br /></td></tr>
<tr class="separator:gac19de6ea88d0a25a21441f25f541766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a5ed58ed8dcf54e526a5be235f73c0"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0">AiShaderGlobalsEvaluateBump</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">AtFloatBumpEvaluator</a> bump_func, void *data)</td></tr>
<tr class="memdesc:ga71a5ed58ed8dcf54e526a5be235f73c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns a normal based on the current shading point and the specified bump-function.  <a href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0">More...</a><br /></td></tr>
<tr class="separator:ga71a5ed58ed8dcf54e526a5be235f73c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118cad952d25a08241902fa88973a35f"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga118cad952d25a08241902fa88973a35f">AiShaderGlobalsStochasticOpacity</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;opacity)</td></tr>
<tr class="memdesc:ga118cad952d25a08241902fa88973a35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs some optimizations and returns a modified opacity value which allows for increased performance.  <a href="group__ai__shader__util.html#ga118cad952d25a08241902fa88973a35f">More...</a><br /></td></tr>
<tr class="separator:ga118cad952d25a08241902fa88973a35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4934e9c36bc40f0b9c8ffb5f7309a29f"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga4934e9c36bc40f0b9c8ffb5f7309a29f">AiShaderGlobalsArea</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga4934e9c36bc40f0b9c8ffb5f7309a29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the world space area being shaded or displaced.  <a href="group__ai__shader__util.html#ga4934e9c36bc40f0b9c8ffb5f7309a29f">More...</a><br /></td></tr>
<tr class="separator:ga4934e9c36bc40f0b9c8ffb5f7309a29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35dd961276c0c70b05c91377cbf1efed"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga35dd961276c0c70b05c91377cbf1efed">AiShaderGlobalsEdgeLength</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga35dd961276c0c70b05c91377cbf1efed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum (for now) edge length of a given polygon.  <a href="group__ai__shader__util.html#ga35dd961276c0c70b05c91377cbf1efed">More...</a><br /></td></tr>
<tr class="separator:ga35dd961276c0c70b05c91377cbf1efed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32652a3e1ee52df7234de17eef14d3b1"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga32652a3e1ee52df7234de17eef14d3b1">AiWireframe</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float line_width, bool raster_space, int edge_type)</td></tr>
<tr class="memdesc:ga32652a3e1ee52df7234de17eef14d3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes wireframe shading for a mesh.  <a href="group__ai__shader__util.html#ga32652a3e1ee52df7234de17eef14d3b1">More...</a><br /></td></tr>
<tr class="separator:ga32652a3e1ee52df7234de17eef14d3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e7aa4ccd02c52c0c6feaa275dfc2c5"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga99e7aa4ccd02c52c0c6feaa275dfc2c5">AiShaderGlobalsIsObjectMatte</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga99e7aa4ccd02c52c0c6feaa275dfc2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the matte setting for the current object.  <a href="group__ai__shader__util.html#ga99e7aa4ccd02c52c0c6feaa275dfc2c5">More...</a><br /></td></tr>
<tr class="separator:ga99e7aa4ccd02c52c0c6feaa275dfc2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c7fe5b276d6b98ce783daf3606df38"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gac7c7fe5b276d6b98ce783daf3606df38">AiShaderGlobalsIsObjectOpaque</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gac7c7fe5b276d6b98ce783daf3606df38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the opaque setting for the current object.  <a href="group__ai__shader__util.html#gac7c7fe5b276d6b98ce783daf3606df38">More...</a><br /></td></tr>
<tr class="separator:gac7c7fe5b276d6b98ce783daf3606df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63525ec88ebbc329969abf5db859cd96"><td class="memItemLeft" align="right" valign="top">AI_DEVICE <a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga63525ec88ebbc329969abf5db859cd96">AiFaceViewer</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga63525ec88ebbc329969abf5db859cd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the surface normal face the viewer.  <a href="group__ai__shader__util.html#ga63525ec88ebbc329969abf5db859cd96">More...</a><br /></td></tr>
<tr class="separator:ga63525ec88ebbc329969abf5db859cd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Camera Information</h2></td></tr>
<tr class="memitem:gad42f91c8954bb803b6fd37c6590b2114"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114">AiCameraGetShutterStart</a> ()</td></tr>
<tr class="memdesc:gad42f91c8954bb803b6fd37c6590b2114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch camera shutter start.  <a href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114">More...</a><br /></td></tr>
<tr class="separator:gad42f91c8954bb803b6fd37c6590b2114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca3cda2dcbc6433aebb3a03e23e0e2b"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gadca3cda2dcbc6433aebb3a03e23e0e2b">AiCameraGetShutterEnd</a> ()</td></tr>
<tr class="memdesc:gadca3cda2dcbc6433aebb3a03e23e0e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch camera shutter end.  <a href="group__ai__shader__util.html#gadca3cda2dcbc6433aebb3a03e23e0e2b">More...</a><br /></td></tr>
<tr class="separator:gadca3cda2dcbc6433aebb3a03e23e0e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0972e6cfcec466fe38ac8e93f8ec29a5"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga0972e6cfcec466fe38ac8e93f8ec29a5">AiCameraToWorldMatrix</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, float time, <a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;out)</td></tr>
<tr class="memdesc:ga0972e6cfcec466fe38ac8e93f8ec29a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes camera to world matrix.  <a href="group__ai__shader__util.html#ga0972e6cfcec466fe38ac8e93f8ec29a5">More...</a><br /></td></tr>
<tr class="separator:ga0972e6cfcec466fe38ac8e93f8ec29a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc97297e4143357ccaa6d0144a94fcf"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga6cc97297e4143357ccaa6d0144a94fcf">AiWorldToCameraMatrix</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, float time, <a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;out)</td></tr>
<tr class="memdesc:ga6cc97297e4143357ccaa6d0144a94fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes world to camera matrix.  <a href="group__ai__shader__util.html#ga6cc97297e4143357ccaa6d0144a94fcf">More...</a><br /></td></tr>
<tr class="separator:ga6cc97297e4143357ccaa6d0144a94fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e47405eaf0a2c9714c695466272fc55"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga6e47405eaf0a2c9714c695466272fc55">AiWorldToScreenMatrix</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, float time, <a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;out)</td></tr>
<tr class="memdesc:ga6e47405eaf0a2c9714c695466272fc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes world to screen matrix.  <a href="group__ai__shader__util.html#ga6e47405eaf0a2c9714c695466272fc55">More...</a><br /></td></tr>
<tr class="separator:ga6e47405eaf0a2c9714c695466272fc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Environment Mappings</h2></td></tr>
<tr class="memitem:gaf39ec6643aa504aef17820c4ff254c92"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaf39ec6643aa504aef17820c4ff254c92">AiMappingMirroredBall</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, float &amp;u, float &amp;v)</td></tr>
<tr class="memdesc:gaf39ec6643aa504aef17820c4ff254c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping.  <a href="group__ai__shader__util.html#gaf39ec6643aa504aef17820c4ff254c92">More...</a><br /></td></tr>
<tr class="separator:gaf39ec6643aa504aef17820c4ff254c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c89210a0b2b8efe52e3abc53ff620e1"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga6c89210a0b2b8efe52e3abc53ff620e1">AiMappingAngularMap</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, float &amp;u, float &amp;v)</td></tr>
<tr class="memdesc:ga6c89210a0b2b8efe52e3abc53ff620e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping.  <a href="group__ai__shader__util.html#ga6c89210a0b2b8efe52e3abc53ff620e1">More...</a><br /></td></tr>
<tr class="separator:ga6c89210a0b2b8efe52e3abc53ff620e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0ed9baf69953f2537a0f73f2a55089"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga7f0ed9baf69953f2537a0f73f2a55089">AiMappingLatLong</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, float &amp;u, float &amp;v)</td></tr>
<tr class="memdesc:ga7f0ed9baf69953f2537a0f73f2a55089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapping.  <a href="group__ai__shader__util.html#ga7f0ed9baf69953f2537a0f73f2a55089">More...</a><br /></td></tr>
<tr class="separator:ga7f0ed9baf69953f2537a0f73f2a55089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Derivatives for Environment Mappings</h2></td></tr>
<tr class="memitem:ga5bdff947a8fb0a8cc6462e98de08c41d"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga5bdff947a8fb0a8cc6462e98de08c41d">AiMappingMirroredBallDerivs</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dDdx, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dDdy, float &amp;u, float &amp;v, float &amp;dudx, float &amp;dudy, float &amp;dvdx, float &amp;dvdy)</td></tr>
<tr class="memdesc:ga5bdff947a8fb0a8cc6462e98de08c41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#gaf39ec6643aa504aef17820c4ff254c92" title="Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping.">AiMappingMirroredBall()</a>.  <a href="group__ai__shader__util.html#ga5bdff947a8fb0a8cc6462e98de08c41d">More...</a><br /></td></tr>
<tr class="separator:ga5bdff947a8fb0a8cc6462e98de08c41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d14dc47038609c57ec93197e753066"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga19d14dc47038609c57ec93197e753066">AiMappingAngularMapDerivs</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dDdx, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dDdy, float &amp;u, float &amp;v, float &amp;dudx, float &amp;dudy, float &amp;dvdx, float &amp;dvdy)</td></tr>
<tr class="memdesc:ga19d14dc47038609c57ec93197e753066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#ga6c89210a0b2b8efe52e3abc53ff620e1" title="Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping.">AiMappingAngularMap()</a>.  <a href="group__ai__shader__util.html#ga19d14dc47038609c57ec93197e753066">More...</a><br /></td></tr>
<tr class="separator:ga19d14dc47038609c57ec93197e753066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01a320f6abec18e4e3bfd6c36be5156f"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga01a320f6abec18e4e3bfd6c36be5156f">AiMappingLatLongDerivs</a> (const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dDdx, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dDdy, float &amp;u, float &amp;v, float &amp;dudx, float &amp;dudy, float &amp;dvdx, float &amp;dvdy)</td></tr>
<tr class="memdesc:ga01a320f6abec18e4e3bfd6c36be5156f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#ga7f0ed9baf69953f2537a0f73f2a55089" title="Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapp...">AiMappingLatLong()</a>.  <a href="group__ai__shader__util.html#ga01a320f6abec18e4e3bfd6c36be5156f">More...</a><br /></td></tr>
<tr class="separator:ga01a320f6abec18e4e3bfd6c36be5156f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Coordinate Transformations</h2></td></tr>
<tr class="memitem:gaf94cdbe877ec107f1b36a8c2e8986def"><td class="memItemLeft" align="right" valign="top"><a id="gaf94cdbe877ec107f1b36a8c2e8986def" name="gaf94cdbe877ec107f1b36a8c2e8986def"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WORLD_TO_OBJECT</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf94cdbe877ec107f1b36a8c2e8986def"><td class="mdescLeft">&#160;</td><td class="mdescRight">World-to-object coordinate transformation. <br /></td></tr>
<tr class="separator:gaf94cdbe877ec107f1b36a8c2e8986def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63bd87c3f5d74f268f346fb3b4f8a93"><td class="memItemLeft" align="right" valign="top"><a id="gad63bd87c3f5d74f268f346fb3b4f8a93" name="gad63bd87c3f5d74f268f346fb3b4f8a93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_OBJECT_TO_WORLD</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gad63bd87c3f5d74f268f346fb3b4f8a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object-to-world coordinate transformation. <br /></td></tr>
<tr class="separator:gad63bd87c3f5d74f268f346fb3b4f8a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Wireframe Types</h2></td></tr>
<tr class="memitem:ga3e95eeae8b6cab6a1baac3c7fc41819e"><td class="memItemLeft" align="right" valign="top"><a id="ga3e95eeae8b6cab6a1baac3c7fc41819e" name="ga3e95eeae8b6cab6a1baac3c7fc41819e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WIREFRAME_TRIANGLES</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga3e95eeae8b6cab6a1baac3c7fc41819e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tessellated triangles <br  />
 <br /></td></tr>
<tr class="separator:ga3e95eeae8b6cab6a1baac3c7fc41819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169b8934e524b156cd9a47ef76ccd1a9"><td class="memItemLeft" align="right" valign="top"><a id="ga169b8934e524b156cd9a47ef76ccd1a9" name="ga169b8934e524b156cd9a47ef76ccd1a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WIREFRAME_POLYGONS</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga169b8934e524b156cd9a47ef76ccd1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tessellated polygons <br  />
 <br /></td></tr>
<tr class="separator:ga169b8934e524b156cd9a47ef76ccd1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51055e5eee9e21546beef9641f5d5bd"><td class="memItemLeft" align="right" valign="top"><a id="gad51055e5eee9e21546beef9641f5d5bd" name="gad51055e5eee9e21546beef9641f5d5bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WIREFRAME_PATCHES</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gad51055e5eee9e21546beef9641f5d5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patches before subdivision. <br /></td></tr>
<tr class="separator:gad51055e5eee9e21546beef9641f5d5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Various utility functions for shader writers. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga91ed48a428cd8774c8c39f4761448d07" name="ga91ed48a428cd8774c8c39f4761448d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91ed48a428cd8774c8c39f4761448d07">&#9670;&nbsp;</a></span>AtFloatBumpEvaluator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float(* AtFloatBumpEvaluator) (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pointer points to float-based bump-mapping function for use by <a class="el" href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0" title="Computes and returns a normal based on the current shading point and the specified bump-function.">AiShaderGlobalsEvaluateBump()</a>. </p>
<p >This function would return the displacement height for the given shading context. This function would be called three times (on three different shading contexts). The returned displacements would be used to generate a triangle from which a normal is calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>the current shading context </td></tr>
    <tr><td class="paramname">data</td><td>user-defined data pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bump/displacement height for the current shading context </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5510f32973d38f1009bdf0bf820269e8" name="ga5510f32973d38f1009bdf0bf820269e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5510f32973d38f1009bdf0bf820269e8">&#9670;&nbsp;</a></span>AiOcclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_GPU_FORCE_INLINE <a class="el" href="structAtRGB.html">AtRGB</a> AiOcclusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>falloff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtSampler.html">AtSampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Nbent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ambient occlusion at a shading point. </p>
<p >Computes an ambient occlusion lookup: fire a number of hemispherical rays, return the ratio of hits/rays and, optionally, also return the bent normal.</p>
<p >Note that if N is set to the mirror direction, you get <em>reflection occlusion</em>. In the extreme, if spread is set to 0, you get sharp <em>mirror occlusion</em>.</p>
<p >The geometric normal is used for detecting occlusion rays that penetrate into the surface, thus biasing the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>normal vector at the shading point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ng</td><td>geometric normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context where occlusion is evaluated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mint</td><td>minimum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxt</td><td>maximum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">spread</td><td>angular radian spread around the normal vector N, in the range [0,pi/2] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">falloff</td><td>exponential falloff rate for the occlusion along the ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td>a two-dimensional <a class="el" href="structAtSampler.html" title="Opaque data type for a sampler.">AtSampler</a> object that holds the number of samples to take per evaluation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nbent</td><td>if non-NULL, the average direction to non-occluded areas, or <em>bent normal</em>, will be stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ambient occlusion at {sg-&gt;P,N}</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__sampler.html#gab478318bab81593209cd6fa8b1960b27" title="Create a user sampler with a unique seed.">AiSampler</a> </dd></dl>

</div>
</div>
<a id="ga86ff27830f5300c8d6fcb0a99aa9104b" name="ga86ff27830f5300c8d6fcb0a99aa9104b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ff27830f5300c8d6fcb0a99aa9104b">&#9670;&nbsp;</a></span>AiSelfOcclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_GPU_FORCE_INLINE <a class="el" href="structAtRGB.html">AtRGB</a> AiSelfOcclusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>falloff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtSampler.html">AtSampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Nbent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ambient occlusion at a shading point, only considering the same object. </p>
<p >Computes an ambient occlusion lookup: fire a number of hemispherical rays, return the ratio of hits/rays and, optionally, also return the bent normal.</p>
<p >Note that if N is set to the mirror direction, you get <em>reflection occlusion</em>. In the extreme, if spread is set to 0, you get sharp <em>mirror occlusion</em>.</p>
<p >The geometric normal is used for detecting occlusion rays that penetrate into the surface, thus biasing the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>normal vector at the shading point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ng</td><td>geometric normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context where occlusion is evaluated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mint</td><td>minimum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxt</td><td>maximum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">spread</td><td>angular spread around the normal vector N, in the range [0,1], where 1 maps to 90 degrees (the full hemisphere) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">falloff</td><td>exponential falloff rate for the occlusion along the ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td>a two-dimensional <a class="el" href="structAtSampler.html" title="Opaque data type for a sampler.">AtSampler</a> object that holds the number of samples to take per evaluation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nbent</td><td>if non-NULL, the average direction to non-occluded areas, or <em>bent normal</em>, will be stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ambient occlusion at {sg-&gt;P,N}</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__sampler.html#gab478318bab81593209cd6fa8b1960b27" title="Create a user sampler with a unique seed.">AiSampler</a> </dd></dl>

</div>
</div>
<a id="gad37d5953c115eb2b513776c0eff7770c" name="gad37d5953c115eb2b513776c0eff7770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad37d5953c115eb2b513776c0eff7770c">&#9670;&nbsp;</a></span>AiDirectDiffuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtRGB.html">AtRGB</a> AiDirectDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the direct-lighting component of the irradiance at a shading point. </p>
<p >Computes the irradiance coming directly from all light sources in the scene, at shading point sg-&gt;P with normal N.</p>
<dl class="section note"><dt>Note</dt><dd>Deprecated, use shader closures instead of integrating light in shaders.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>normal vector that defines the hemisphere of incoming radiance </td></tr>
    <tr><td class="paramname">sg</td><td>shader globals context where irradiance is evaluated at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>direct component of diffuse irradiance </dd></dl>

</div>
</div>
<a id="gac4ed7745714b0f8c4a6f29e08fe7481a" name="gac4ed7745714b0f8c4a6f29e08fe7481a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ed7745714b0f8c4a6f29e08fe7481a">&#9670;&nbsp;</a></span>AiIndirectDiffuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtRGB.html">AtRGB</a> AiIndirectDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indirect-lighting component of the irradiance at a shading point. </p>
<p >Computes the indirect irradiance as an integral of the incident radiance over the hemisphere. The irradiance is computed at surface point sg-&gt;P.</p>
<p >This is usually called from shaders that need diffuse global illumination.</p>
<dl class="section note"><dt>Note</dt><dd>Deprecated, use shader closures instead of integrating light in shaders.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>normal vector that defines the hemisphere of incoming radiance </td></tr>
    <tr><td class="paramname">sg</td><td>shader globals context where irradiance is evaluated at </td></tr>
    <tr><td class="paramname">weight</td><td>RGB weight applied to the result and used for Russian roulette termination for more efficient rendering with high GI depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indirect component of diffuse irradiance </dd></dl>

</div>
</div>
<a id="ga5d3fd3f45289ec21865239fdc3a2a713" name="ga5d3fd3f45289ec21865239fdc3a2a713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3fd3f45289ec21865239fdc3a2a713">&#9670;&nbsp;</a></span>AiReflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtVector.html">AtVector</a> AiReflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns specular direction from incident direction I and normal N. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae42939b2d6257d96ce4fbd8c92bf0f6b" name="gae42939b2d6257d96ce4fbd8c92bf0f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42939b2d6257d96ce4fbd8c92bf0f6b">&#9670;&nbsp;</a></span>AiReflectWithDerivs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtVectorDv.html">AtVectorDv</a> AiReflectWithDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns specular direction from incident direction I and normal N, with derivatives. </p>
<p >This function can be used to implement BSDFs, where preserving ray differentials is important for texture filtering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff019cef650c51ae54883146dc1a0ec2" name="gaff019cef650c51ae54883146dc1a0ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff019cef650c51ae54883146dc1a0ec2">&#9670;&nbsp;</a></span>AiReflectSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtVector.html">AtVector</a> AiReflectSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns specular direction from incident direction I and normal N. </p>
<p >This function should be used for Phong-smoothed meshes instead of <a class="el" href="group__ai__shader__util.html#ga5d3fd3f45289ec21865239fdc3a2a713" title="Returns specular direction from incident direction I and normal N.">AiReflect()</a>. It makes sure the reflected vector doesn't penetrate below the geometric normal, which happens when the smooth (interpolated) normal points away from the viewing direction near silhouettes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramname">Ng</td><td>surface normal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e4ba727b9897d1ef0cf8a02f539a3f8" name="ga9e4ba727b9897d1ef0cf8a02f539a3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e4ba727b9897d1ef0cf8a02f539a3f8">&#9670;&nbsp;</a></span>AiRefract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE bool AiRefract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns transmitted direction T from incident direction I and normal N. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>outgoing transmitted direction with respect to N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n1</td><td>index of refraction (IOR) of the medium the incident ray travels in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n2</td><td>index of refraction (IOR) of the medium the transmitted ray travels in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if total internal reflection (TIR) occurs and there is no transmission </dd></dl>

</div>
</div>
<a id="ga879c5b7bdbed8b37ceeee63645f7e1fe" name="ga879c5b7bdbed8b37ceeee63645f7e1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879c5b7bdbed8b37ceeee63645f7e1fe">&#9670;&nbsp;</a></span>AiRefractWithDerivs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiRefractWithDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVectorDv.html">AtVectorDv</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns transmitted direction T from incident direction I and normal N, with derivatives. </p>
<p >This function can be used to implement BSDFs, where preserving ray differentials is important for texture filtering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>outgoing transmitted direction with respect to N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n1</td><td>index of refraction (IOR) of the medium the incident ray travels in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n2</td><td>index of refraction (IOR) of the medium the transmitted ray travels in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if total internal reflection (TIR) occurs and there is no transmission </dd></dl>

</div>
</div>
<a id="ga548a97409a1ffe3bd26de96b90e09546" name="ga548a97409a1ffe3bd26de96b90e09546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548a97409a1ffe3bd26de96b90e09546">&#9670;&nbsp;</a></span>AiSchlickFresnel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_CONST float AiSchlickFresnel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Krn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors. </p>
<p >Uses Schlick's cos^5 approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramname">V</td><td>incident viewing direction </td></tr>
    <tr><td class="paramname">Krn</td><td>reflectance at normal incidence, derived from the dielectric's IOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reflectance value, in [0,1] </dd></dl>

</div>
</div>
<a id="gaec31a65cd1f89eeee97a71fa54872156" name="gaec31a65cd1f89eeee97a71fa54872156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec31a65cd1f89eeee97a71fa54872156">&#9670;&nbsp;</a></span>AiSchlickFresnelRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST <a class="el" href="structAtRGB.html">AtRGB</a> AiSchlickFresnelRGB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>Krn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimized version of <a class="el" href="group__ai__shader__util.html#ga548a97409a1ffe3bd26de96b90e09546" title="Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors.">AiSchlickFresnel()</a> for RGB reflectance. </p>
<p >Using this function once avoids three calls to the scalar <a class="el" href="group__ai__shader__util.html#ga548a97409a1ffe3bd26de96b90e09546" title="Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors.">AiSchlickFresnel()</a>, saving a few CPU cycles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramname">V</td><td>incident viewing direction </td></tr>
    <tr><td class="paramname">Krn</td><td>reflectance at normal incidence, derived from the dielectric's IOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reflectance value, in [0,1] </dd></dl>

</div>
</div>
<a id="ga8422a2ea7f4a6e171e5e4bb01885dfbb" name="ga8422a2ea7f4a6e171e5e4bb01885dfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8422a2ea7f4a6e171e5e4bb01885dfbb">&#9670;&nbsp;</a></span>AiConductorFresnel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST <a class="el" href="structAtRGB.html">AtRGB</a> AiConductorFresnel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Fresnel reflectance at a conductor interface for given normal and viewing vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramname">V</td><td>incident viewing direction </td></tr>
    <tr><td class="paramname">n</td><td>real part of the complex refractive index </td></tr>
    <tr><td class="paramname">k</td><td>imaginary part of the complex refractive index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reflectance value, in [0,1] </dd></dl>

</div>
</div>
<a id="gad82697e53c99313be8059575898ba611" name="gad82697e53c99313be8059575898ba611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad82697e53c99313be8059575898ba611">&#9670;&nbsp;</a></span>AiDielectricFresnel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST float AiDielectricFresnel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Fresnel reflectance at a dielectric interface for given normal and viewing vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramname">V</td><td>incident viewing direction </td></tr>
    <tr><td class="paramname">eta</td><td>index of refraction (IOR) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reflectance value, in [0,1] </dd></dl>

</div>
</div>
<a id="ga7a899fa26dc24016d26c9e592713ba08" name="ga7a899fa26dc24016d26c9e592713ba08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a899fa26dc24016d26c9e592713ba08">&#9670;&nbsp;</a></span>AiArtisticToConductorFresnel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiArtisticToConductorFresnel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>reflectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>edgetint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert artist friendly metallic Fresnel parameters to complex refractive indices for conductor Fresnel. </p>
<dl class="section see"><dt>See also</dt><dd><a href="http://jcgt.org/published/0003/04/03/">http://jcgt.org/published/0003/04/03/</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reflectivity</td><td>reflectance at normal incidence </td></tr>
    <tr><td class="paramname">edgetint</td><td>color bias at edges </td></tr>
    <tr><td class="paramname">n</td><td>real part of the complex refractive index </td></tr>
    <tr><td class="paramname">k</td><td>imaginary part of the complex refractive index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7343b5e1c87d7905a2508761def4704e" name="ga7343b5e1c87d7905a2508761def4704e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7343b5e1c87d7905a2508761def4704e">&#9670;&nbsp;</a></span>AiFaceForward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiFaceForward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a normal vector face forward with respect to a given vector. </p>
<p >Reverses vector N if needed, in order to make it face forward with respect to vector I.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacc36a9b01af18da13e4044363b1619c" name="gaacc36a9b01af18da13e4044363b1619c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc36a9b01af18da13e4044363b1619c">&#9670;&nbsp;</a></span>AiShaderGlobalsGetTriangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE bool AiShaderGlobalsGetTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a>&#160;</td>
          <td class="paramname"><em>p</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get triangle vertices at a given motion key. </p>
<p >Return object-space triangle vertices at this shading context, at a given motion key. It is up to the caller to transform the vertices to world-space as needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>motion key to get the triangle at (if -1, vertices are interpolated at <code>sg-&gt;time</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>output array of triangle vertices in object-space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if there is no triangle to get vertices from.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga48b6a79b8ed49f68991434975594554e" title="Get polygon vertices at a given motion key.">AiShaderGlobalsGetPolygon</a> </dd></dl>

</div>
</div>
<a id="gacbe9f856c030b56833996c2b25e8c797" name="gacbe9f856c030b56833996c2b25e8c797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe9f856c030b56833996c2b25e8c797">&#9670;&nbsp;</a></span>AiShaderGlobalsGetVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiShaderGlobalsGetVertexNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a>&#160;</td>
          <td class="paramname"><em>n</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get normal vectors for all triangle vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>motion key to get the normals at (if -1, normals are interpolated at <code>sg-&gt;time</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>output array of triangle vertex normals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if there is no triangle to get normals from or if the mesh doesn't have vertex normals, or during displacement.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not available during displacement.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gaacc36a9b01af18da13e4044363b1619c" title="Get triangle vertices at a given motion key.">AiShaderGlobalsGetTriangle</a> </dd>
<dd>
<a class="el" href="group__ai__shader__util.html#ga7e0d7b514ebfbecef56e5d15ecd0e4ca" title="Get UV coordinates for all triangle vertices.">AiShaderGlobalsGetVertexUVs</a> </dd></dl>

</div>
</div>
<a id="ga7e0d7b514ebfbecef56e5d15ecd0e4ca" name="ga7e0d7b514ebfbecef56e5d15ecd0e4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0d7b514ebfbecef56e5d15ecd0e4ca">&#9670;&nbsp;</a></span>AiShaderGlobalsGetVertexUVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiShaderGlobalsGetVertexUVs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>uvset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector2.html">AtVector2</a>&#160;</td>
          <td class="paramname"><em>uv</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UV coordinates for all triangle vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">uvset</td><td>uv set this query refers to, if uvset is NULL or empty the default UVs will be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uv</td><td>output array of UV coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if there is no triangle to get UVs from or if the mesh doesn't have UV coordinates.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gaacc36a9b01af18da13e4044363b1619c" title="Get triangle vertices at a given motion key.">AiShaderGlobalsGetTriangle</a> </dd>
<dd>
<a class="el" href="group__ai__shader__util.html#gacbe9f856c030b56833996c2b25e8c797" title="Get normal vectors for all triangle vertices.">AiShaderGlobalsGetVertexNormals</a> </dd></dl>

</div>
</div>
<a id="ga48b6a79b8ed49f68991434975594554e" name="ga48b6a79b8ed49f68991434975594554e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b6a79b8ed49f68991434975594554e">&#9670;&nbsp;</a></span>AiShaderGlobalsGetPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE uint32_t AiShaderGlobalsGetPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get polygon vertices at a given motion key. </p>
<p >Return object-space polygon vertices at this shading context, at a given motion key. It is up to the caller to transform the vertices to world-space as needed.</p>
<p >Usage example: </p><div class="fragment"><div class="line">AtUInt32 numvertices = <a class="code hl_function" href="group__ai__shader__util.html#ga48b6a79b8ed49f68991434975594554e">AiShaderGlobalsGetPolygon</a>(sg, key, NULL);</div>
<div class="line"><a class="code hl_struct" href="structAtVector.html">AtVector</a>* vertices   = (<a class="code hl_struct" href="structAtVector.html">AtVector</a>*) <a class="code hl_function" href="group__ai__shader__util.html#gac19de6ea88d0a25a21441f25f541766e">AiShaderGlobalsQuickAlloc</a>(sg, np * <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structAtVector.html">AtVector</a>));</div>
<div class="line"><a class="code hl_function" href="group__ai__shader__util.html#ga48b6a79b8ed49f68991434975594554e">AiShaderGlobalsGetPolygon</a>(sg, key, vertices);</div>
<div class="line"><span class="comment">// do whatever process with the vertices</span></div>
<div class="ttc" id="agroup__ai__shader__util_html_ga48b6a79b8ed49f68991434975594554e"><div class="ttname"><a href="group__ai__shader__util.html#ga48b6a79b8ed49f68991434975594554e">AiShaderGlobalsGetPolygon</a></div><div class="ttdeci">AI_API AI_DEVICE uint32_t AiShaderGlobalsGetPolygon(const AtShaderGlobals *sg, int key, AtVector *p)</div><div class="ttdoc">Get polygon vertices at a given motion key.</div><div class="ttdef"><b>Definition:</b> ai_shaderglobals.cpp:212</div></div>
<div class="ttc" id="agroup__ai__shader__util_html_gac19de6ea88d0a25a21441f25f541766e"><div class="ttname"><a href="group__ai__shader__util.html#gac19de6ea88d0a25a21441f25f541766e">AiShaderGlobalsQuickAlloc</a></div><div class="ttdeci">AI_API void * AiShaderGlobalsQuickAlloc(const AtShaderGlobals *sg, uint32_t size)</div><div class="ttdoc">Allocates temporary memory for this ray-tree.</div><div class="ttdef"><b>Definition:</b> ai_shaderglobals.cpp:698</div></div>
<div class="ttc" id="astructAtVector_html"><div class="ttname"><a href="structAtVector.html">AtVector</a></div><div class="ttdoc">3D point (single precision)</div><div class="ttdef"><b>Definition:</b> ai_vector.h:30</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>motion key to get the polygon at (if -1, vertices are interpolated at <code>sg-&gt;time</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>if non-null, it will be filled with polygon vertices in object-space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of polygon vertices, or 0 if there is no polygon in <code>sg</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gaacc36a9b01af18da13e4044363b1619c" title="Get triangle vertices at a given motion key.">AiShaderGlobalsGetTriangle</a> </dd></dl>

</div>
</div>
<a id="ga3c80b10a3079e6c11891410346cfe3e6" name="ga3c80b10a3079e6c11891410346cfe3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c80b10a3079e6c11891410346cfe3e6">&#9670;&nbsp;</a></span>AiShaderGlobalsGetUniformID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE uint32_t AiShaderGlobalsGetUniformID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get unique per face, subdivision patch, curve or point ID. </p>
<p >This uniform ID may for example be used for randomizing colors per hair curve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uniform ID </dd></dl>

</div>
</div>
<a id="ga5e258595f6d98d14d6b71e8df621aee2" name="ga5e258595f6d98d14d6b71e8df621aee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e258595f6d98d14d6b71e8df621aee2">&#9670;&nbsp;</a></span>AiShaderGlobalsGetPositionAtTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiShaderGlobalsGetPositionAtTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtVector.html">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reproject the shading point to a different time. </p>
<p >The function will take in a shader globals and output a new position, smooth and geometric normal. Note that the normals are optional, if any of them is not needed, you may pass <code>NULL</code> to avoid their calculation.</p>
<p >A typical use of this function is to reproject the shading point to time=0, so that the new point can be used to index into a user-created spatial data structure that was built at time=0 and thus has no support for motion-blur. For example, a static, octree-based irradiance cache.</p>
<dl class="section note"><dt>Note</dt><dd>Normals not available during displacement (will not be computed).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>time at which <code>sg-&gt;P</code> will be reprojected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>reprojected <code>sg-&gt;P</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>reprojected <code>sg-&gt;N</code> (optional) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ng</td><td>reprojected <code>sg-&gt;Ng</code> (optional) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ns</td><td>reprojected <code>sg-&gt;Ns</code> (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga283f55eaa4b258f0aaa769aa86cd7281" name="ga283f55eaa4b258f0aaa769aa86cd7281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga283f55eaa4b258f0aaa769aa86cd7281">&#9670;&nbsp;</a></span>AiShaderGlobalsGetPixelMotionVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_PURE <a class="el" href="structAtVector2.html">AtVector2</a> AiShaderGlobalsGetPixelMotionVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute motion vector. </p>
<p >Measures the motion of the hit point in screen space during the given time interval. This can be used to implement screen space motion vector shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals for current hit point </td></tr>
    <tr><td class="paramname">time0</td><td>time from which to start the vector </td></tr>
    <tr><td class="paramname">time1</td><td>time at which to stop the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>amount of motion in raster space (pixels) </dd></dl>

</div>
</div>
<a id="gab9d559c4e509744f650a33fb43d2e33d" name="gab9d559c4e509744f650a33fb43d2e33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9d559c4e509744f650a33fb43d2e33d">&#9670;&nbsp;</a></span>AiShaderGlobalsGetBBoxLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a> AiShaderGlobalsGetBBoxLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the object-space bounds of the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object's bounding box in object-space </dd></dl>

</div>
</div>
<a id="gae317950ce946a0e301697bea55a43381" name="gae317950ce946a0e301697bea55a43381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae317950ce946a0e301697bea55a43381">&#9670;&nbsp;</a></span>AiShaderGlobalsGetBBoxWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a> AiShaderGlobalsGetBBoxWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the world-space bounds of the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object's bounding box in world-space </dd></dl>

</div>
</div>
<a id="ga9182468f4405d7d585ef2d0fca53df1f" name="ga9182468f4405d7d585ef2d0fca53df1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9182468f4405d7d585ef2d0fca53df1f">&#9670;&nbsp;</a></span>AiShaderGlobalsGetShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiShaderGlobalsGetShader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get shader assigned to the object at the current shading point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>root shader node </dd></dl>

</div>
</div>
<a id="gae5dc706765ddc743175dc6191a0b79a2" name="gae5dc706765ddc743175dc6191a0b79a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5dc706765ddc743175dc6191a0b79a2">&#9670;&nbsp;</a></span>AiShaderGlobalsSetTraceSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiShaderGlobalsSetTraceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a trace-set string and assigns it to the shader globals. </p>
<p >Any ray created on the basis of this shader globals, will use this trace-set.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since sg-&gt;traceset can be accessed <em>after</em> the assignment, it's possible (but unlikely) that someone will change the contents of the string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context where the trace-set will be stored </td></tr>
    <tr><td class="paramname">set</td><td>the trace-set string </td></tr>
    <tr><td class="paramname">inclusive</td><td>indicates if the trace-set is to be treated as an <em>inclusive</em> set, as opposed to an <em>exclusive</em> one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga127a2210ba0cbde40e1d22b496a4fe04" title="Resets the trace-set for this shader globals.">AiShaderGlobalsUnsetTraceSet</a> </dd></dl>

</div>
</div>
<a id="ga127a2210ba0cbde40e1d22b496a4fe04" name="ga127a2210ba0cbde40e1d22b496a4fe04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga127a2210ba0cbde40e1d22b496a4fe04">&#9670;&nbsp;</a></span>AiShaderGlobalsUnsetTraceSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiShaderGlobalsUnsetTraceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the trace-set for this shader globals. </p>
<p >Sets the trace-set to NULL which indicates that trace-sets are to be ignored. While the same behavior can be achieved by calling <a class="el" href="group__ai__shader__util.html#gae5dc706765ddc743175dc6191a0b79a2" title="Takes a trace-set string and assigns it to the shader globals.">AiShaderGlobalsSetTraceSet()</a> and either passing in a NULL, or passing the name of a trace-set that doesn't exist and setting <code>inclusive</code> to false, it is both cleaner and more efficient to use this function instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context where the trace-set will be removed from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gae5dc706765ddc743175dc6191a0b79a2" title="Takes a trace-set string and assigns it to the shader globals.">AiShaderGlobalsSetTraceSet</a> </dd></dl>

</div>
</div>
<a id="gac19de6ea88d0a25a21441f25f541766e" name="gac19de6ea88d0a25a21441f25f541766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19de6ea88d0a25a21441f25f541766e">&#9670;&nbsp;</a></span>AiShaderGlobalsQuickAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void * AiShaderGlobalsQuickAlloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates temporary memory for this ray-tree. </p>
<p >This function returns a block of memory that will be accessible until the camera ray for this sample is done. The memory is allocated from an internal memory pool that is flushed after each sub-pixel sample. This is much faster than allocating memory via <code>malloc()</code> or <a class="el" href="group__ai__allocate.html#ga981390c2ca8cfe4ab66746c87d1d0668" title="Arnold malloc() wrapper.">AiMalloc()</a>. This can be useful to exchange data of type pointer or string within shader networks or across rays by using message passing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>non-NULL shader globals context for the point being shaded </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a block of memory at least size bytes long or <code>NULL</code> if either parameter was <code>NULL</code> or 0 </dd></dl>

</div>
</div>
<a id="ga71a5ed58ed8dcf54e526a5be235f73c0" name="ga71a5ed58ed8dcf54e526a5be235f73c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a5ed58ed8dcf54e526a5be235f73c0">&#9670;&nbsp;</a></span>AiShaderGlobalsEvaluateBump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtVector.html">AtVector</a> AiShaderGlobalsEvaluateBump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">AtFloatBumpEvaluator</a>&#160;</td>
          <td class="paramname"><em>bump_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns a normal based on the current shading point and the specified bump-function. </p>
<p >This function will compute and return a perturbed normal based on the specified shading point and bump-mapping function. This function will create three new shader-globals contexts surrounding the shading point, and call the supplied bump-mapping function with the three new displaced shading contexts. Given a particular shading context, the bump-mapping function should return its associated displacement value (a float). The new normal is calculated based on a forward differencing of the the values returned by this bump-mapping function.</p>
<p >This function itself will not modify the incoming <a class="el" href="structAtShaderGlobals.html" title="Shader globals data structure.">AtShaderGlobals</a>, but it is possible that the bump-mapping function itself, or those functions that it might call, will modify the incoming 'sg'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context for the point whose perturbed normal is being computed </td></tr>
    <tr><td class="paramname">bump_func</td><td>a bump-mapping function which returns a float-based displacement amount. This function will be executed three times with three different shading point contexts. </td></tr>
    <tr><td class="paramname">data</td><td>an opaque user-pointer which is passed on to the bump-mapping function in order to help pass on state information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a perturbed normal for the current shading point </dd></dl>

</div>
</div>
<a id="ga118cad952d25a08241902fa88973a35f" name="ga118cad952d25a08241902fa88973a35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118cad952d25a08241902fa88973a35f">&#9670;&nbsp;</a></span>AiShaderGlobalsStochasticOpacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtRGB.html">AtRGB</a> AiShaderGlobalsStochasticOpacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs some optimizations and returns a modified opacity value which allows for increased performance. </p>
<p >The opacity value is equivalent and can be used instead of the provided opacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context for the point whose opacity is being applied </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity value upon which the optimizations are applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>modified opacity value </dd></dl>

</div>
</div>
<a id="ga4934e9c36bc40f0b9c8ffb5f7309a29f" name="ga4934e9c36bc40f0b9c8ffb5f7309a29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4934e9c36bc40f0b9c8ffb5f7309a29f">&#9670;&nbsp;</a></span>AiShaderGlobalsArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_PURE float AiShaderGlobalsArea </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the world space area being shaded or displaced. </p>
<p >Area differential on the shaded surface: </p><pre class="fragment">area = ||dPdx x dPdy||
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context at the shading point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>area at <code>sg</code> </dd></dl>

</div>
</div>
<a id="ga35dd961276c0c70b05c91377cbf1efed" name="ga35dd961276c0c70b05c91377cbf1efed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35dd961276c0c70b05c91377cbf1efed">&#9670;&nbsp;</a></span>AiShaderGlobalsEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_PURE float AiShaderGlobalsEdgeLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum (for now) edge length of a given polygon. </p>
<p >This is currently used by the heatmap code in the <code>utility</code> node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context at the shading point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum edge length of the polygon at <code>sg</code> </dd></dl>

</div>
</div>
<a id="ga32652a3e1ee52df7234de17eef14d3b1" name="ga32652a3e1ee52df7234de17eef14d3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32652a3e1ee52df7234de17eef14d3b1">&#9670;&nbsp;</a></span>AiWireframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_PURE float AiWireframe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>line_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>raster_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes wireframe shading for a mesh. </p>
<p >Returns 0 when the current point is close to the triangle's edges and 1 otherwise. A fractional value may be returned in between for anti-aliasing purposes. This can be used to render the wireframe of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context at the shading point </td></tr>
    <tr><td class="paramname">line_width</td><td>the size of the lines in either pixel-space or world-space </td></tr>
    <tr><td class="paramname">raster_space</td><td>if enabled, <code>line_width</code> works in pixel-space </td></tr>
    <tr><td class="paramname">edge_type</td><td>this value should be one of <code>AI_WIREFRAME_*</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a number in the range [0,1] </dd></dl>

</div>
</div>
<a id="ga99e7aa4ccd02c52c0c6feaa275dfc2c5" name="ga99e7aa4ccd02c52c0c6feaa275dfc2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99e7aa4ccd02c52c0c6feaa275dfc2c5">&#9670;&nbsp;</a></span>AiShaderGlobalsIsObjectMatte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiShaderGlobalsIsObjectMatte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the matte setting for the current object. </p>
<p >The matte setting when turned on will force the object to have an RGBA of zero. Surface shaders are not run when the object is both opaque and matte at the same time, and when it is not opaque the shaders will be run only to retrieve opacity for blending purposes.</p>
<dl class="section return"><dt>Returns</dt><dd>matte status for the object </dd></dl>

</div>
</div>
<a id="gac7c7fe5b276d6b98ce783daf3606df38" name="gac7c7fe5b276d6b98ce783daf3606df38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c7fe5b276d6b98ce783daf3606df38">&#9670;&nbsp;</a></span>AiShaderGlobalsIsObjectOpaque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiShaderGlobalsIsObjectOpaque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the opaque setting for the current object. </p>
<p >When objects are opaque, intersections against them can proceed faster as there is no need to process any ray hits beyond the object. It is expected that shaders will return a 1.0 RGB opacity when this is the case.</p>
<dl class="section return"><dt>Returns</dt><dd>opaque status for the object </dd></dl>

</div>
</div>
<a id="ga63525ec88ebbc329969abf5db859cd96" name="ga63525ec88ebbc329969abf5db859cd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63525ec88ebbc329969abf5db859cd96">&#9670;&nbsp;</a></span>AiFaceViewer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AI_DEVICE <a class="el" href="structAtVector.html">AtVector</a> AiFaceViewer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the surface normal face the viewer. </p>
<p >Returns a reversed vector sg-&gt;N if needed, in order to make it face forward with respect to viewing vector sg-&gt;Rd (not necessarily a camera ray).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>the current shading context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>viewer-facing normal vector </dd></dl>

</div>
</div>
<a id="gad42f91c8954bb803b6fd37c6590b2114" name="gad42f91c8954bb803b6fd37c6590b2114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad42f91c8954bb803b6fd37c6590b2114">&#9670;&nbsp;</a></span>AiCameraGetShutterStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE float AiCameraGetShutterStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch camera shutter start. </p>
<p >If this function is called inside of a node update, the below dependencies must be registered with <a class="el" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e" title="This version of the AiNodeAddDependency API is deprecated.">AiNodeAddDependency()</a>: render camera &mdash; shutter_start render options &mdash; camera</p>
<dl class="section return"><dt>Returns</dt><dd>shutter start time </dd></dl>

</div>
</div>
<a id="gadca3cda2dcbc6433aebb3a03e23e0e2b" name="gadca3cda2dcbc6433aebb3a03e23e0e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadca3cda2dcbc6433aebb3a03e23e0e2b">&#9670;&nbsp;</a></span>AiCameraGetShutterEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE float AiCameraGetShutterEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch camera shutter end. </p>
<p >This function correctly accounts for closed shutters and disabled motion blur.</p>
<p >If this function is called inside of a node update, the below dependencies must be registered with <a class="el" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e" title="This version of the AiNodeAddDependency API is deprecated.">AiNodeAddDependency()</a>: render camera &mdash; shutter_start, shutter_end render options &mdash; camera, ignore_motion</p>
<dl class="section return"><dt>Returns</dt><dd>shutter end time </dd></dl>

</div>
</div>
<a id="ga0972e6cfcec466fe38ac8e93f8ec29a5" name="ga0972e6cfcec466fe38ac8e93f8ec29a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0972e6cfcec466fe38ac8e93f8ec29a5">&#9670;&nbsp;</a></span>AiCameraToWorldMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiCameraToWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes camera to world matrix. </p>
<p >Computes the matrix that transforms between camera space and world space. Camera space is defined such that +x is right, +y is up and looks down -z. This function accounts for camera motion blur by calculating the matrix at the requested time. If you are not interested in motion information, you can use options.reference_time or <a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start.">AiCameraGetShutterStart()</a> for time.</p>
<p >If the provided node is invalid, not a camera or otherwise not initialized this function will return the identity matrix.</p>
<p >If this function is called inside of a node update, the below dependencies must be registered with <a class="el" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e" title="This version of the AiNodeAddDependency API is deprecated.">AiNodeAddDependency()</a>: render camera &mdash; matrix, motion_start, motion_end render options &mdash; camera</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>camera node to get matrix from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>absolute time at which to calculate the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>this matrix will be filled with the camera to world matrix for the requested time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start.">AiCameraGetShutterStart</a> </dd></dl>

</div>
</div>
<a id="ga6cc97297e4143357ccaa6d0144a94fcf" name="ga6cc97297e4143357ccaa6d0144a94fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc97297e4143357ccaa6d0144a94fcf">&#9670;&nbsp;</a></span>AiWorldToCameraMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiWorldToCameraMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes world to camera matrix. </p>
<p >Computes the matrix that transforms between world space and camera space. Camera space is defined such that +x is right, +y is up and looks down -z. This function accounts for camera motion blur by calculating the matrix at the requested time. If you are not interested in motion information, you can use options.reference_time or <a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start.">AiCameraGetShutterStart()</a> for time.</p>
<p >If the provided node is invalid, not a camera or otherwise not initialized this function will return the identity matrix.</p>
<p >If this function is called inside of a node update, the below dependencies must be registered with <a class="el" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e" title="This version of the AiNodeAddDependency API is deprecated.">AiNodeAddDependency()</a>: render camera &mdash; matrix, motion_start, motion_end render options &mdash; camera</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>camera node to get matrix from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>absolute time at which to calculate the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>this matrix will be filled with the world to camera matrix for the requested time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start.">AiCameraGetShutterStart</a> </dd></dl>

</div>
</div>
<a id="ga6e47405eaf0a2c9714c695466272fc55" name="ga6e47405eaf0a2c9714c695466272fc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e47405eaf0a2c9714c695466272fc55">&#9670;&nbsp;</a></span>AiWorldToScreenMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiWorldToScreenMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes world to screen matrix. </p>
<p >Computes the matrix that transforms between world space and screen space. Screen space is defined such that +x is right, +y is up and looks down +z. After a homogenous transform and normalization by w, you will have x and y in [-1,+1] and z in [0,1] (which correspond to near and far clipping planes).</p>
<p >This function accounts for camera motion blur by calculating the matrix at the requested time. If you are not interested in motion information, you can use options.reference_time or <a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start.">AiCameraGetShutterStart()</a> for time.</p>
<p >If the provided node is invalid, not a camera or otherwise not initialized this function will return the identity matrix.</p>
<p >If this function is called inside of a node update, the below dependencies must be registered with <a class="el" href="group__ai__nodes.html#ga8f24f17347975bc830b2990545a58c1e" title="This version of the AiNodeAddDependency API is deprecated.">AiNodeAddDependency()</a>: render options &mdash; camera, xres, yres, pixel_aspect_ratio render camera &mdash; use AtString() as the parameter name as this function depends on most camera parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>camera node to get matrix from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>absolute time at which to calculate the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>this matrix will be filled with the world to screen matrix for the requested time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start.">AiCameraGetShutterStart</a> </dd></dl>

</div>
</div>
<a id="gaf39ec6643aa504aef17820c4ff254c92" name="gaf39ec6643aa504aef17820c4ff254c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf39ec6643aa504aef17820c4ff254c92">&#9670;&nbsp;</a></span>AiMappingMirroredBall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingMirroredBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>world-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>location in which to write v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c89210a0b2b8efe52e3abc53ff620e1" name="ga6c89210a0b2b8efe52e3abc53ff620e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c89210a0b2b8efe52e3abc53ff620e1">&#9670;&nbsp;</a></span>AiMappingAngularMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingAngularMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>world-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>location in which to write v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f0ed9baf69953f2537a0f73f2a55089" name="ga7f0ed9baf69953f2537a0f73f2a55089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0ed9baf69953f2537a0f73f2a55089">&#9670;&nbsp;</a></span>AiMappingLatLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingLatLong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>location in which to write v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bdff947a8fb0a8cc6462e98de08c41d" name="ga5bdff947a8fb0a8cc6462e98de08c41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bdff947a8fb0a8cc6462e98de08c41d">&#9670;&nbsp;</a></span>AiMappingMirroredBallDerivs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiMappingMirroredBallDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#gaf39ec6643aa504aef17820c4ff254c92" title="Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping.">AiMappingMirroredBall()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>world-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>pointer to location in which to write dvdy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19d14dc47038609c57ec93197e753066" name="ga19d14dc47038609c57ec93197e753066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d14dc47038609c57ec93197e753066">&#9670;&nbsp;</a></span>AiMappingAngularMapDerivs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiMappingAngularMapDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#ga6c89210a0b2b8efe52e3abc53ff620e1" title="Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping.">AiMappingAngularMap()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>world-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>pointer to location in which to write dvdy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga01a320f6abec18e4e3bfd6c36be5156f" name="ga01a320f6abec18e4e3bfd6c36be5156f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01a320f6abec18e4e3bfd6c36be5156f">&#9670;&nbsp;</a></span>AiMappingLatLongDerivs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiMappingLatLongDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#ga7f0ed9baf69953f2537a0f73f2a55089" title="Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapp...">AiMappingLatLong()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>world-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>pointer to location in which to write dvdy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
