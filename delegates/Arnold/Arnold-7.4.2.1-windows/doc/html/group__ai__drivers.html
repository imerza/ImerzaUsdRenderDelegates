<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Output Driver Nodes</div></div>
</div><!--header-->
<div class="contents">

<p>Construction and manipulation of driver nodes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Node methods structure.  <a href="structAtDriverNodeMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga207e56f175cfa9496b4940fb09a1b470"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga207e56f175cfa9496b4940fb09a1b470">AI_DRIVER_NODE_EXPORT_METHODS</a>(tag)</td></tr>
<tr class="memdesc:ga207e56f175cfa9496b4940fb09a1b470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output Driver node methods exporter.  <a href="group__ai__drivers.html#ga207e56f175cfa9496b4940fb09a1b470">More...</a><br /></td></tr>
<tr class="separator:ga207e56f175cfa9496b4940fb09a1b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae9fb0df1baae5d7f8d0ad6af481e5629"><td class="memItemLeft" align="right" valign="top"><a id="gae9fb0df1baae5d7f8d0ad6af481e5629" name="gae9fb0df1baae5d7f8d0ad6af481e5629"></a>
bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverSupportsPixelType</b> )(const <a class="el" href="structAtNode.html">AtNode</a> *, uint8_t)</td></tr>
<tr class="separator:gae9fb0df1baae5d7f8d0ad6af481e5629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d0de798eb94247372872b0f892c1fa"><td class="memItemLeft" align="right" valign="top"><a id="gaa6d0de798eb94247372872b0f892c1fa" name="gaa6d0de798eb94247372872b0f892c1fa"></a>
const char **(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverExtension</b> )()</td></tr>
<tr class="separator:gaa6d0de798eb94247372872b0f892c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7891b821ceb5b588e236ca32bf957868"><td class="memItemLeft" align="right" valign="top"><a id="ga7891b821ceb5b588e236ca32bf957868" name="ga7891b821ceb5b588e236ca32bf957868"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverOpen</b> )(<a class="el" href="structAtNode.html">AtNode</a> *, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a> *, <a class="el" href="structAtBBox2.html">AtBBox2</a>, <a class="el" href="structAtBBox2.html">AtBBox2</a>, int)</td></tr>
<tr class="separator:ga7891b821ceb5b588e236ca32bf957868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcb96d6ad49fb7532ae000f831024f3"><td class="memItemLeft" align="right" valign="top"><a id="gaddcb96d6ad49fb7532ae000f831024f3" name="gaddcb96d6ad49fb7532ae000f831024f3"></a>
bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverNeedsBucket</b> )(<a class="el" href="structAtNode.html">AtNode</a> *, int, int, int, int, uint16_t)</td></tr>
<tr class="separator:gaddcb96d6ad49fb7532ae000f831024f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63641059ba701667b9a0d7979468adeb"><td class="memItemLeft" align="right" valign="top"><a id="ga63641059ba701667b9a0d7979468adeb" name="ga63641059ba701667b9a0d7979468adeb"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverPrepareBucket</b> )(<a class="el" href="structAtNode.html">AtNode</a> *, int, int, int, int, uint16_t)</td></tr>
<tr class="separator:ga63641059ba701667b9a0d7979468adeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87276b2fb6a6f1bafe78a3b1fe540286"><td class="memItemLeft" align="right" valign="top"><a id="ga87276b2fb6a6f1bafe78a3b1fe540286" name="ga87276b2fb6a6f1bafe78a3b1fe540286"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverProcessBucket</b> )(<a class="el" href="structAtNode.html">AtNode</a> *, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a> *, struct AtAOVSampleIterator *, int, int, int, int, uint16_t)</td></tr>
<tr class="separator:ga87276b2fb6a6f1bafe78a3b1fe540286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69dcc1da998b9043f450edd2881f6ce8"><td class="memItemLeft" align="right" valign="top"><a id="ga69dcc1da998b9043f450edd2881f6ce8" name="ga69dcc1da998b9043f450edd2881f6ce8"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverWriteBucket</b> )(<a class="el" href="structAtNode.html">AtNode</a> *, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a> *, struct AtAOVSampleIterator *, int, int, int, int)</td></tr>
<tr class="separator:ga69dcc1da998b9043f450edd2881f6ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0d8f25f2b3ee3258a959dca2a33e4a"><td class="memItemLeft" align="right" valign="top"><a id="ga7a0d8f25f2b3ee3258a959dca2a33e4a" name="ga7a0d8f25f2b3ee3258a959dca2a33e4a"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtDriverNodeMethods::DriverClose</b> )(<a class="el" href="structAtNode.html">AtNode</a> *, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a> *)</td></tr>
<tr class="separator:ga7a0d8f25f2b3ee3258a959dca2a33e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Quantization and Dithering</h2></td></tr>
<tr class="memitem:ga2de59bdc8d63de0dc48fba9f9a0992e0"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0">AiQuantize8bit</a> (int x, int y, int i, float value, bool dither)</td></tr>
<tr class="memdesc:ga2de59bdc8d63de0dc48fba9f9a0992e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize a floating point number down to an 8-bit integer.  <a href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0">More...</a><br /></td></tr>
<tr class="separator:ga2de59bdc8d63de0dc48fba9f9a0992e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae614ea72f07d143728642cff6288ca5d"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gae614ea72f07d143728642cff6288ca5d">AiQuantize16bit</a> (int x, int y, int i, float value, bool dither)</td></tr>
<tr class="memdesc:gae614ea72f07d143728642cff6288ca5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize a floating point number down to a 16-bit integer.  <a href="group__ai__drivers.html#gae614ea72f07d143728642cff6288ca5d">More...</a><br /></td></tr>
<tr class="separator:gae614ea72f07d143728642cff6288ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">API for Driver Writers</h2></td></tr>
<tr class="memitem:ga99dfebdcd9643a87afc0ca8304b90bba"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga99dfebdcd9643a87afc0ca8304b90bba">AiDriverInitialize</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, bool supports_multiple_outputs)</td></tr>
<tr class="memdesc:ga99dfebdcd9643a87afc0ca8304b90bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes the driver structure.  <a href="group__ai__drivers.html#ga99dfebdcd9643a87afc0ca8304b90bba">More...</a><br /></td></tr>
<tr class="separator:ga99dfebdcd9643a87afc0ca8304b90bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b5e913dab41dae23ca287fb732fc79"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga38b5e913dab41dae23ca287fb732fc79">AiRawDriverInitialize</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char **required_aovs, bool requires_depth)</td></tr>
<tr class="memdesc:ga38b5e913dab41dae23ca287fb732fc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes the driver structure.  <a href="group__ai__drivers.html#ga38b5e913dab41dae23ca287fb732fc79">More...</a><br /></td></tr>
<tr class="separator:ga38b5e913dab41dae23ca287fb732fc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac511a54e0b2a8d2c9bf776b11a58034c"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gac511a54e0b2a8d2c9bf776b11a58034c">AiDriverGetMatrices</a> (<a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;world_to_camera, <a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;world_to_screen)</td></tr>
<tr class="memdesc:gac511a54e0b2a8d2c9bf776b11a58034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Renderman compliant matrices from the active camera for use in file headers.  <a href="group__ai__drivers.html#gac511a54e0b2a8d2c9bf776b11a58034c">More...</a><br /></td></tr>
<tr class="separator:gac511a54e0b2a8d2c9bf776b11a58034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed1ea73f137e49e219c404c4ac4f3f6"><td class="memItemLeft" align="right" valign="top"><a id="ga0ed1ea73f137e49e219c404c4ac4f3f6" name="ga0ed1ea73f137e49e219c404c4ac4f3f6"></a>
AI_API const char **&#160;</td><td class="memItemRight" valign="bottom"><b>AiDriverExtension</b> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *node_entry)</td></tr>
<tr class="memdesc:ga0ed1ea73f137e49e219c404c4ac4f3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a driver's <a class="el" href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">driver_extension</a> method which returns a NULL-terminated array of filename extensions supported by this driver (note: uses the node_entry as this is a "static" method) <br /></td></tr>
<tr class="separator:ga0ed1ea73f137e49e219c404c4ac4f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05162d912bf2264738d6f5926e438984"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga05162d912bf2264738d6f5926e438984">AiFindDriverType</a> (const char *extension)</td></tr>
<tr class="memdesc:ga05162d912bf2264738d6f5926e438984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get correct driver node type from an extension.  <a href="group__ai__drivers.html#ga05162d912bf2264738d6f5926e438984">More...</a><br /></td></tr>
<tr class="separator:ga05162d912bf2264738d6f5926e438984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Method Declarations</h2></td></tr>
<tr class="memitem:gad18183b3cd0bc436a8087ca1d25850ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">driver_supports_pixel_type</a>&#160;&#160;&#160;static bool DriverSupportsPixelType(const <a class="el" href="structAtNode.html">AtNode</a>* node, uint8_t pixel_type)</td></tr>
<tr class="memdesc:gad18183b3cd0bc436a8087ca1d25850ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_supports_pixel_type declaration.  <a href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">More...</a><br /></td></tr>
<tr class="separator:gad18183b3cd0bc436a8087ca1d25850ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b8895e83f19a5cbf53091bb52dd0e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">driver_extension</a>&#160;&#160;&#160;static const char** DriverExtension()</td></tr>
<tr class="memdesc:gac0b8895e83f19a5cbf53091bb52dd0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_extension method declaration.  <a href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">More...</a><br /></td></tr>
<tr class="separator:gac0b8895e83f19a5cbf53091bb52dd0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4c1392f7280dcf596d833b27c63257"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga5c4c1392f7280dcf596d833b27c63257">driver_open</a>&#160;&#160;&#160;static void DriverOpen(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator, <a class="el" href="structAtBBox2.html">AtBBox2</a> display_window, <a class="el" href="structAtBBox2.html">AtBBox2</a> data_window, int bucket_size)</td></tr>
<tr class="memdesc:ga5c4c1392f7280dcf596d833b27c63257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_open method declaration.  <a href="group__ai__drivers.html#ga5c4c1392f7280dcf596d833b27c63257">More...</a><br /></td></tr>
<tr class="separator:ga5c4c1392f7280dcf596d833b27c63257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea47f8f7451d75112be4bfb1da5611b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gaea47f8f7451d75112be4bfb1da5611b5">driver_needs_bucket</a>&#160;&#160;&#160;static bool DriverNeedsBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, uint16_t tid)</td></tr>
<tr class="memdesc:gaea47f8f7451d75112be4bfb1da5611b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_needs_bucket method declaration.  <a href="group__ai__drivers.html#gaea47f8f7451d75112be4bfb1da5611b5">More...</a><br /></td></tr>
<tr class="separator:gaea47f8f7451d75112be4bfb1da5611b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0171f32654d3704a27b3177cfea5fc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gac0171f32654d3704a27b3177cfea5fc6">driver_prepare_bucket</a>&#160;&#160;&#160;static void DriverPrepareBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, uint16_t tid)</td></tr>
<tr class="memdesc:gac0171f32654d3704a27b3177cfea5fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_prepare_bucket method declaration.  <a href="group__ai__drivers.html#gac0171f32654d3704a27b3177cfea5fc6">More...</a><br /></td></tr>
<tr class="separator:gac0171f32654d3704a27b3177cfea5fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad581a889a481b9c7ad1fddf92c2bc8b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gad581a889a481b9c7ad1fddf92c2bc8b7">driver_process_bucket</a>&#160;&#160;&#160;static void DriverProcessBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, uint16_t tid)</td></tr>
<tr class="memdesc:gad581a889a481b9c7ad1fddf92c2bc8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_process_bucket method declaration.  <a href="group__ai__drivers.html#gad581a889a481b9c7ad1fddf92c2bc8b7">More...</a><br /></td></tr>
<tr class="separator:gad581a889a481b9c7ad1fddf92c2bc8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7734e3bcc6deff211dec384a840fb09b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga7734e3bcc6deff211dec384a840fb09b">driver_write_bucket</a>&#160;&#160;&#160;static void DriverWriteBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y)</td></tr>
<tr class="memdesc:ga7734e3bcc6deff211dec384a840fb09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_write_bucket method declaration.  <a href="group__ai__drivers.html#ga7734e3bcc6deff211dec384a840fb09b">More...</a><br /></td></tr>
<tr class="separator:ga7734e3bcc6deff211dec384a840fb09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016be0537a02f4b1db64c69dd9667b71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga016be0537a02f4b1db64c69dd9667b71">driver_close</a>&#160;&#160;&#160;static void DriverClose(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator)</td></tr>
<tr class="memdesc:ga016be0537a02f4b1db64c69dd9667b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_close method declaration.  <a href="group__ai__drivers.html#ga016be0537a02f4b1db64c69dd9667b71">More...</a><br /></td></tr>
<tr class="separator:ga016be0537a02f4b1db64c69dd9667b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Construction and manipulation of driver nodes. </p>
<p >Arnold supports pluggable output-file writers called "drivers". This output driver mechanism provides a pluggable architecture for writing output image files using Arnold's built-in AOV pipeline. It is also possible to write to arbitrary devices, such as a window display.</p>
<p >AOVs (Arbitrary Output Values) are organized into "layers", with each layer having a particular type (such as FLOAT or RGBA).</p>
<p >Drivers receive AOVs one bucket at a time which is perfectly suited to image-formats that are tiled. An iterator allows the driver to iterate through all the AOV layers contained in the bucket. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga207e56f175cfa9496b4940fb09a1b470" name="ga207e56f175cfa9496b4940fb09a1b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga207e56f175cfa9496b4940fb09a1b470">&#9670;&nbsp;</a></span>AI_DRIVER_NODE_EXPORT_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_DRIVER_NODE_EXPORT_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">AI_INSTANCE_COMMON_METHODS                         \</a></div>
<div class="line"><a class="code hl_define" href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">driver_supports_pixel_type</a>;                        \</div>
<div class="line">driver_extension;                                  \</div>
<div class="line">driver_open;                                       \</div>
<div class="line">driver_needs_bucket;                               \</div>
<div class="line">driver_prepare_bucket;                             \</div>
<div class="line">driver_process_bucket;                             \</div>
<div class="line">driver_write_bucket;                               \</div>
<div class="line">driver_close;                                      \</div>
<div class="line">static <a class="code hl_struct" href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a> ai_driver_mtds = {      \</div>
<div class="line">   DriverSupportsPixelType,                        \</div>
<div class="line">   DriverExtension,                                \</div>
<div class="line">   DriverOpen,                                     \</div>
<div class="line">   DriverNeedsBucket,                              \</div>
<div class="line">   DriverPrepareBucket,                            \</div>
<div class="line">   DriverProcessBucket,                            \</div>
<div class="line">   DriverWriteBucket,                              \</div>
<div class="line">   DriverClose,                                    \</div>
<div class="line">};                                                 \</div>
<div class="line">static <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_mtds = {              \</div>
<div class="line">   &amp;ai_common_mtds,                                \</div>
<div class="line">   &amp;ai_driver_mtds                                 \</div>
<div class="line">};                                                 \</div>
<div class="line">const <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a> *tag = &amp;ai_node_mtds;</div>
<div class="ttc" id="agroup__ai__drivers_html_gad18183b3cd0bc436a8087ca1d25850ec"><div class="ttname"><a href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">driver_supports_pixel_type</a></div><div class="ttdeci">#define driver_supports_pixel_type</div><div class="ttdoc">Driver's driver_supports_pixel_type declaration.</div><div class="ttdef"><b>Definition:</b> ai_drivers.h:96</div></div>
<div class="ttc" id="astructAtDriverNodeMethods_html"><div class="ttname"><a href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a></div><div class="ttdoc">Driver Node methods structure.</div><div class="ttdef"><b>Definition:</b> ai_drivers.h:46</div></div>
<div class="ttc" id="astructAtNodeMethods_html"><div class="ttname"><a href="structAtNodeMethods.html">AtNodeMethods</a></div><div class="ttdoc">Node methods.</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:86</div></div>
</div><!-- fragment -->
<p>Output Driver node methods exporter. </p>

</div>
</div>
<a id="gad18183b3cd0bc436a8087ca1d25850ec" name="gad18183b3cd0bc436a8087ca1d25850ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad18183b3cd0bc436a8087ca1d25850ec">&#9670;&nbsp;</a></span>driver_supports_pixel_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_supports_pixel_type&#160;&#160;&#160;static bool DriverSupportsPixelType(const <a class="el" href="structAtNode.html">AtNode</a>* node, uint8_t pixel_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_supports_pixel_type declaration. </p>
<p >Can the driver handle buckets of pixels of the specified type? This function is not called for raw mode drivers.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the driver can write pixels of the given type </dd></dl>

</div>
</div>
<a id="gac0b8895e83f19a5cbf53091bb52dd0e8" name="gac0b8895e83f19a5cbf53091bb52dd0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b8895e83f19a5cbf53091bb52dd0e8">&#9670;&nbsp;</a></span>driver_extension</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_extension&#160;&#160;&#160;static const char** DriverExtension()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_extension method declaration. </p>
<p >If the extension is empty (returned array is {NULL} then arnold will assume the driver could be a "view" type driver as opposed to just a file writing driver. Both view and file drivers will apply imagers at the end of the render, but view drivers will also apply imagers during rendering so that there is a quicker preview of what the final image will look like. This extra imager processing can slow the render, so view drivers have the option of returning an arbitrary extension so that the faster code path is used.</p>
<dl class="section return"><dt>Returns</dt><dd>a NULL-terminated array of filename extensions which this driver is capable of writing. For example, a 'jpeg' driver might return the following array: { "jpeg", "jpg", NULL } </dd></dl>

</div>
</div>
<a id="ga5c4c1392f7280dcf596d833b27c63257" name="ga5c4c1392f7280dcf596d833b27c63257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c4c1392f7280dcf596d833b27c63257">&#9670;&nbsp;</a></span>driver_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_open&#160;&#160;&#160;static void DriverOpen(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator, <a class="el" href="structAtBBox2.html">AtBBox2</a> display_window, <a class="el" href="structAtBBox2.html">AtBBox2</a> data_window, int bucket_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_open method declaration. </p>
<p >This function is called before rendering starts and can make any preparations the driver needs, like opening a file or allocating memory. The list of connected outputs is passed in using an output iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator for outputs connected to this driver </td></tr>
    <tr><td class="paramname">display_window</td><td>this is a 2D bounding box for the actual resolution </td></tr>
    <tr><td class="paramname">data_window</td><td>this is the actual region of pixels that will be rendered </td></tr>
    <tr><td class="paramname">bucket_size</td><td>maximum width in pixels of a bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea47f8f7451d75112be4bfb1da5611b5" name="gaea47f8f7451d75112be4bfb1da5611b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea47f8f7451d75112be4bfb1da5611b5">&#9670;&nbsp;</a></span>driver_needs_bucket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_needs_bucket&#160;&#160;&#160;static bool DriverNeedsBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, uint16_t tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_needs_bucket method declaration. </p>
<p >This function is called to determine if a bucket will be rendered. It can be used to continue work on partial images without re-rendering already present buckets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
    <tr><td class="paramname">tid</td><td>thread ID that will render this bucket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bucket needs to be rendered, false if the bucket can be skipped </dd></dl>

</div>
</div>
<a id="gac0171f32654d3704a27b3177cfea5fc6" name="gac0171f32654d3704a27b3177cfea5fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0171f32654d3704a27b3177cfea5fc6">&#9670;&nbsp;</a></span>driver_prepare_bucket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_prepare_bucket&#160;&#160;&#160;static void DriverPrepareBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, uint16_t tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_prepare_bucket method declaration. </p>
<p >This function is called before a bucket is rendered. It can be used to display bucket corners for interactive rendering drivers to show which buckets are being processed, for example. The renderer locks around this function so the contained code is not required to be thread safe. The bucket size may be smaller than what was given to <code>driver_open</code> because buckets are clamped to the edge of the render region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
    <tr><td class="paramname">tid</td><td>thread ID that will render this bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad581a889a481b9c7ad1fddf92c2bc8b7" name="gad581a889a481b9c7ad1fddf92c2bc8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad581a889a481b9c7ad1fddf92c2bc8b7">&#9670;&nbsp;</a></span>driver_process_bucket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_process_bucket&#160;&#160;&#160;static void DriverProcessBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, uint16_t tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_process_bucket method declaration. </p>
<p >This function is called after a bucket has been rendered, but before it is written out. It provides the rendered pixels of each output to the driver, or the raw AOV samples if this is a raw driver. The renderer does not lock around this function, to allow for lengthy bucket preprocessing to happen in parallel. The contained code should not require any thread synchornization. The bucket size may be smaller than what was given to <code>driver_open</code> because buckets are clamped to the edge of the render region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator (loops over connected outputs for regular drivers) </td></tr>
    <tr><td class="paramname">sample_iterator</td><td>raw AOV sample iterator (loops over connected AOVs for raw drivers) </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
    <tr><td class="paramname">tid</td><td>thread ID that rendered this bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7734e3bcc6deff211dec384a840fb09b" name="ga7734e3bcc6deff211dec384a840fb09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7734e3bcc6deff211dec384a840fb09b">&#9670;&nbsp;</a></span>driver_write_bucket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_write_bucket&#160;&#160;&#160;static void DriverWriteBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_write_bucket method declaration. </p>
<p >This function is called after a bucket has been rendered. It provides the rendered pixels of each output to the driver, or the raw AOV samples if this is a raw driver. The renderer locks around this function so the contained code is not required to be thread safe. The bucket size may be smaller than what was given to <code>driver_open</code> because buckets are clamped to the edge of the render region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator (loops over connected outputs for regular drivers) </td></tr>
    <tr><td class="paramname">sample_iterator</td><td>raw AOV sample iterator (loops over connected AOVs for raw drivers) </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga016be0537a02f4b1db64c69dd9667b71" name="ga016be0537a02f4b1db64c69dd9667b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga016be0537a02f4b1db64c69dd9667b71">&#9670;&nbsp;</a></span>driver_close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_close&#160;&#160;&#160;static void DriverClose(<a class="el" href="structAtNode.html">AtNode</a>* node, struct <a class="el" href="structAtOutputIterator.html">AtOutputIterator</a>* iterator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_close method declaration. </p>
<p >This function is called after the image has finished rendering. It is responsible for any final tasks such as flushing or closing open files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator (loops over connected outputs for regular drivers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2de59bdc8d63de0dc48fba9f9a0992e0" name="ga2de59bdc8d63de0dc48fba9f9a0992e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de59bdc8d63de0dc48fba9f9a0992e0">&#9670;&nbsp;</a></span>AiQuantize8bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST uint8_t AiQuantize8bit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantize a floating point number down to an 8-bit integer. </p>
<p >This function is typically used in an output driver to prepare pixel values before sending them to the output device. For example, we may want to send the continuous floating point image to a standard display with a limited color resolution of 8 bits per component.</p>
<p >Pixel quantization is a lossy process that can introduce distracting banding artifacts in the rendered image. This function optionally uses random dithering, which breaks the banding up into almost imperceptible noise. The input parameters <code>x</code>,<code>y</code> are used to lock the dither noise to the location of each pixel to prevent it from flickering in animation.</p>
<p >Usage example: </p><div class="fragment"><div class="line">AtUInt8 r = <a class="code hl_function" href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0">AiQuantize8bit</a>(x, y, 0, color.r, 1.0f);</div>
<div class="line">AtUInt8 g = <a class="code hl_function" href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0">AiQuantize8bit</a>(x, y, 1, color.g, 1.0f);</div>
<div class="line">AtUInt8 b = <a class="code hl_function" href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0">AiQuantize8bit</a>(x, y, 2, color.b, 1.0f);</div>
<div class="ttc" id="agroup__ai__drivers_html_ga2de59bdc8d63de0dc48fba9f9a0992e0"><div class="ttname"><a href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0">AiQuantize8bit</a></div><div class="ttdeci">AI_API AI_CONST uint8_t AiQuantize8bit(int x, int y, int i, float value, bool dither)</div><div class="ttdoc">Quantize a floating point number down to an 8-bit integer.</div><div class="ttdef"><b>Definition:</b> ai_driver_utils.cpp:44</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>horizontal coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">y</td><td>vertical coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">i</td><td>instance number in 0..n-1, when part of a sequence of n calls </td></tr>
    <tr><td class="paramname">value</td><td>input floating point value to be quantized, in the [0,1] range </td></tr>
    <tr><td class="paramname">dither</td><td>use random dithering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quantized value, in 0..255 </dd></dl>

</div>
</div>
<a id="gae614ea72f07d143728642cff6288ca5d" name="gae614ea72f07d143728642cff6288ca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae614ea72f07d143728642cff6288ca5d">&#9670;&nbsp;</a></span>AiQuantize16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST uint16_t AiQuantize16bit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantize a floating point number down to a 16-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>horizontal coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">y</td><td>vertical coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">i</td><td>instance number in 0..n-1, when part of a sequence of n calls </td></tr>
    <tr><td class="paramname">value</td><td>floating point value, in the [0,1] range </td></tr>
    <tr><td class="paramname">dither</td><td>use random dithering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quantized value, in 0..65535</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__drivers.html#ga2de59bdc8d63de0dc48fba9f9a0992e0" title="Quantize a floating point number down to an 8-bit integer.">AiQuantize8bit</a> </dd></dl>

</div>
</div>
<a id="ga99dfebdcd9643a87afc0ca8304b90bba" name="ga99dfebdcd9643a87afc0ca8304b90bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99dfebdcd9643a87afc0ca8304b90bba">&#9670;&nbsp;</a></span>AiDriverInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiDriverInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supports_multiple_outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes the driver structure. </p>
<p >This function creates an internal DriverNode structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node </td></tr>
    <tr><td class="paramname">supports_multiple_outputs</td><td>does this driver support more than one output routed to it? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38b5e913dab41dae23ca287fb732fc79" name="ga38b5e913dab41dae23ca287fb732fc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b5e913dab41dae23ca287fb732fc79">&#9670;&nbsp;</a></span>AiRawDriverInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiRawDriverInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>required_aovs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requires_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes the driver structure. </p>
<p >This function works just like <a class="el" href="group__ai__drivers.html#ga99dfebdcd9643a87afc0ca8304b90bba" title="Allocates and initializes the driver structure.">AiDriverInitialize()</a> but should only be used for raw drivers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node </td></tr>
    <tr><td class="paramname">required_aovs</td><td>NULL-terminated array of AOV descriptors (<code>"TYPE name"</code>) to route to this driver </td></tr>
    <tr><td class="paramname">requires_depth</td><td>should input AOVs be tracked with depth</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__drivers.html#ga99dfebdcd9643a87afc0ca8304b90bba" title="Allocates and initializes the driver structure.">AiDriverInitialize</a> </dd></dl>

</div>
</div>
<a id="gac511a54e0b2a8d2c9bf776b11a58034c" name="gac511a54e0b2a8d2c9bf776b11a58034c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac511a54e0b2a8d2c9bf776b11a58034c">&#9670;&nbsp;</a></span>AiDriverGetMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiDriverGetMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>world_to_camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>world_to_screen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Renderman compliant matrices from the active camera for use in file headers. </p>
<p >This fetches the camera and screen matrices from the currently active camera so they can be placed in an output file's header. Note that unlike the camera API functions, the world to camera transform looks down +Z for compatibility with most file formats (TIFF,OpenEXR,dshd,...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">world_to_camera</td><td>world to camera transformation matrix (looking down +Z) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">world_to_screen</td><td>world to screen transformation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05162d912bf2264738d6f5926e438984" name="ga05162d912bf2264738d6f5926e438984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05162d912bf2264738d6f5926e438984">&#9670;&nbsp;</a></span>AiFindDriverType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> * AiFindDriverType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get correct driver node type from an extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>a string containing the file extension, e.g. <code>"tiff"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> corresponding to <code>extension</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
