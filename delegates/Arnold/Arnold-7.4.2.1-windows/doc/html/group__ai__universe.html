<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">AtUniverse API</div></div>
</div><!--header-->
<div class="contents">

<p>Construction and manipulation of <a class="el" href="structAtUniverse.html">AtUniverse</a> objects.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtUniverse.html">AtUniverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a universe in Arnold.  <a href="structAtUniverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab3bae212abb1206510c786fa736beb9e"><td class="memItemLeft" align="right" valign="top"><a id="gab3bae212abb1206510c786fa736beb9e" name="gab3bae212abb1206510c786fa736beb9e"></a>
<a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtAOVEntry::name</b></td></tr>
<tr class="memdesc:gab3bae212abb1206510c786fa736beb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">AOV name <br  />
 <br /></td></tr>
<tr class="separator:gab3bae212abb1206510c786fa736beb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab02838ee8a17b079422a4ccdabc68a2b"><td class="memItemLeft" align="right" valign="top"><a id="gab02838ee8a17b079422a4ccdabc68a2b" name="gab02838ee8a17b079422a4ccdabc68a2b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtAOVEntry::type</b></td></tr>
<tr class="memdesc:gab02838ee8a17b079422a4ccdabc68a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type <br  />
 <br /></td></tr>
<tr class="separator:gab02838ee8a17b079422a4ccdabc68a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dacfbc3b18c2510991a021cdbb912a0"><td class="memItemLeft" align="right" valign="top"><a id="ga1dacfbc3b18c2510991a021cdbb912a0" name="ga1dacfbc3b18c2510991a021cdbb912a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtAOVEntry::blend_mode</b></td></tr>
<tr class="memdesc:ga1dacfbc3b18c2510991a021cdbb912a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blend mode <br  />
 <br /></td></tr>
<tr class="separator:ga1dacfbc3b18c2510991a021cdbb912a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36e82b708c5c93ef2cd343ac61176951"><td class="memItemLeft" align="right" valign="top"><a id="ga36e82b708c5c93ef2cd343ac61176951" name="ga36e82b708c5c93ef2cd343ac61176951"></a>
<a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtAOVEntry::expression</b></td></tr>
<tr class="memdesc:ga36e82b708c5c93ef2cd343ac61176951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional light path expression. <br /></td></tr>
<tr class="separator:ga36e82b708c5c93ef2cd343ac61176951"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Methods</h2></td></tr>
<tr class="memitem:ga31b30200833aac1a32444651a0ca2db5"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga31b30200833aac1a32444651a0ca2db5">AiUniverse</a> ()</td></tr>
<tr class="memdesc:ga31b30200833aac1a32444651a0ca2db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new universe that can be used independently of the default universe.  <a href="group__ai__universe.html#ga31b30200833aac1a32444651a0ca2db5">More...</a><br /></td></tr>
<tr class="separator:ga31b30200833aac1a32444651a0ca2db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1d4c4f658e30ea5ad7efb72631499b"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gadf1d4c4f658e30ea5ad7efb72631499b">AiUniverseDestroy</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gadf1d4c4f658e30ea5ad7efb72631499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an existing universe and releases any allocated resources.  <a href="group__ai__universe.html#gadf1d4c4f658e30ea5ad7efb72631499b">More...</a><br /></td></tr>
<tr class="separator:gadf1d4c4f658e30ea5ad7efb72631499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cd7fcb96f63df14344fe939a8d46944"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga2cd7fcb96f63df14344fe939a8d46944">AiUniverseCacheFlush</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, int cache_flags)</td></tr>
<tr class="memdesc:ga2cd7fcb96f63df14344fe939a8d46944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush one or several caches in a given Arnold universe.  <a href="group__ai__universe.html#ga2cd7fcb96f63df14344fe939a8d46944">More...</a><br /></td></tr>
<tr class="separator:ga2cd7fcb96f63df14344fe939a8d46944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1062096c1ab6712e2e1aa087efea3b"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga3d1062096c1ab6712e2e1aa087efea3b">AiUniverseGetOptions</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:ga3d1062096c1ab6712e2e1aa087efea3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the global options node for a specific Arnold universe.  <a href="group__ai__universe.html#ga3d1062096c1ab6712e2e1aa087efea3b">More...</a><br /></td></tr>
<tr class="separator:ga3d1062096c1ab6712e2e1aa087efea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f83862bd2e9c8fc3ab51100cc9e94b"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE AI_PURE <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga64f83862bd2e9c8fc3ab51100cc9e94b">AiUniverseGetCamera</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:ga64f83862bd2e9c8fc3ab51100cc9e94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the currently active camera node for a given Arnold universe.  <a href="group__ai__universe.html#ga64f83862bd2e9c8fc3ab51100cc9e94b">More...</a><br /></td></tr>
<tr class="separator:ga64f83862bd2e9c8fc3ab51100cc9e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0e747e6c613983d257f2f2b07445fd"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gadc0e747e6c613983d257f2f2b07445fd">AiUniverseGetSceneBounds</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gadc0e747e6c613983d257f2f2b07445fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding box of the given Arnold universe.  <a href="group__ai__universe.html#gadc0e747e6c613983d257f2f2b07445fd">More...</a><br /></td></tr>
<tr class="separator:gadc0e747e6c613983d257f2f2b07445fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9a681d265bf5ce15f4964a008f2ecc"><td class="memItemLeft" align="right" valign="top">AI_API AtNodeIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga7e9a681d265bf5ce15f4964a008f2ecc">AiUniverseGetNodeIterator</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, unsigned int node_mask)</td></tr>
<tr class="memdesc:ga7e9a681d265bf5ce15f4964a008f2ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node iterator for the given Arnold universe and resets it to the first node.  <a href="group__ai__universe.html#ga7e9a681d265bf5ce15f4964a008f2ecc">More...</a><br /></td></tr>
<tr class="separator:ga7e9a681d265bf5ce15f4964a008f2ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ded8db7a6f764a902173e6f38d468d"><td class="memItemLeft" align="right" valign="top">AI_API AtNodeEntryIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga02ded8db7a6f764a902173e6f38d468d">AiUniverseGetNodeEntryIterator</a> (unsigned int node_mask)</td></tr>
<tr class="memdesc:ga02ded8db7a6f764a902173e6f38d468d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node entry iterator and resets it to the first installed node entry.  <a href="group__ai__universe.html#ga02ded8db7a6f764a902173e6f38d468d">More...</a><br /></td></tr>
<tr class="separator:ga02ded8db7a6f764a902173e6f38d468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3afc59b9d4f4f925a132711864ee14"><td class="memItemLeft" align="right" valign="top">AI_API AtAOVIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gacd3afc59b9d4f4f925a132711864ee14">AiUniverseGetAOVIterator</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gacd3afc59b9d4f4f925a132711864ee14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new AOV iterator for a specific universe and resets it to the first entry.  <a href="group__ai__universe.html#gacd3afc59b9d4f4f925a132711864ee14">More...</a><br /></td></tr>
<tr class="separator:gacd3afc59b9d4f4f925a132711864ee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ff5389b2fd0b5591130e150a947489"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaf2ff5389b2fd0b5591130e150a947489">AiUniverseAddDefaultNodes</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, const AtParamValueMap *params)</td></tr>
<tr class="memdesc:gaf2ff5389b2fd0b5591130e150a947489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates default camera and/or light nodes when they are not present in the scene.  <a href="group__ai__universe.html#gaf2ff5389b2fd0b5591130e150a947489">More...</a><br /></td></tr>
<tr class="separator:gaf2ff5389b2fd0b5591130e150a947489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb095fa507230ad53c261f7b2f486680"><td class="memItemLeft" align="right" valign="top">AI_API AtRenderSession *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gadb095fa507230ad53c261f7b2f486680">AiUniverseGetRenderSession</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gadb095fa507230ad53c261f7b2f486680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the render session using the given universe.  <a href="group__ai__universe.html#gadb095fa507230ad53c261f7b2f486680">More...</a><br /></td></tr>
<tr class="separator:gadb095fa507230ad53c261f7b2f486680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7508871ef98819ae374827f02748688e"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga7508871ef98819ae374827f02748688e">AiUniverseCompare</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe1, const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe2, unsigned int node_mask=<a class="el" href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a>, AtParamValueMap *diffs=NULL)</td></tr>
<tr class="memdesc:ga7508871ef98819ae374827f02748688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two universes.  <a href="group__ai__universe.html#ga7508871ef98819ae374827f02748688e">More...</a><br /></td></tr>
<tr class="separator:ga7508871ef98819ae374827f02748688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3391fdd454ae80278256ad1861f9ae1"><td class="memItemLeft" align="right" valign="top">AI_API uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gac3391fdd454ae80278256ad1861f9ae1">AiUniverseGetId</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gac3391fdd454ae80278256ad1861f9ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 32bit integer ID for a universe.  <a href="group__ai__universe.html#gac3391fdd454ae80278256ad1861f9ae1">More...</a><br /></td></tr>
<tr class="separator:gac3391fdd454ae80278256ad1861f9ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed3747699d67673f58ae1f87c7f264d"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaaed3747699d67673f58ae1f87c7f264d">AiUniverseGetFromId</a> (uint32_t universe_id)</td></tr>
<tr class="memdesc:gaaed3747699d67673f58ae1f87c7f264d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a universe from its 32bit integer ID.  <a href="group__ai__universe.html#gaaed3747699d67673f58ae1f87c7f264d">More...</a><br /></td></tr>
<tr class="separator:gaaed3747699d67673f58ae1f87c7f264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Iterator API</h2></td></tr>
<tr class="memitem:gac14e2b776f7e32dcb7346f64061f28ff"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">AiNodeIteratorDestroy</a> (AtNodeIterator *iter)</td></tr>
<tr class="memdesc:gac14e2b776f7e32dcb7346f64061f28ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a node iterator when it is no longer needed.  <a href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">More...</a><br /></td></tr>
<tr class="separator:gac14e2b776f7e32dcb7346f64061f28ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d69986fc556e8a69c400d355558238"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238">AiNodeIteratorGetNext</a> (AtNodeIterator *iter)</td></tr>
<tr class="memdesc:ga96d69986fc556e8a69c400d355558238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current node and points node iterator to the next node.  <a href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238">More...</a><br /></td></tr>
<tr class="separator:ga96d69986fc556e8a69c400d355558238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6b120df6cb2b6b57dc700d04d5f118"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">AiNodeIteratorFinished</a> (const AtNodeIterator *iter)</td></tr>
<tr class="memdesc:gaed6b120df6cb2b6b57dc700d04d5f118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more nodes to iterate over.  <a href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">More...</a><br /></td></tr>
<tr class="separator:gaed6b120df6cb2b6b57dc700d04d5f118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Entry Iterator API</h2></td></tr>
<tr class="memitem:gacdbbbed549f79288819316f227def22f"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f">AiNodeEntryIteratorDestroy</a> (AtNodeEntryIterator *iter)</td></tr>
<tr class="memdesc:gacdbbbed549f79288819316f227def22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a node entry iterator when it is no longer needed.  <a href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f">More...</a><br /></td></tr>
<tr class="separator:gacdbbbed549f79288819316f227def22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d85c49a5621567ae11016a915b7395c"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga5d85c49a5621567ae11016a915b7395c">AiNodeEntryIteratorGetNext</a> (AtNodeEntryIterator *iter)</td></tr>
<tr class="memdesc:ga5d85c49a5621567ae11016a915b7395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current node entry and points node entry iterator to the next node entry.  <a href="group__ai__universe.html#ga5d85c49a5621567ae11016a915b7395c">More...</a><br /></td></tr>
<tr class="separator:ga5d85c49a5621567ae11016a915b7395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7978243ad260abcb7b6a7f2468aca7"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga2b7978243ad260abcb7b6a7f2468aca7">AiNodeEntryIteratorFinished</a> (const AtNodeEntryIterator *iter)</td></tr>
<tr class="memdesc:ga2b7978243ad260abcb7b6a7f2468aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more node entries to iterate over.  <a href="group__ai__universe.html#ga2b7978243ad260abcb7b6a7f2468aca7">More...</a><br /></td></tr>
<tr class="separator:ga2b7978243ad260abcb7b6a7f2468aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AOV Iterator API</h2></td></tr>
<tr class="memitem:gae3f61927424448febb6f7bd5b878b68d"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d">AiAOVIteratorDestroy</a> (AtAOVIterator *iter)</td></tr>
<tr class="memdesc:gae3f61927424448febb6f7bd5b878b68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a AOV iterator when it is no longer needed.  <a href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d">More...</a><br /></td></tr>
<tr class="separator:gae3f61927424448febb6f7bd5b878b68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907f3d834b7fe4fe16914a86857a0357"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtAOVEntry.html">AtAOVEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga907f3d834b7fe4fe16914a86857a0357">AiAOVIteratorGetNext</a> (AtAOVIterator *iter)</td></tr>
<tr class="memdesc:ga907f3d834b7fe4fe16914a86857a0357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current AOV entry and points AOV iterator to the next AOV.  <a href="group__ai__universe.html#ga907f3d834b7fe4fe16914a86857a0357">More...</a><br /></td></tr>
<tr class="separator:ga907f3d834b7fe4fe16914a86857a0357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb557694ef170cb568d03cdc543ed8f"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gabdb557694ef170cb568d03cdc543ed8f">AiAOVIteratorFinished</a> (const AtAOVIterator *iter)</td></tr>
<tr class="memdesc:gabdb557694ef170cb568d03cdc543ed8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more AOV entries to iterate over.  <a href="group__ai__universe.html#gabdb557694ef170cb568d03cdc543ed8f">More...</a><br /></td></tr>
<tr class="separator:gabdb557694ef170cb568d03cdc543ed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cache Types</h2></td></tr>
<tr class="memitem:gac5d80ecf4926d8537b9096991091f30c"><td class="memItemLeft" align="right" valign="top"><a id="gac5d80ecf4926d8537b9096991091f30c" name="gac5d80ecf4926d8537b9096991091f30c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_CACHE_TEXTURE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:gac5d80ecf4926d8537b9096991091f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all texturemaps. <br /></td></tr>
<tr class="separator:gac5d80ecf4926d8537b9096991091f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96498ee6fcadca7a579a1a3cd421ed1"><td class="memItemLeft" align="right" valign="top"><a id="gaa96498ee6fcadca7a579a1a3cd421ed1" name="gaa96498ee6fcadca7a579a1a3cd421ed1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_CACHE_BACKGROUND</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:gaa96498ee6fcadca7a579a1a3cd421ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all skydome importance tables for background. <br /></td></tr>
<tr class="separator:gaa96498ee6fcadca7a579a1a3cd421ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe3026e8e85e3a791936a581f915e9ac"><td class="memItemLeft" align="right" valign="top"><a id="gabe3026e8e85e3a791936a581f915e9ac" name="gabe3026e8e85e3a791936a581f915e9ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_CACHE_QUAD</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:gabe3026e8e85e3a791936a581f915e9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all quad lights importance tables. <br /></td></tr>
<tr class="separator:gabe3026e8e85e3a791936a581f915e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4218e0c1dd0b97cb79a7bf745584b296"><td class="memItemLeft" align="right" valign="top"><a id="ga4218e0c1dd0b97cb79a7bf745584b296" name="ga4218e0c1dd0b97cb79a7bf745584b296"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_CACHE_VOLUME_DISPLAY</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ga4218e0c1dd0b97cb79a7bf745584b296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all volume viewport display data. <br /></td></tr>
<tr class="separator:ga4218e0c1dd0b97cb79a7bf745584b296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0aa9118fe67d4771c2a6fad5bdd151"><td class="memItemLeft" align="right" valign="top"><a id="gacc0aa9118fe67d4771c2a6fad5bdd151" name="gacc0aa9118fe67d4771c2a6fad5bdd151"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_CACHE_ALL</b>&#160;&#160;&#160;(<a class="el" href="group__ai__universe.html#gac5d80ecf4926d8537b9096991091f30c">AI_CACHE_TEXTURE</a> | <a class="el" href="group__ai__universe.html#gaa96498ee6fcadca7a579a1a3cd421ed1">AI_CACHE_BACKGROUND</a> | <a class="el" href="group__ai__universe.html#gabe3026e8e85e3a791936a581f915e9ac">AI_CACHE_QUAD</a> | <a class="el" href="group__ai__universe.html#ga4218e0c1dd0b97cb79a7bf745584b296">AI_CACHE_VOLUME_DISPLAY</a>)</td></tr>
<tr class="memdesc:gacc0aa9118fe67d4771c2a6fad5bdd151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all cache types simultaneously. <br /></td></tr>
<tr class="separator:gacc0aa9118fe67d4771c2a6fad5bdd151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Construction and manipulation of <a class="el" href="structAtUniverse.html">AtUniverse</a> objects. </p>
<p >There is always a default universe, created on <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a">AiBegin()</a> and destroyed on <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d">AiEnd()</a>. This universe cannot be manually destroyed. As a shortcut, universe API calls can use a null universe pointer to refer to this default universe.</p>
<p >There can also be a number of secondary universes created using <a class="el" href="group__ai__universe.html#ga31b30200833aac1a32444651a0ca2db5">AiUniverse()</a>, which can be used for scene import, export and rendering independently from other universes and the default universe.</p>
<p >Note that universes are totally independent, so a node can only belong to a single universe, and it cannot link to or reference nodes in a different universe. <br  />
 </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga31b30200833aac1a32444651a0ca2db5" name="ga31b30200833aac1a32444651a0ca2db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b30200833aac1a32444651a0ca2db5">&#9670;&nbsp;</a></span>AiUniverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtUniverse.html">AtUniverse</a> * AiUniverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new universe that can be used independently of the default universe. </p>
<p ><a class="el" href="group__ai__universe.html#gadf1d4c4f658e30ea5ad7efb72631499b" title="Destroys an existing universe and releases any allocated resources.">AiUniverseDestroy()</a> can be used to destroy this universe on demand. This is not necessary if the universe is used until the end of the Arnold session, because <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a> will take care of destroying any existing universes.</p>
<dl class="section note"><dt>Note</dt><dd>A default universe always exists during the Arnold session (between <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> and <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a>). This default universe cannot be destroyed manually (it will be released during <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a>). You can generally use a NULL pointer to select the default universe in the API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new universe. NULL if called outside of an <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a> block. </dd></dl>

</div>
</div>
<a id="gadf1d4c4f658e30ea5ad7efb72631499b" name="gadf1d4c4f658e30ea5ad7efb72631499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1d4c4f658e30ea5ad7efb72631499b">&#9670;&nbsp;</a></span>AiUniverseDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiUniverseDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an existing universe and releases any allocated resources. </p>
<p >This is necessary when a universe has been created for a temporary usage, and needs to be released before <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a> is called.</p>
<dl class="section note"><dt>Note</dt><dd>Trying to destroy the default universe, or passing a NULL pointer, will do nothing</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>the universe to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cd7fcb96f63df14344fe939a8d46944" name="ga2cd7fcb96f63df14344fe939a8d46944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cd7fcb96f63df14344fe939a8d46944">&#9670;&nbsp;</a></span>AiUniverseCacheFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiUniverseCacheFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush one or several caches in a given Arnold universe. </p>
<p >This function will request the release of the resource. If safe to do so (no other render sessions could be actively using the resource, etc.) the release will finish before the function returns. Otherwise the request is recorded and the flush will happen later when the resource is no longer used (often the start or end of a render).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>the target universe for the cache flush (NULL for default universe) </td></tr>
    <tr><td class="paramname">cache_flags</td><td>a bitmask specifying the cache types to be flushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the requested cache flushes were executed, false if they were deferred. </dd></dl>

</div>
</div>
<a id="ga3d1062096c1ab6712e2e1aa087efea3b" name="ga3d1062096c1ab6712e2e1aa087efea3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1062096c1ab6712e2e1aa087efea3b">&#9670;&nbsp;</a></span>AiUniverseGetOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> * AiUniverseGetOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the global options node for a specific Arnold universe. </p>
<p >Will return NULL if called outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The universe's options reflects what the user requested, not what is being actually used. For instance, if options.threads=0 (autodetect thread count) this will return 0. If you want the actual number of threads being used, then instead AiRenderSessionGetOptions(AiUniverseGetRenderSession(universe)) should be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>the universe to get the options node from (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the global options node </dd></dl>

</div>
</div>
<a id="ga64f83862bd2e9c8fc3ab51100cc9e94b" name="ga64f83862bd2e9c8fc3ab51100cc9e94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f83862bd2e9c8fc3ab51100cc9e94b">&#9670;&nbsp;</a></span>AiUniverseGetCamera()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE AI_PURE <a class="el" href="structAtNode.html">AtNode</a> * AiUniverseGetCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the currently active camera node for a given Arnold universe. </p>
<p >Will return NULL if the universe is not valid, if the camera has not been set or if the linked node is not a camera.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>the universe to get the camera node from (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the active camera node </dd></dl>

</div>
</div>
<a id="gadc0e747e6c613983d257f2f2b07445fd" name="gadc0e747e6c613983d257f2f2b07445fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc0e747e6c613983d257f2f2b07445fd">&#9670;&nbsp;</a></span>AiUniverseGetSceneBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a> AiUniverseGetSceneBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding box of the given Arnold universe. </p>
<p >Note that this box may be conservative in the presence of "infinite" primitives or procedurals. If the universe given is not valid, this will return an empty box containing the origin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>the universe to get the bounding box from (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scene bounding box </dd></dl>

</div>
</div>
<a id="ga7e9a681d265bf5ce15f4964a008f2ecc" name="ga7e9a681d265bf5ce15f4964a008f2ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e9a681d265bf5ce15f4964a008f2ecc">&#9670;&nbsp;</a></span>AiUniverseGetNodeIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtNodeIterator * AiUniverseGetNodeIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new node iterator for the given Arnold universe and resets it to the first node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>the universe to iterate (NULL for default universe) </td></tr>
    <tr><td class="paramname">node_mask</td><td>bitmask of node types, e.g <code>AI_NODE_ALL</code>, <code>AI_NODE_LIGHT</code> | <code>AI_NODE_SHADER</code>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node iterator over the given type of nodes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff" title="Destroys a node iterator when it is no longer needed.">AiNodeIteratorDestroy</a>, <a class="el" href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238" title="Returns current node and points node iterator to the next node.">AiNodeIteratorGetNext</a> </dd></dl>

</div>
</div>
<a id="ga02ded8db7a6f764a902173e6f38d468d" name="ga02ded8db7a6f764a902173e6f38d468d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02ded8db7a6f764a902173e6f38d468d">&#9670;&nbsp;</a></span>AiUniverseGetNodeEntryIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtNodeEntryIterator * AiUniverseGetNodeEntryIterator </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new node entry iterator and resets it to the first installed node entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_mask</td><td>bitmask of node types, e.g <code>AI_NODE_ALL</code>, <code>AI_NODE_LIGHT</code> | <code>AI_NODE_SHADER</code>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node entry iterator over the given type of nodes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f" title="Destroys a node entry iterator when it is no longer needed.">AiNodeEntryIteratorDestroy</a>, <a class="el" href="group__ai__universe.html#ga5d85c49a5621567ae11016a915b7395c" title="Returns current node entry and points node entry iterator to the next node entry.">AiNodeEntryIteratorGetNext</a> </dd></dl>

</div>
</div>
<a id="gacd3afc59b9d4f4f925a132711864ee14" name="gacd3afc59b9d4f4f925a132711864ee14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3afc59b9d4f4f925a132711864ee14">&#9670;&nbsp;</a></span>AiUniverseGetAOVIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtAOVIterator * AiUniverseGetAOVIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new AOV iterator for a specific universe and resets it to the first entry. </p>
<p >In case the universe doesn't have a render session associated, this will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe to get the AOV iterator for (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a AOV iterator over all registered AOVs</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d" title="Destroys a AOV iterator when it is no longer needed.">AiAOVIteratorDestroy</a>, <a class="el" href="group__ai__universe.html#ga907f3d834b7fe4fe16914a86857a0357" title="Returns current AOV entry and points AOV iterator to the next AOV.">AiAOVIteratorGetNext</a> </dd></dl>

</div>
</div>
<a id="gaf2ff5389b2fd0b5591130e150a947489" name="gaf2ff5389b2fd0b5591130e150a947489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ff5389b2fd0b5591130e150a947489">&#9670;&nbsp;</a></span>AiUniverseAddDefaultNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiUniverseAddDefaultNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates default camera and/or light nodes when they are not present in the scene. </p>
<p >This example code creates a default set of lights: </p><div class="fragment"><div class="line">AtParamValueMap* params = <a class="code hl_function" href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a>();</div>
<div class="line">AiParamValueMapSetBool(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;default_lights&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line">AiParamValueMapSetStr(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;light_type&quot;</span>), <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;distant_light&quot;</span>));</div>
<div class="line">AiParamValueMapSetStr(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;light_mode&quot;</span>), <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;three_point&quot;</span>));</div>
<div class="line"><a class="code hl_function" href="group__ai__universe.html#gaf2ff5389b2fd0b5591130e150a947489">AiUniverseAddDefaultNodes</a>(universe, params); </div>
<div class="line"><a class="code hl_function" href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a>(params);</div>
<div class="ttc" id="aclassAtString_html"><div class="ttname"><a href="classAtString.html">AtString</a></div><div class="ttdoc">Arnold String allows for fast string comparisons.</div><div class="ttdef"><b>Definition:</b> ai_string.h:54</div></div>
<div class="ttc" id="agroup__ai__map_html_ga79ba0a87866541a1029201b9df5bddf1"><div class="ttname"><a href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a></div><div class="ttdeci">AI_API AtParamValueMap * AiParamValueMap()</div><div class="ttdoc">Creates a new map.</div><div class="ttdef"><b>Definition:</b> ai_map.cpp:46</div></div>
<div class="ttc" id="agroup__ai__map_html_gab06bffff6c01ce8b403d107e4325052e"><div class="ttname"><a href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a></div><div class="ttdeci">AI_API void AiParamValueMapDestroy(AtParamValueMap *map)</div><div class="ttdoc">Destroys a map object.</div><div class="ttdef"><b>Definition:</b> ai_map.cpp:55</div></div>
<div class="ttc" id="agroup__ai__universe_html_gaf2ff5389b2fd0b5591130e150a947489"><div class="ttname"><a href="group__ai__universe.html#gaf2ff5389b2fd0b5591130e150a947489">AiUniverseAddDefaultNodes</a></div><div class="ttdeci">AI_API void AiUniverseAddDefaultNodes(AtUniverse *universe, const AtParamValueMap *params)</div><div class="ttdoc">Creates default camera and/or light nodes when they are not present in the scene.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:301</div></div>
</div><!-- fragment --><p >Supported params:</p>
<table class="doxtable">
<tr>
<td><b>default_camera</b></td><td><em>BOOLEAN</em></td><td>Set to true to create default camera when none is found </td></tr>
<tr>
<td><b>default_lights</b></td><td><em>BOOLEAN</em></td><td>Set to true to create default lights when none is found </td></tr>
<tr>
<td><b>light_type</b></td><td><em>STRING</em></td><td>Selects type of light to be created for default lights (spot_light, distant_light, ...) </td></tr>
<tr>
<td><b>light_mode</b></td><td><em>STRING</em></td><td>Selects light arrangement to create (three_point, flashlight, skydome_light) </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe where nodes will be added (NULL for default universe) </td></tr>
    <tr><td class="paramname">params</td><td>list of parameters to modify which nodes are created and how </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb095fa507230ad53c261f7b2f486680" name="gadb095fa507230ad53c261f7b2f486680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb095fa507230ad53c261f7b2f486680">&#9670;&nbsp;</a></span>AiUniverseGetRenderSession()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtRenderSession * AiUniverseGetRenderSession </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the render session using the given universe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>Pointer to a universe (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the render session using this universe (NULL if no render session is created using this universe) </dd></dl>

</div>
</div>
<a id="ga7508871ef98819ae374827f02748688e" name="ga7508871ef98819ae374827f02748688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7508871ef98819ae374827f02748688e">&#9670;&nbsp;</a></span>AiUniverseCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiUniverseCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtParamValueMap *&#160;</td>
          <td class="paramname"><em>diffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two universes. </p>
<p >This function will compare 2 universes node by node, optionally filtered by a node mask, and returns true only when both universes have the same nodes with the same parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe1</td><td>Pointer to a universe (NULL for default universe) </td></tr>
    <tr><td class="paramname">universe2</td><td>Pointer to a universe (NULL for default universe) </td></tr>
    <tr><td class="paramname">node_mask</td><td>bitmask of node types, e.g <code>AI_NODE_ALL</code>, <code>AI_NODE_LIGHT</code> | <code>AI_NODE_SHADER</code>, etc. </td></tr>
    <tr><td class="paramname">diffs</td><td>Optional list of differences to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if universes are equivalent, and false if there is any difference </dd></dl>

</div>
</div>
<a id="gac3391fdd454ae80278256ad1861f9ae1" name="gac3391fdd454ae80278256ad1861f9ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3391fdd454ae80278256ad1861f9ae1">&#9670;&nbsp;</a></span>AiUniverseGetId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API uint32_t AiUniverseGetId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 32bit integer ID for a universe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>Pointer to a universe (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32bit integer ID value </dd></dl>

</div>
</div>
<a id="gaaed3747699d67673f58ae1f87c7f264d" name="gaaed3747699d67673f58ae1f87c7f264d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaed3747699d67673f58ae1f87c7f264d">&#9670;&nbsp;</a></span>AiUniverseGetFromId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtUniverse.html">AtUniverse</a> * AiUniverseGetFromId </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>universe_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a universe from its 32bit integer ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe_id</td><td>32bit integer ID for universe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the universe with this ID (or NULL if not found) </dd></dl>

</div>
</div>
<a id="gac14e2b776f7e32dcb7346f64061f28ff" name="gac14e2b776f7e32dcb7346f64061f28ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac14e2b776f7e32dcb7346f64061f28ff">&#9670;&nbsp;</a></span>AiNodeIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtNodeIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a node iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>node iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96d69986fc556e8a69c400d355558238" name="ga96d69986fc556e8a69c400d355558238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96d69986fc556e8a69c400d355558238">&#9670;&nbsp;</a></span>AiNodeIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiNodeIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtNodeIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current node and points node iterator to the next node. </p>
<p >This function is designed to be used inside a loop, as illustrated by the following example:</p>
<div class="fragment"><div class="line">AtNodeIterator *iter = <a class="code hl_function" href="group__ai__universe.html#ga7e9a681d265bf5ce15f4964a008f2ecc">AiUniverseGetNodeIterator</a>(<a class="code hl_define" href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a>);</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">AiNodeIteratorFinished</a>(iter))</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_struct" href="structAtNode.html">AtNode</a> *node = <a class="code hl_function" href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238">AiNodeIteratorGetNext</a>(iter);</div>
<div class="line">   <span class="comment">// do something with node ...</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">AiNodeIteratorDestroy</a>(iter);</div>
<div class="ttc" id="agroup__ai__node__entry_html_gaaf029c124baf82592ee04a8a303be9d8"><div class="ttname"><a href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a></div><div class="ttdeci">#define AI_NODE_ALL</div><div class="ttdoc">Bitmask including all node types, used by AiSceneWrite()</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:49</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga7e9a681d265bf5ce15f4964a008f2ecc"><div class="ttname"><a href="group__ai__universe.html#ga7e9a681d265bf5ce15f4964a008f2ecc">AiUniverseGetNodeIterator</a></div><div class="ttdeci">AI_API AtNodeIterator * AiUniverseGetNodeIterator(const AtUniverse *universe, unsigned int node_mask)</div><div class="ttdoc">Creates a new node iterator for the given Arnold universe and resets it to the first node.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:220</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga96d69986fc556e8a69c400d355558238"><div class="ttname"><a href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238">AiNodeIteratorGetNext</a></div><div class="ttdeci">AI_API AtNode * AiNodeIteratorGetNext(AtNodeIterator *iter)</div><div class="ttdoc">Returns current node and points node iterator to the next node.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:513</div></div>
<div class="ttc" id="agroup__ai__universe_html_gac14e2b776f7e32dcb7346f64061f28ff"><div class="ttname"><a href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">AiNodeIteratorDestroy</a></div><div class="ttdeci">AI_API void AiNodeIteratorDestroy(AtNodeIterator *iter)</div><div class="ttdoc">Destroys a node iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:488</div></div>
<div class="ttc" id="agroup__ai__universe_html_gaed6b120df6cb2b6b57dc700d04d5f118"><div class="ttname"><a href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">AiNodeIteratorFinished</a></div><div class="ttdeci">AI_API AI_PURE bool AiNodeIteratorFinished(const AtNodeIterator *iter)</div><div class="ttdoc">Returns true if there are no more nodes to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:524</div></div>
<div class="ttc" id="astructAtNode_html"><div class="ttname"><a href="structAtNode.html">AtNode</a></div><div class="ttdoc">This represents a node in Arnold.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node pointed by the iterator, or <code>NULL</code> if there are no more nodes to iterate over </dd></dl>

</div>
</div>
<a id="gaed6b120df6cb2b6b57dc700d04d5f118" name="gaed6b120df6cb2b6b57dc700d04d5f118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6b120df6cb2b6b57dc700d04d5f118">&#9670;&nbsp;</a></span>AiNodeIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtNodeIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more nodes to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node iterator has moved past the last node </dd></dl>

</div>
</div>
<a id="gacdbbbed549f79288819316f227def22f" name="gacdbbbed549f79288819316f227def22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdbbbed549f79288819316f227def22f">&#9670;&nbsp;</a></span>AiNodeEntryIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeEntryIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtNodeEntryIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a node entry iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>node entry iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d85c49a5621567ae11016a915b7395c" name="ga5d85c49a5621567ae11016a915b7395c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d85c49a5621567ae11016a915b7395c">&#9670;&nbsp;</a></span>AiNodeEntryIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> * AiNodeEntryIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtNodeEntryIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current node entry and points node entry iterator to the next node entry. </p>
<p >This function is designed to be used inside a loop, as illustrated by the following example:</p>
<div class="fragment"><div class="line">AtNodeEntryIterator *iter = <a class="code hl_function" href="group__ai__universe.html#ga02ded8db7a6f764a902173e6f38d468d">AiUniverseGetNodeEntryIterator</a>(<a class="code hl_define" href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a>);</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__universe.html#ga2b7978243ad260abcb7b6a7f2468aca7">AiNodeEntryIteratorFinished</a>(iter))</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_struct" href="structAtNodeEntry.html">AtNodeEntry</a> *node_entry = <a class="code hl_function" href="group__ai__universe.html#ga5d85c49a5621567ae11016a915b7395c">AiNodeEntryIteratorGetNext</a>(iter);</div>
<div class="line">   <span class="comment">// do something with node_entry ...</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f">AiNodeEntryIteratorDestroy</a>(iter);</div>
<div class="ttc" id="agroup__ai__universe_html_ga02ded8db7a6f764a902173e6f38d468d"><div class="ttname"><a href="group__ai__universe.html#ga02ded8db7a6f764a902173e6f38d468d">AiUniverseGetNodeEntryIterator</a></div><div class="ttdeci">AI_API AtNodeEntryIterator * AiUniverseGetNodeEntryIterator(unsigned int node_mask)</div><div class="ttdoc">Creates a new node entry iterator and resets it to the first installed node entry.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:249</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga2b7978243ad260abcb7b6a7f2468aca7"><div class="ttname"><a href="group__ai__universe.html#ga2b7978243ad260abcb7b6a7f2468aca7">AiNodeEntryIteratorFinished</a></div><div class="ttdeci">AI_API AI_PURE bool AiNodeEntryIteratorFinished(const AtNodeEntryIterator *iter)</div><div class="ttdoc">Returns true if there are no more node entries to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:576</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga5d85c49a5621567ae11016a915b7395c"><div class="ttname"><a href="group__ai__universe.html#ga5d85c49a5621567ae11016a915b7395c">AiNodeEntryIteratorGetNext</a></div><div class="ttdeci">AI_API AtNodeEntry * AiNodeEntryIteratorGetNext(AtNodeEntryIterator *iter)</div><div class="ttdoc">Returns current node entry and points node entry iterator to the next node entry.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:565</div></div>
<div class="ttc" id="agroup__ai__universe_html_gacdbbbed549f79288819316f227def22f"><div class="ttname"><a href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f">AiNodeEntryIteratorDestroy</a></div><div class="ttdeci">AI_API void AiNodeEntryIteratorDestroy(AtNodeEntryIterator *iter)</div><div class="ttdoc">Destroys a node entry iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:540</div></div>
<div class="ttc" id="astructAtNodeEntry_html"><div class="ttname"><a href="structAtNodeEntry.html">AtNodeEntry</a></div><div class="ttdoc">This represents a node type in Arnold.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node entry iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node entry pointed by the iterator, or <code>NULL</code> if there are no more node entries to iterate over </dd></dl>

</div>
</div>
<a id="ga2b7978243ad260abcb7b6a7f2468aca7" name="ga2b7978243ad260abcb7b6a7f2468aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b7978243ad260abcb7b6a7f2468aca7">&#9670;&nbsp;</a></span>AiNodeEntryIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeEntryIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtNodeEntryIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more node entries to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node entry iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node entry iterator has moved past the last node entry </dd></dl>

</div>
</div>
<a id="gae3f61927424448febb6f7bd5b878b68d" name="gae3f61927424448febb6f7bd5b878b68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f61927424448febb6f7bd5b878b68d">&#9670;&nbsp;</a></span>AiAOVIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiAOVIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtAOVIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a AOV iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>AOV iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga907f3d834b7fe4fe16914a86857a0357" name="ga907f3d834b7fe4fe16914a86857a0357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga907f3d834b7fe4fe16914a86857a0357">&#9670;&nbsp;</a></span>AiAOVIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtAOVEntry.html">AtAOVEntry</a> * AiAOVIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtAOVIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current AOV entry and points AOV iterator to the next AOV. </p>
<p >This function is designed to be used inside a loop, as illustrated by the following example:</p>
<div class="fragment"><div class="line">AtAOVIterator* iter = <a class="code hl_function" href="group__ai__universe.html#gacd3afc59b9d4f4f925a132711864ee14">AiUniverseGetAOVIterator</a>();</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__universe.html#gabdb557694ef170cb568d03cdc543ed8f">AiAOVIteratorFinished</a>(iter))</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_struct" href="structAtAOVEntry.html">AtAOVEntry</a>* aov_entry = <a class="code hl_function" href="group__ai__universe.html#ga907f3d834b7fe4fe16914a86857a0357">AiAOVIteratorGetNext</a>(iter);</div>
<div class="line">   <span class="comment">// do something with aov_entry ...</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d">AiAOVIteratorDestroy</a>(iter);</div>
<div class="ttc" id="agroup__ai__universe_html_ga907f3d834b7fe4fe16914a86857a0357"><div class="ttname"><a href="group__ai__universe.html#ga907f3d834b7fe4fe16914a86857a0357">AiAOVIteratorGetNext</a></div><div class="ttdeci">AI_API const AtAOVEntry * AiAOVIteratorGetNext(AtAOVIterator *iter)</div><div class="ttdoc">Returns current AOV entry and points AOV iterator to the next AOV.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:616</div></div>
<div class="ttc" id="agroup__ai__universe_html_gabdb557694ef170cb568d03cdc543ed8f"><div class="ttname"><a href="group__ai__universe.html#gabdb557694ef170cb568d03cdc543ed8f">AiAOVIteratorFinished</a></div><div class="ttdeci">AI_API AI_PURE bool AiAOVIteratorFinished(const AtAOVIterator *iter)</div><div class="ttdoc">Returns true if there are no more AOV entries to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:627</div></div>
<div class="ttc" id="agroup__ai__universe_html_gacd3afc59b9d4f4f925a132711864ee14"><div class="ttname"><a href="group__ai__universe.html#gacd3afc59b9d4f4f925a132711864ee14">AiUniverseGetAOVIterator</a></div><div class="ttdeci">AI_API AtAOVIterator * AiUniverseGetAOVIterator(const AtUniverse *universe)</div><div class="ttdoc">Creates a new AOV iterator for a specific universe and resets it to the first entry.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:264</div></div>
<div class="ttc" id="agroup__ai__universe_html_gae3f61927424448febb6f7bd5b878b68d"><div class="ttname"><a href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d">AiAOVIteratorDestroy</a></div><div class="ttdeci">AI_API void AiAOVIteratorDestroy(AtAOVIterator *iter)</div><div class="ttdoc">Destroys a AOV iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:591</div></div>
<div class="ttc" id="astructAtAOVEntry_html"><div class="ttname"><a href="structAtAOVEntry.html">AtAOVEntry</a></div><div class="ttdoc">This helper struct is used to return information from the AOV iterator.</div><div class="ttdef"><b>Definition:</b> ai_universe.h:34</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>AOV iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the AOV pointed by the iterator, or <code>NULL</code> if there are no more AOV entries to iterate over </dd></dl>

</div>
</div>
<a id="gabdb557694ef170cb568d03cdc543ed8f" name="gabdb557694ef170cb568d03cdc543ed8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdb557694ef170cb568d03cdc543ed8f">&#9670;&nbsp;</a></span>AiAOVIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiAOVIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtAOVIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more AOV entries to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a AOV iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the AOV iterator has moved past the last AOV </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
