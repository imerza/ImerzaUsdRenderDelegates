<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Light Sampling API</div></div>
</div><!--header-->
<div class="contents">

<p>Light sampling.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtLightSample.html">AtLightSample</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Light sample data structure.  <a href="structAtLightSample.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga760437b92b3eb71c9f7ed6f0e4571bbc"><td class="memItemLeft" align="right" valign="top"><a id="ga760437b92b3eb71c9f7ed6f0e4571bbc" name="ga760437b92b3eb71c9f7ed6f0e4571bbc"></a>
const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::Lp</b></td></tr>
<tr class="memdesc:ga760437b92b3eb71c9f7ed6f0e4571bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to light node <br  />
 <br /></td></tr>
<tr class="separator:ga760437b92b3eb71c9f7ed6f0e4571bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b7e702ac60f08574f063f8912b692d"><td class="memItemLeft" align="right" valign="top"><a id="ga48b7e702ac60f08574f063f8912b692d" name="ga48b7e702ac60f08574f063f8912b692d"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::Ldist</b></td></tr>
<tr class="memdesc:ga48b7e702ac60f08574f063f8912b692d"><td class="mdescLeft">&#160;</td><td class="mdescRight">distance from P to light source <br  />
 <br /></td></tr>
<tr class="separator:ga48b7e702ac60f08574f063f8912b692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80abef8a8fcbbc0889b0add1d2934789"><td class="memItemLeft" align="right" valign="top"><a id="ga80abef8a8fcbbc0889b0add1d2934789" name="ga80abef8a8fcbbc0889b0add1d2934789"></a>
<a class="el" href="structAtVector.html">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::Ld</b></td></tr>
<tr class="memdesc:ga80abef8a8fcbbc0889b0add1d2934789"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalized direction vector from P to the light sample <br  />
 <br /></td></tr>
<tr class="separator:ga80abef8a8fcbbc0889b0add1d2934789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd1e4f6608f78bd1573e8f8bf623be0"><td class="memItemLeft" align="right" valign="top"><a id="gabcd1e4f6608f78bd1573e8f8bf623be0" name="gabcd1e4f6608f78bd1573e8f8bf623be0"></a>
<a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::Li</b></td></tr>
<tr class="memdesc:gabcd1e4f6608f78bd1573e8f8bf623be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">incident radiance, same as <code>Liu</code> * (1 - <code>Lo</code>) <br  />
 <br /></td></tr>
<tr class="separator:gabcd1e4f6608f78bd1573e8f8bf623be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3d7a125c615937fbe6bf18980fd02b"><td class="memItemLeft" align="right" valign="top"><a id="ga8e3d7a125c615937fbe6bf18980fd02b" name="ga8e3d7a125c615937fbe6bf18980fd02b"></a>
<a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::Liu</b></td></tr>
<tr class="memdesc:ga8e3d7a125c615937fbe6bf18980fd02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">unoccluded incident radiance <br  />
 <br /></td></tr>
<tr class="separator:ga8e3d7a125c615937fbe6bf18980fd02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b12b4e259c81c03a2d50fef1b50a615"><td class="memItemLeft" align="right" valign="top"><a id="ga8b12b4e259c81c03a2d50fef1b50a615" name="ga8b12b4e259c81c03a2d50fef1b50a615"></a>
<a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::Lo</b></td></tr>
<tr class="memdesc:ga8b12b4e259c81c03a2d50fef1b50a615"><td class="mdescLeft">&#160;</td><td class="mdescRight">shadow occlusion factor, (1,1,1) means fully occluded <br  />
 <br /></td></tr>
<tr class="separator:ga8b12b4e259c81c03a2d50fef1b50a615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a3b267a0b1a56566a7bc819fc7e338"><td class="memItemLeft" align="right" valign="top"><a id="ga77a3b267a0b1a56566a7bc819fc7e338" name="ga77a3b267a0b1a56566a7bc819fc7e338"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtLightSample::pdf</b></td></tr>
<tr class="memdesc:ga77a3b267a0b1a56566a7bc819fc7e338"><td class="mdescLeft">&#160;</td><td class="mdescRight">sample probability density function <br  />
 <br /></td></tr>
<tr class="separator:ga77a3b267a0b1a56566a7bc819fc7e338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f542d8852eac09ab1a6160ea416148"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#ga33f542d8852eac09ab1a6160ea416148">AtLightSample::trace_ray_types</a></td></tr>
<tr class="memdesc:ga33f542d8852eac09ab1a6160ea416148"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitmask of ray types that will return light hits from AiLightsTrace  <a href="group__ai__shader__lights.html#ga33f542d8852eac09ab1a6160ea416148">More...</a><br /></td></tr>
<tr class="separator:ga33f542d8852eac09ab1a6160ea416148"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Light Loop Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpb422192829e427e326a1226e70fabc8e"></a>This is the API for looping over light source samples. </p>
</td></tr>
<tr class="memitem:gaf117a89db0e2e2a565b91024a5b9040c"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#gaf117a89db0e2e2a565b91024a5b9040c">AiLightsPrepare</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gaf117a89db0e2e2a565b91024a5b9040c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize light sampling loop.  <a href="group__ai__shader__lights.html#gaf117a89db0e2e2a565b91024a5b9040c">More...</a><br /></td></tr>
<tr class="separator:gaf117a89db0e2e2a565b91024a5b9040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f6022718190265298c4a3c98af0958"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#gaf9f6022718190265298c4a3c98af0958">AiLightsGetSample</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtLightSample.html">AtLightSample</a> &amp;sample)</td></tr>
<tr class="memdesc:gaf9f6022718190265298c4a3c98af0958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a cached light sample within a light loop.  <a href="group__ai__shader__lights.html#gaf9f6022718190265298c4a3c98af0958">More...</a><br /></td></tr>
<tr class="separator:gaf9f6022718190265298c4a3c98af0958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d213b31354f46df56156e0583df635"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#ga77d213b31354f46df56156e0583df635">AiLightsTrace</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtVector.html">AtVector</a> &amp;dir, uint8_t ray_type, <a class="el" href="structAtLightSample.html">AtLightSample</a> *&amp;hits)</td></tr>
<tr class="memdesc:ga77d213b31354f46df56156e0583df635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect all lights present in the light sampling loop for a given ray type and direction as seen from the shading point <code><a class="el" href="group__ai__shader__globals.html#ga3ec4087242f8c51e0f6f5bd5b4b938ea" title="shading point in world-space">AtShaderGlobals::P</a></code>, and return any hits as an array of <code>AtLightSamples</code>.  <a href="group__ai__shader__lights.html#ga77d213b31354f46df56156e0583df635">More...</a><br /></td></tr>
<tr class="separator:ga77d213b31354f46df56156e0583df635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b19437130a1c661da131397bcbea5d"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#gae2b19437130a1c661da131397bcbea5d">AiLightsTraceRayTypes</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gae2b19437130a1c661da131397bcbea5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask of ray types for which <code>AiLightsTrace</code> can be effectively used in the given shading context.  <a href="group__ai__shader__lights.html#gae2b19437130a1c661da131397bcbea5d">More...</a><br /></td></tr>
<tr class="separator:gae2b19437130a1c661da131397bcbea5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9d9698ee23df888465e0e49338a8e4"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#ga6f9d9698ee23df888465e0e49338a8e4">AiLightsResetCache</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga6f9d9698ee23df888465e0e49338a8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the light cache before running another light loop.  <a href="group__ai__shader__lights.html#ga6f9d9698ee23df888465e0e49338a8e4">More...</a><br /></td></tr>
<tr class="separator:ga6f9d9698ee23df888465e0e49338a8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7023b116574d1e36e9e1b738af743ff0"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#ga7023b116574d1e36e9e1b738af743ff0">AiLightsIntegrateShadowMatte</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, AtBSDF *bsdf=NULL)</td></tr>
<tr class="memdesc:ga7023b116574d1e36e9e1b738af743ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shadow or occlusion value for the current shading point and the active set of lights using the specified BSDF.  <a href="group__ai__shader__lights.html#ga7023b116574d1e36e9e1b738af743ff0">More...</a><br /></td></tr>
<tr class="separator:ga7023b116574d1e36e9e1b738af743ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Light Getter Methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpb35d355b57b3ee55a58356ce76503249"></a>These getters are to avoid slow AiNodeGet*() calls to access light parameters. Only the most common attributes are exposed for now. </p>
</td></tr>
<tr class="memitem:gaca36d6acc59d03fb882d445356b6078c"><td class="memItemLeft" align="right" valign="top"><a id="gaca36d6acc59d03fb882d445356b6078c" name="gaca36d6acc59d03fb882d445356b6078c"></a>
AI_API AI_PURE <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetColor</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gaca36d6acc59d03fb882d445356b6078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for parameter color. <br /></td></tr>
<tr class="separator:gaca36d6acc59d03fb882d445356b6078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6057ffba147f5bf5c4784f7cb8eab8e"><td class="memItemLeft" align="right" valign="top"><a id="gae6057ffba147f5bf5c4784f7cb8eab8e" name="gae6057ffba147f5bf5c4784f7cb8eab8e"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetIntensity</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gae6057ffba147f5bf5c4784f7cb8eab8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for parameter intensity. <br /></td></tr>
<tr class="separator:gae6057ffba147f5bf5c4784f7cb8eab8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00335201b31f5ecb84cd062a1a398072"><td class="memItemLeft" align="right" valign="top"><a id="ga00335201b31f5ecb84cd062a1a398072" name="ga00335201b31f5ecb84cd062a1a398072"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetDiffuse</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga00335201b31f5ecb84cd062a1a398072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for the light's diffuse shading multiplier. <br /></td></tr>
<tr class="separator:ga00335201b31f5ecb84cd062a1a398072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d6d43a01a6061ea984affaff39becd"><td class="memItemLeft" align="right" valign="top"><a id="gac4d6d43a01a6061ea984affaff39becd" name="gac4d6d43a01a6061ea984affaff39becd"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetSpecular</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gac4d6d43a01a6061ea984affaff39becd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for the light's specular reflection shading multiplier. <br /></td></tr>
<tr class="separator:gac4d6d43a01a6061ea984affaff39becd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c32a268a78bdad8501d18cad326b25"><td class="memItemLeft" align="right" valign="top"><a id="ga61c32a268a78bdad8501d18cad326b25" name="ga61c32a268a78bdad8501d18cad326b25"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetTransmission</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga61c32a268a78bdad8501d18cad326b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for the light's specular transmission shading multiplier. <br /></td></tr>
<tr class="separator:ga61c32a268a78bdad8501d18cad326b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7c592197906918bd5ef5331d896287"><td class="memItemLeft" align="right" valign="top"><a id="gabc7c592197906918bd5ef5331d896287" name="gabc7c592197906918bd5ef5331d896287"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetSSS</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gabc7c592197906918bd5ef5331d896287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for the light's SSS shading multiplier. <br /></td></tr>
<tr class="separator:gabc7c592197906918bd5ef5331d896287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28d0c6ccb1d6940b948dcf93b2fc1ba"><td class="memItemLeft" align="right" valign="top"><a id="gae28d0c6ccb1d6940b948dcf93b2fc1ba" name="gae28d0c6ccb1d6940b948dcf93b2fc1ba"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetVolume</b> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gae28d0c6ccb1d6940b948dcf93b2fc1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast getter method for the light's volume shading multiplier. <br /></td></tr>
<tr class="separator:gae28d0c6ccb1d6940b948dcf93b2fc1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908b35920fbde36dbff51a87f76f73bd"><td class="memItemLeft" align="right" valign="top"><a id="ga908b35920fbde36dbff51a87f76f73bd" name="ga908b35920fbde36dbff51a87f76f73bd"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiLightGetInfluence</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtNode.html">AtNode</a> *node, uint8_t ray_type)</td></tr>
<tr class="memdesc:ga908b35920fbde36dbff51a87f76f73bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get light shading multiplier depending on the shading context and ray type. <br /></td></tr>
<tr class="separator:ga908b35920fbde36dbff51a87f76f73bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Light IES Format Parser</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp992d5d788975521d34f28709fab0de03"></a>Not a shader specific call, this is called by plugins or host DCCs to parse IES files </p>
</td></tr>
<tr class="memitem:ga29673623129d7cfe116e2b01c99bb796"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__lights.html#ga29673623129d7cfe116e2b01c99bb796">AiLightIESLoad</a> (const <a class="el" href="classAtString.html">AtString</a> filename, const unsigned int width, const unsigned int height, float *max_intensity, float *data)</td></tr>
<tr class="memdesc:ga29673623129d7cfe116e2b01c99bb796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an IES profile and returns a lat long array of intensity values.  <a href="group__ai__shader__lights.html#ga29673623129d7cfe116e2b01c99bb796">More...</a><br /></td></tr>
<tr class="separator:ga29673623129d7cfe116e2b01c99bb796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Light sampling. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf117a89db0e2e2a565b91024a5b9040c" name="gaf117a89db0e2e2a565b91024a5b9040c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf117a89db0e2e2a565b91024a5b9040c">&#9670;&nbsp;</a></span>AiLightsPrepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiLightsPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize light sampling loop. </p>
<p >Prepares the given shader globals with a light sample cache and other variables used when looping over lights samples. The creation of the light sample cache is where lights are sampled, light samples are filtered, and shadow rays are cast as needed.</p>
<p >The sample cache will be reused in subsequent <code><a class="el" href="group__ai__shader__lights.html#gaf117a89db0e2e2a565b91024a5b9040c" title="Initialize light sampling loop.">AiLightsPrepare()</a></code> calls unless the shader globals has been changed in ways that would involve a different set of lights, different shadow rays to be traced or a different set of light samples to be produced.</p>
<p ><code><a class="el" href="structAtShaderGlobals.html" title="Shader globals data structure.">AtShaderGlobals</a></code> fields whose changes invalidate the light sample cache include: sc, fhemi, skip_shadow, inclusive_traceset, traceset, N, Nf, P</p>
<p >The light sample cache may also be manually invalidated at any time by calling <a class="el" href="group__ai__shader__lights.html#ga6f9d9698ee23df888465e0e49338a8e4" title="Reset the light cache before running another light loop.">AiLightsResetCache()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Deprecated, use shader closures instead of integrating light in shaders.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sg</td><td>the shader globals context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9f6022718190265298c4a3c98af0958" name="gaf9f6022718190265298c4a3c98af0958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f6022718190265298c4a3c98af0958">&#9670;&nbsp;</a></span>AiLightsGetSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE bool AiLightsGetSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtLightSample.html">AtLightSample</a> &amp;&#160;</td>
          <td class="paramname"><em>light_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a cached light sample within a light loop. </p>
<p >After <code><a class="el" href="group__ai__shader__lights.html#gaf117a89db0e2e2a565b91024a5b9040c" title="Initialize light sampling loop.">AiLightsPrepare()</a></code> has been called, this function should be called inside a while loop. The call returns true if a valid light sample has been set. globals context are set:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sg</td><td>the shader globals context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid sample was available </dd></dl>

</div>
</div>
<a id="ga77d213b31354f46df56156e0583df635" name="ga77d213b31354f46df56156e0583df635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d213b31354f46df56156e0583df635">&#9670;&nbsp;</a></span>AiLightsTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE uint32_t AiLightsTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ray_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtLightSample.html">AtLightSample</a> *&amp;&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect all lights present in the light sampling loop for a given ray type and direction as seen from the shading point <code><a class="el" href="group__ai__shader__globals.html#ga3ec4087242f8c51e0f6f5bd5b4b938ea" title="shading point in world-space">AtShaderGlobals::P</a></code>, and return any hits as an array of <code>AtLightSamples</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It is expected for this function to be called only once per BSDF lobe sample as part of an MIS direct light sampling implementation. The number of BSDF samples for the lobe's <code>AtBSDFLobeInfo::ray_type</code> is defined by the corresponding render option GI sample setting.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>the direction in which to sample </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ray_type</td><td>the ray type of the light sample </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hits</td><td>array of light intersections detected for the given context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of light intersections detected for the given context </dd></dl>

</div>
</div>
<a id="gae2b19437130a1c661da131397bcbea5d" name="gae2b19437130a1c661da131397bcbea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b19437130a1c661da131397bcbea5d">&#9670;&nbsp;</a></span>AiLightsTraceRayTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE uint8_t AiLightsTraceRayTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bitmask of ray types for which <code>AiLightsTrace</code> can be effectively used in the given shading context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>the shader globals context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mask of the types of rays for which the prepared set of lights are potentially visible </dd></dl>

</div>
</div>
<a id="ga6f9d9698ee23df888465e0e49338a8e4" name="ga6f9d9698ee23df888465e0e49338a8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9d9698ee23df888465e0e49338a8e4">&#9670;&nbsp;</a></span>AiLightsResetCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiLightsResetCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the light cache before running another light loop. </p>
<p >When called, <code><a class="el" href="group__ai__shader__lights.html#gaf117a89db0e2e2a565b91024a5b9040c" title="Initialize light sampling loop.">AiLightsPrepare()</a></code> caches a set of sampled and shadowed light samples such that subsequent calls will incur little overhead unless the light sampling context has changed in ways that would involve a different set of lights, different shadow rays to be traced or a different set of light samples to be produced. In these cases, the cached set of light samples is invalidated and a new set of samples is produced.</p>
<p ><code><a class="el" href="structAtShaderGlobals.html" title="Shader globals data structure.">AtShaderGlobals</a></code> fields whose changes invalidate the light sample cache include: sc, fhemi, skip_shadow, inclusive_traceset, traceset, N, Nf, P</p>
<p >These shader globals should capture all situations where built-in lighting and shading functionality would require a fresh set of samples to reflect the changed context, however, certain custom light loops and shading operations may involve other information that is not pertinent to the built-in light loop functionality. This function is provided as a manual reset of the light sample cache in situations for cache invalidation that are not contemplated by default.</p>
<dl class="section warning"><dt>Warning</dt><dd>Resetting the light cache when it is not strictly necessary may severely impact performance, as extra shadow rays are traced unnecessarily. Be sure to only use this when you need to make sure and gather a new set of light samples.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>the shader globals context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7023b116574d1e36e9e1b738af743ff0" name="ga7023b116574d1e36e9e1b738af743ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7023b116574d1e36e9e1b738af743ff0">&#9670;&nbsp;</a></span>AiLightsIntegrateShadowMatte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtRGB.html">AtRGB</a> AiLightsIntegrateShadowMatte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtBSDF *&#160;</td>
          <td class="paramname"><em>bsdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the shadow or occlusion value for the current shading point and the active set of lights using the specified BSDF. </p>
<p >Shadow occlusion is defined as the complementary of the ratio of actual reflected light with respect unshadowed reflected light, or the integral of (1 - Li / Liu)</p>
<p >If no BSDF is specified a default front facing Oren Nayar will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>the shader globals context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of light occlusion per color channel </dd></dl>

</div>
</div>
<a id="ga29673623129d7cfe116e2b01c99bb796" name="ga29673623129d7cfe116e2b01c99bb796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29673623129d7cfe116e2b01c99bb796">&#9670;&nbsp;</a></span>AiLightIESLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiLightIESLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max_intensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an IES profile and returns a lat long array of intensity values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the IES profile map </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">width</td><td>Width of the IES profile intensity output array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">height</td><td>Height of the IES profile intensity output array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_intensity</td><td>IES profile maximum intensity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>IES profile normalized intensity data. Underlying buffer is allocated by caller. Caller should make sure it has the proper size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the IES profile conversion was successful. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga33f542d8852eac09ab1a6160ea416148" name="ga33f542d8852eac09ab1a6160ea416148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f542d8852eac09ab1a6160ea416148">&#9670;&nbsp;</a></span>trace_ray_types</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t AtLightSample::trace_ray_types</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bitmask of ray types that will return light hits from AiLightsTrace </p>
<p >and so can use multiple importance sampling (MIS) <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
