<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Texture Mapping API</div></div>
</div><!--header-->
<div class="contents">

<p>Texture mapping system.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtTextureParams.html">AtTextureParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds all of the available texture map look-up options.  <a href="structAtTextureParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtImage.html">AtImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds infromation for reading, writing and resizing images.  <a href="structAtImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtTextureHandle.html">AtTextureHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds a handle for a given texture.  <a href="structAtTextureHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab0c2ee5a526fe7e37c671f590d06a640"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gab0c2ee5a526fe7e37c671f590d06a640">AtTextureParams::fill</a></td></tr>
<tr class="memdesc:gab0c2ee5a526fe7e37c671f590d06a640"><td class="mdescLeft">&#160;</td><td class="mdescRight">value for nonexistent channels (e.g.  <a href="group__ai__texture.html#gab0c2ee5a526fe7e37c671f590d06a640">More...</a><br /></td></tr>
<tr class="separator:gab0c2ee5a526fe7e37c671f590d06a640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d5de9e91d203f275a0d1f74b9c30b2"><td class="memItemLeft" align="right" valign="top"><a id="gaf8d5de9e91d203f275a0d1f74b9c30b2" name="gaf8d5de9e91d203f275a0d1f74b9c30b2"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::filter</b>: 2</td></tr>
<tr class="memdesc:gaf8d5de9e91d203f275a0d1f74b9c30b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">texture look-up mode <br  />
 <br /></td></tr>
<tr class="separator:gaf8d5de9e91d203f275a0d1f74b9c30b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f2c27d8e2e9385916f2d52a36284f2"><td class="memItemLeft" align="right" valign="top"><a id="ga45f2c27d8e2e9385916f2d52a36284f2" name="ga45f2c27d8e2e9385916f2d52a36284f2"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::wrap_s</b>: 3</td></tr>
<tr class="memdesc:ga45f2c27d8e2e9385916f2d52a36284f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrap mode for S coordinate <br  />
 <br /></td></tr>
<tr class="separator:ga45f2c27d8e2e9385916f2d52a36284f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f931fc216d0ee167fff0b495654a81"><td class="memItemLeft" align="right" valign="top"><a id="gac2f931fc216d0ee167fff0b495654a81" name="gac2f931fc216d0ee167fff0b495654a81"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::wrap_t</b>: 3</td></tr>
<tr class="memdesc:gac2f931fc216d0ee167fff0b495654a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrap mode for T coordinate <br  />
 <br /></td></tr>
<tr class="separator:gac2f931fc216d0ee167fff0b495654a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga944c05b65d3bc0808624b90ac1fdf3b8"><td class="memItemLeft" align="right" valign="top"><a id="ga944c05b65d3bc0808624b90ac1fdf3b8" name="ga944c05b65d3bc0808624b90ac1fdf3b8"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::start_channel</b></td></tr>
<tr class="memdesc:ga944c05b65d3bc0808624b90ac1fdf3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting channel index to read from <br  />
 <br /></td></tr>
<tr class="separator:ga944c05b65d3bc0808624b90ac1fdf3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c55a9dcf6fc4e42c453c37433bb52b3"><td class="memItemLeft" align="right" valign="top"><a id="ga0c55a9dcf6fc4e42c453c37433bb52b3" name="ga0c55a9dcf6fc4e42c453c37433bb52b3"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::mipmap_bias</b></td></tr>
<tr class="memdesc:ga0c55a9dcf6fc4e42c453c37433bb52b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">mipmap level bias <br  />
 <br /></td></tr>
<tr class="separator:ga0c55a9dcf6fc4e42c453c37433bb52b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5d8e4532e06622a9dac236c8cdc6da"><td class="memItemLeft" align="right" valign="top"><a id="gabf5d8e4532e06622a9dac236c8cdc6da" name="gabf5d8e4532e06622a9dac236c8cdc6da"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::mipmap_mode</b>: 3</td></tr>
<tr class="memdesc:gabf5d8e4532e06622a9dac236c8cdc6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">mode for mipmap blending and filtering <br  />
 <br /></td></tr>
<tr class="separator:gabf5d8e4532e06622a9dac236c8cdc6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ede3056e075e055cadee4a037faa466"><td class="memItemLeft" align="right" valign="top"><a id="ga9ede3056e075e055cadee4a037faa466" name="ga9ede3056e075e055cadee4a037faa466"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::single_channel</b>: 1</td></tr>
<tr class="memdesc:ga9ede3056e075e055cadee4a037faa466"><td class="mdescLeft">&#160;</td><td class="mdescRight">treat image as single channel <br  />
 <br /></td></tr>
<tr class="separator:ga9ede3056e075e055cadee4a037faa466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166f95e45cf635c43c0a74a71b1f7c40"><td class="memItemLeft" align="right" valign="top"><a id="ga166f95e45cf635c43c0a74a71b1f7c40" name="ga166f95e45cf635c43c0a74a71b1f7c40"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::flip_s</b>: 1</td></tr>
<tr class="memdesc:ga166f95e45cf635c43c0a74a71b1f7c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">flip S coordinate <br  />
 <br /></td></tr>
<tr class="separator:ga166f95e45cf635c43c0a74a71b1f7c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad3c9a26bd9d1956b00ab3e8a63c04c"><td class="memItemLeft" align="right" valign="top"><a id="ga4ad3c9a26bd9d1956b00ab3e8a63c04c" name="ga4ad3c9a26bd9d1956b00ab3e8a63c04c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::flip_t</b>: 1</td></tr>
<tr class="memdesc:ga4ad3c9a26bd9d1956b00ab3e8a63c04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">flip T coordinate <br  />
 <br /></td></tr>
<tr class="separator:ga4ad3c9a26bd9d1956b00ab3e8a63c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5bff38677579943fe096b23e3ca4f9"><td class="memItemLeft" align="right" valign="top"><a id="ga8b5bff38677579943fe096b23e3ca4f9" name="ga8b5bff38677579943fe096b23e3ca4f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::swap_st</b>: 1</td></tr>
<tr class="memdesc:ga8b5bff38677579943fe096b23e3ca4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable swapping of S and T coordinates <br  />
 <br /></td></tr>
<tr class="separator:ga8b5bff38677579943fe096b23e3ca4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51329e13bb56bdf705cb133a1dad1a16"><td class="memItemLeft" align="right" valign="top"><a id="ga51329e13bb56bdf705cb133a1dad1a16" name="ga51329e13bb56bdf705cb133a1dad1a16"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::scale_s</b></td></tr>
<tr class="memdesc:ga51329e13bb56bdf705cb133a1dad1a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale S coordinate <br  />
 <br /></td></tr>
<tr class="separator:ga51329e13bb56bdf705cb133a1dad1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ebccecc3f4cf7164c800f937ead278"><td class="memItemLeft" align="right" valign="top"><a id="ga24ebccecc3f4cf7164c800f937ead278" name="ga24ebccecc3f4cf7164c800f937ead278"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::scale_t</b></td></tr>
<tr class="memdesc:ga24ebccecc3f4cf7164c800f937ead278"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale T coordinate <br  />
 <br /></td></tr>
<tr class="separator:ga24ebccecc3f4cf7164c800f937ead278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a413aa46c4b26e12f605f1529d198c"><td class="memItemLeft" align="right" valign="top"><a id="gae9a413aa46c4b26e12f605f1529d198c" name="gae9a413aa46c4b26e12f605f1529d198c"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::width_s</b></td></tr>
<tr class="memdesc:gae9a413aa46c4b26e12f605f1529d198c"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplicative widening of look-ups on the S axis <br  />
 <br /></td></tr>
<tr class="separator:gae9a413aa46c4b26e12f605f1529d198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8f4c2e40751e067dae0be4911a4d71"><td class="memItemLeft" align="right" valign="top"><a id="ga3b8f4c2e40751e067dae0be4911a4d71" name="ga3b8f4c2e40751e067dae0be4911a4d71"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::width_t</b></td></tr>
<tr class="memdesc:ga3b8f4c2e40751e067dae0be4911a4d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplicative widening of look-ups on the T axis <br  />
 <br /></td></tr>
<tr class="separator:ga3b8f4c2e40751e067dae0be4911a4d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca523d2bce1265314cd486cc6b4127c5"><td class="memItemLeft" align="right" valign="top"><a id="gaca523d2bce1265314cd486cc6b4127c5" name="gaca523d2bce1265314cd486cc6b4127c5"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::blur_s</b></td></tr>
<tr class="memdesc:gaca523d2bce1265314cd486cc6b4127c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">additive blur in look-ups along the S axis <br  />
 <br /></td></tr>
<tr class="separator:gaca523d2bce1265314cd486cc6b4127c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec66e60ce2a8188600eae94cedef3a56"><td class="memItemLeft" align="right" valign="top"><a id="gaec66e60ce2a8188600eae94cedef3a56" name="gaec66e60ce2a8188600eae94cedef3a56"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtTextureParams::blur_t</b></td></tr>
<tr class="memdesc:gaec66e60ce2a8188600eae94cedef3a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">additive blur in look-ups along the T axis <br  />
 <br /></td></tr>
<tr class="separator:gaec66e60ce2a8188600eae94cedef3a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793f5dd2f8edd745568de054ab9ad8e8"><td class="memItemLeft" align="right" valign="top"><a id="ga793f5dd2f8edd745568de054ab9ad8e8" name="ga793f5dd2f8edd745568de054ab9ad8e8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::buffer</b> = nullptr</td></tr>
<tr class="memdesc:ga793f5dd2f8edd745568de054ab9ad8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">pixel values <br  />
 <br /></td></tr>
<tr class="separator:ga793f5dd2f8edd745568de054ab9ad8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad809675a50321f7a438b935ec04fe06f"><td class="memItemLeft" align="right" valign="top"><a id="gad809675a50321f7a438b935ec04fe06f" name="gad809675a50321f7a438b935ec04fe06f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::width</b> = 0</td></tr>
<tr class="memdesc:gad809675a50321f7a438b935ec04fe06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">width of the image in pixels <br  />
 <br /></td></tr>
<tr class="separator:gad809675a50321f7a438b935ec04fe06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc954f1b2a9a0c584dc93876ac905719"><td class="memItemLeft" align="right" valign="top"><a id="gafc954f1b2a9a0c584dc93876ac905719" name="gafc954f1b2a9a0c584dc93876ac905719"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::height</b> = 0</td></tr>
<tr class="memdesc:gafc954f1b2a9a0c584dc93876ac905719"><td class="mdescLeft">&#160;</td><td class="mdescRight">height of the image in pixels <br  />
 <br /></td></tr>
<tr class="separator:gafc954f1b2a9a0c584dc93876ac905719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db3ab9e38bb423a81337024bfe39d24"><td class="memItemLeft" align="right" valign="top"><a id="ga1db3ab9e38bb423a81337024bfe39d24" name="ga1db3ab9e38bb423a81337024bfe39d24"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::full_width</b> = 0</td></tr>
<tr class="memdesc:ga1db3ab9e38bb423a81337024bfe39d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">width of the full display window in pixels <br  />
 <br /></td></tr>
<tr class="separator:ga1db3ab9e38bb423a81337024bfe39d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76f349b55b4be7bee57157adfdc1291"><td class="memItemLeft" align="right" valign="top"><a id="gaf76f349b55b4be7bee57157adfdc1291" name="gaf76f349b55b4be7bee57157adfdc1291"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::full_height</b> = 0</td></tr>
<tr class="memdesc:gaf76f349b55b4be7bee57157adfdc1291"><td class="mdescLeft">&#160;</td><td class="mdescRight">height of the full display window in pixels <br  />
 <br /></td></tr>
<tr class="separator:gaf76f349b55b4be7bee57157adfdc1291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac575eb19a2c379c1cb6576c2e688ce27"><td class="memItemLeft" align="right" valign="top"><a id="gac575eb19a2c379c1cb6576c2e688ce27" name="gac575eb19a2c379c1cb6576c2e688ce27"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::x</b> = 0</td></tr>
<tr class="memdesc:gac575eb19a2c379c1cb6576c2e688ce27"><td class="mdescLeft">&#160;</td><td class="mdescRight">origin (upper left corner) of pixel data <br  />
 <br /></td></tr>
<tr class="separator:gac575eb19a2c379c1cb6576c2e688ce27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf26e71cf4abe4af61e22773c0fac34f"><td class="memItemLeft" align="right" valign="top"><a id="gacf26e71cf4abe4af61e22773c0fac34f" name="gacf26e71cf4abe4af61e22773c0fac34f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::y</b> = 0</td></tr>
<tr class="memdesc:gacf26e71cf4abe4af61e22773c0fac34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">origin (upper left corner) of pixel data <br  />
 <br /></td></tr>
<tr class="separator:gacf26e71cf4abe4af61e22773c0fac34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e599f27ac90f99a0b8161b6e96ef57"><td class="memItemLeft" align="right" valign="top"><a id="ga06e599f27ac90f99a0b8161b6e96ef57" name="ga06e599f27ac90f99a0b8161b6e96ef57"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::channels</b> = 0</td></tr>
<tr class="memdesc:ga06e599f27ac90f99a0b8161b6e96ef57"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of channels per pixel <br  />
 <br /></td></tr>
<tr class="separator:ga06e599f27ac90f99a0b8161b6e96ef57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d71445767b4f19924c8ae897464f1db"><td class="memItemLeft" align="right" valign="top"><a id="ga1d71445767b4f19924c8ae897464f1db" name="ga1d71445767b4f19924c8ae897464f1db"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::format</b> = 0</td></tr>
<tr class="memdesc:ga1d71445767b4f19924c8ae897464f1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type of pixels AI_TYPE_(BYTE, USHORT, HALF, UINT, FLOAT) <br /></td></tr>
<tr class="separator:ga1d71445767b4f19924c8ae897464f1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc266e10334a880aede25a876ee9ea73"><td class="memItemLeft" align="right" valign="top"><a id="gacc266e10334a880aede25a876ee9ea73" name="gacc266e10334a880aede25a876ee9ea73"></a>
AtArray *&#160;</td><td class="memItemRight" valign="bottom"><b>AtImage::aov_names</b> = nullptr</td></tr>
<tr class="memdesc:gacc266e10334a880aede25a876ee9ea73"><td class="mdescLeft">&#160;</td><td class="mdescRight">AtArray of AtStrings of aov names <br  />
 <br /></td></tr>
<tr class="separator:gacc266e10334a880aede25a876ee9ea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">MIP modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp514ea44fe3c2798ffadd5d247bdbbe82"></a>The MIP mode determines how we sample between mipmap levels. </p>
</td></tr>
<tr class="memitem:gac148c943c29fdb40e89283fb4f50a3da"><td class="memItemLeft" align="right" valign="top"><a id="gac148c943c29fdb40e89283fb4f50a3da" name="gac148c943c29fdb40e89283fb4f50a3da"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a> { <br />
&#160;&#160;<b>AiTxPending</b>
, <b>AiTxError</b>
, <b>AiTxUpdated</b>
, <b>AiTxUpdate_unneeded</b>
, <br />
&#160;&#160;<b>AiTxAborted</b>
<br />
 }</td></tr>
<tr class="memdesc:gac148c943c29fdb40e89283fb4f50a3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of AiMakeTx jobs. <br /></td></tr>
<tr class="separator:gac148c943c29fdb40e89283fb4f50a3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ce4e8fb131172956d1a4902f443894"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gab4ce4e8fb131172956d1a4902f443894">AiTextureParamsSetDefaults</a> (<a class="el" href="structAtTextureParams.html">AtTextureParams</a> &amp;params)</td></tr>
<tr class="memdesc:gab4ce4e8fb131172956d1a4902f443894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="structAtTextureParams.html" title="Structure that holds all of the available texture map look-up options.">AtTextureParams</a> object with default values.  <a href="group__ai__texture.html#gab4ce4e8fb131172956d1a4902f443894">More...</a><br /></td></tr>
<tr class="separator:gab4ce4e8fb131172956d1a4902f443894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadd2a82c3d4f6734d7b808a331d7d57"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtTextureHandle.html">AtTextureHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gacadd2a82c3d4f6734d7b808a331d7d57">AiTextureHandleCreate</a> (const char *filename, <a class="el" href="classAtString.html">AtString</a> texture_color_space=<a class="el" href="classAtString.html">AtString</a>())</td></tr>
<tr class="memdesc:gacadd2a82c3d4f6734d7b808a331d7d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a handle for a given texture filename.  <a href="group__ai__texture.html#gacadd2a82c3d4f6734d7b808a331d7d57">More...</a><br /></td></tr>
<tr class="separator:gacadd2a82c3d4f6734d7b808a331d7d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a803e4ec2fc23a68f096360baadb86"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtRGBA.html">AtRGBA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga51a803e4ec2fc23a68f096360baadb86">AiTextureHandleAccess</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtTextureHandle.html">AtTextureHandle</a> *handle, const <a class="el" href="structAtTextureParams.html">AtTextureParams</a> &amp;params, bool *success=NULL)</td></tr>
<tr class="memdesc:ga51a803e4ec2fc23a68f096360baadb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a texture look-up through a handle.  <a href="group__ai__texture.html#ga51a803e4ec2fc23a68f096360baadb86">More...</a><br /></td></tr>
<tr class="separator:ga51a803e4ec2fc23a68f096360baadb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591a08b36ec756f610c4c162ad2624a6"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga591a08b36ec756f610c4c162ad2624a6">AiTextureHandleDestroy</a> (<a class="el" href="structAtTextureHandle.html">AtTextureHandle</a> *handle)</td></tr>
<tr class="memdesc:ga591a08b36ec756f610c4c162ad2624a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an existing texture handle and its associated resources.  <a href="group__ai__texture.html#ga591a08b36ec756f610c4c162ad2624a6">More...</a><br /></td></tr>
<tr class="separator:ga591a08b36ec756f610c4c162ad2624a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736bd671a0b2c0624f607ac42dfb2ebf"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtRGBA.html">AtRGBA</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga736bd671a0b2c0624f607ac42dfb2ebf">AiTextureAccess</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="classAtString.html">AtString</a> filename, <a class="el" href="classAtString.html">AtString</a> texture_color_space, const <a class="el" href="structAtTextureParams.html">AtTextureParams</a> &amp;params, bool *success=NULL)</td></tr>
<tr class="memdesc:ga736bd671a0b2c0624f607ac42dfb2ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a texture look-up through a filename string.  <a href="group__ai__texture.html#ga736bd671a0b2c0624f607ac42dfb2ebf">More...</a><br /></td></tr>
<tr class="separator:ga736bd671a0b2c0624f607ac42dfb2ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c713d9eb333c1b72493062bf53b233"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gad9c713d9eb333c1b72493062bf53b233">AiTextureLoad</a> (const <a class="el" href="classAtString.html">AtString</a> filename, const bool use_float, const unsigned int miplevel, void *image)</td></tr>
<tr class="memdesc:gad9c713d9eb333c1b72493062bf53b233"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is currently an EXPERIMENTAL function and might be modified in future Arnold releases.  <a href="group__ai__texture.html#gad9c713d9eb333c1b72493062bf53b233">More...</a><br /></td></tr>
<tr class="separator:gad9c713d9eb333c1b72493062bf53b233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd302b0cb28564612b3065c06874a439"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gadd302b0cb28564612b3065c06874a439">AiTextureGetResolution</a> (const char *filename, unsigned int *width, unsigned int *height)</td></tr>
<tr class="memdesc:gadd302b0cb28564612b3065c06874a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query resolution info about a texture.  <a href="group__ai__texture.html#gadd302b0cb28564612b3065c06874a439">More...</a><br /></td></tr>
<tr class="separator:gadd302b0cb28564612b3065c06874a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20058b81e8943fc75757597f67bcf3fc"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga20058b81e8943fc75757597f67bcf3fc">AiTextureGetNumChannels</a> (const char *filename, unsigned int *num_channels)</td></tr>
<tr class="memdesc:ga20058b81e8943fc75757597f67bcf3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of channels in the specified image.  <a href="group__ai__texture.html#ga20058b81e8943fc75757597f67bcf3fc">More...</a><br /></td></tr>
<tr class="separator:ga20058b81e8943fc75757597f67bcf3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b91970166c8ef59498088aaf432048"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gaf6b91970166c8ef59498088aaf432048">AiTextureGetChannelName</a> (const char *filename, unsigned int channel_index)</td></tr>
<tr class="memdesc:gaf6b91970166c8ef59498088aaf432048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the name of a channel in the specified image.  <a href="group__ai__texture.html#gaf6b91970166c8ef59498088aaf432048">More...</a><br /></td></tr>
<tr class="separator:gaf6b91970166c8ef59498088aaf432048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc604db3e929eddbb48a8431a62dee8"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gacdc604db3e929eddbb48a8431a62dee8">AiTextureGetFormat</a> (const char *filename, unsigned int *format)</td></tr>
<tr class="memdesc:gacdc604db3e929eddbb48a8431a62dee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the format of the specified image.  <a href="group__ai__texture.html#gacdc604db3e929eddbb48a8431a62dee8">More...</a><br /></td></tr>
<tr class="separator:gacdc604db3e929eddbb48a8431a62dee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a60ee488d5adaf6c4356efde42e93d2"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga9a60ee488d5adaf6c4356efde42e93d2">AiTextureGetBitDepth</a> (const char *filename, unsigned int *bit_depth)</td></tr>
<tr class="memdesc:ga9a60ee488d5adaf6c4356efde42e93d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the bit depth of the specified image.  <a href="group__ai__texture.html#ga9a60ee488d5adaf6c4356efde42e93d2">More...</a><br /></td></tr>
<tr class="separator:ga9a60ee488d5adaf6c4356efde42e93d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga657fca426f012e47550735917b364f54"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga657fca426f012e47550735917b364f54">AiTextureGetMatrices</a> (const char *filename, <a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;world_to_screen, <a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;world_to_camera)</td></tr>
<tr class="memdesc:ga657fca426f012e47550735917b364f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the matrices associated with the specified texture.  <a href="group__ai__texture.html#ga657fca426f012e47550735917b364f54">More...</a><br /></td></tr>
<tr class="separator:ga657fca426f012e47550735917b364f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820456eec4b40f996d06852c16c3100b"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b">AiTextureInvalidate</a> (const char *filename)</td></tr>
<tr class="memdesc:ga820456eec4b40f996d06852c16c3100b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a specific texture from the cache.  <a href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b">More...</a><br /></td></tr>
<tr class="separator:ga820456eec4b40f996d06852c16c3100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b9c121ce04212a59dae68869afe63e"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gab6b9c121ce04212a59dae68869afe63e">AiTextureGetTxFileName</a> (const char *filename, <a class="el" href="classAtString.html">AtString</a> texture_color_space, <a class="el" href="classAtString.html">AtString</a> render_color_space, const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gab6b9c121ce04212a59dae68869afe63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the TX filename that would be generated from the source texture by auto TX.  <a href="group__ai__texture.html#gab6b9c121ce04212a59dae68869afe63e">More...</a><br /></td></tr>
<tr class="separator:gab6b9c121ce04212a59dae68869afe63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99f519590bb02ba54d86f2bd86c150b"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gab99f519590bb02ba54d86f2bd86c150b">AiTextureGetTxSourceFileName</a> (const char *tx_filename)</td></tr>
<tr class="memdesc:gab99f519590bb02ba54d86f2bd86c150b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return filename of the source texture used to generate a given TX file.  <a href="group__ai__texture.html#gab99f519590bb02ba54d86f2bd86c150b">More...</a><br /></td></tr>
<tr class="separator:gab99f519590bb02ba54d86f2bd86c150b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7bac1ada86dad09a128f651ef5ee78d"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gac7bac1ada86dad09a128f651ef5ee78d">AiTextureAutoTxFlags</a> (const char *texture_file, <a class="el" href="classAtString.html">AtString</a> texture_color_space, const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gac7bac1ada86dad09a128f651ef5ee78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flags passed to the "maketx" command during auto TX generation.  <a href="group__ai__texture.html#gac7bac1ada86dad09a128f651ef5ee78d">More...</a><br /></td></tr>
<tr class="separator:gac7bac1ada86dad09a128f651ef5ee78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae355c553e0936cbc1bdde62958e2f848"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gae355c553e0936cbc1bdde62958e2f848">AiTextureTxFileNeedsUpdate</a> (const char *texture_file, const char *tx_filename, const char *flags)</td></tr>
<tr class="memdesc:gae355c553e0936cbc1bdde62958e2f848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the TX file needs to be regenerated.  <a href="group__ai__texture.html#gae355c553e0936cbc1bdde62958e2f848">More...</a><br /></td></tr>
<tr class="separator:gae355c553e0936cbc1bdde62958e2f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36c2954258162607a382f61b6d6acc1b"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga36c2954258162607a382f61b6d6acc1b">AiReadImage</a> (const char *filename, const uint8_t format, <a class="el" href="structAtImage.html">AtImage</a> &amp;image, AtParamValueMap *params=nullptr)</td></tr>
<tr class="memdesc:ga36c2954258162607a382f61b6d6acc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in the image at <code>filename</code> into <code>image</code> .  <a href="group__ai__texture.html#ga36c2954258162607a382f61b6d6acc1b">More...</a><br /></td></tr>
<tr class="separator:ga36c2954258162607a382f61b6d6acc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d2f8e70f8dfd9c365f637bc196fcab"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga28d2f8e70f8dfd9c365f637bc196fcab">AiWriteImage</a> (const char *filename, const <a class="el" href="structAtImage.html">AtImage</a> &amp;image, AtParamValueMap *params=nullptr)</td></tr>
<tr class="memdesc:ga28d2f8e70f8dfd9c365f637bc196fcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the image in <code>image</code> out to the file specified by <code>filename</code>.  <a href="group__ai__texture.html#ga28d2f8e70f8dfd9c365f637bc196fcab">More...</a><br /></td></tr>
<tr class="separator:ga28d2f8e70f8dfd9c365f637bc196fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2103c338b96b05976199fd8f210764"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga2c2103c338b96b05976199fd8f210764">AiResizeImage</a> (const <a class="el" href="structAtImage.html">AtImage</a> &amp;inImage, <a class="el" href="structAtImage.html">AtImage</a> &amp;outImage, AtParamValueMap *params=nullptr)</td></tr>
<tr class="memdesc:ga2c2103c338b96b05976199fd8f210764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the image in <code>inImage</code> into <code>outImage</code> , overwrites the <code>buffer</code> of <code>outImage</code>.  <a href="group__ai__texture.html#ga2c2103c338b96b05976199fd8f210764">More...</a><br /></td></tr>
<tr class="separator:ga2c2103c338b96b05976199fd8f210764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648cd1c51668159ce775bc34e3cff5cd"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga648cd1c51668159ce775bc34e3cff5cd">AiMakeTx</a> (const char *filename, const char *flags, const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe=NULL)</td></tr>
<tr class="memdesc:ga648cd1c51668159ce775bc34e3cff5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously runs a maketx job in the background.  <a href="group__ai__texture.html#ga648cd1c51668159ce775bc34e3cff5cd">More...</a><br /></td></tr>
<tr class="separator:ga648cd1c51668159ce775bc34e3cff5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b776781ede8493a56661f580106ee1"><td class="memItemLeft" align="right" valign="top">AI_API unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#gae3b776781ede8493a56661f580106ee1">AiMakeTxWaitJob</a> (<a class="el" href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a> *&amp;statuses, const char **&amp;source_files, unsigned int &amp;num_submitted_textures)</td></tr>
<tr class="memdesc:gae3b776781ede8493a56661f580106ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will block until at least one job has been finished.  <a href="group__ai__texture.html#gae3b776781ede8493a56661f580106ee1">More...</a><br /></td></tr>
<tr class="separator:gae3b776781ede8493a56661f580106ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317c166055d20e889d246a901bc3edc9"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__texture.html#ga317c166055d20e889d246a901bc3edc9">AiMakeTxAbort</a> (<a class="el" href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a> *&amp;statuses, const char **&amp;source_files, unsigned int &amp;num_submitted_textures)</td></tr>
<tr class="memdesc:ga317c166055d20e889d246a901bc3edc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort pending maketx jobs.  <a href="group__ai__texture.html#ga317c166055d20e889d246a901bc3edc9">More...</a><br /></td></tr>
<tr class="separator:ga317c166055d20e889d246a901bc3edc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1301eceb73fd099302eb269b867e660"><td class="memItemLeft" align="right" valign="top"><a id="gad1301eceb73fd099302eb269b867e660" name="gad1301eceb73fd099302eb269b867e660"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_MIPMODE_DEFAULT</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad1301eceb73fd099302eb269b867e660"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the default mode (auto-selected) <br  />
 <br /></td></tr>
<tr class="separator:gad1301eceb73fd099302eb269b867e660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c05fd8118767beef1b465f486c1408c"><td class="memItemLeft" align="right" valign="top"><a id="ga7c05fd8118767beef1b465f486c1408c" name="ga7c05fd8118767beef1b465f486c1408c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_MIPMODE_NONE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga7c05fd8118767beef1b465f486c1408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use highest-res mip level only <br  />
 <br /></td></tr>
<tr class="separator:ga7c05fd8118767beef1b465f486c1408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72649ece750826e50cb81c4b69c3c767"><td class="memItemLeft" align="right" valign="top"><a id="ga72649ece750826e50cb81c4b69c3c767" name="ga72649ece750826e50cb81c4b69c3c767"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_MIPMODE_ONE</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga72649ece750826e50cb81c4b69c3c767"><td class="mdescLeft">&#160;</td><td class="mdescRight">just use one mip level (closest) <br  />
 <br /></td></tr>
<tr class="separator:ga72649ece750826e50cb81c4b69c3c767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e759023c17b420e9da9bc984306810"><td class="memItemLeft" align="right" valign="top"><a id="ga19e759023c17b420e9da9bc984306810" name="ga19e759023c17b420e9da9bc984306810"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_MIPMODE_TRILINEAR</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga19e759023c17b420e9da9bc984306810"><td class="mdescLeft">&#160;</td><td class="mdescRight">trilinear blending of two closest mip levels <br  />
 <br /></td></tr>
<tr class="separator:ga19e759023c17b420e9da9bc984306810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad946c7507945675cfb577ddc1d8aa3f1"><td class="memItemLeft" align="right" valign="top"><a id="gad946c7507945675cfb577ddc1d8aa3f1" name="gad946c7507945675cfb577ddc1d8aa3f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_MIPMODE_ANISOTROPIC</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gad946c7507945675cfb577ddc1d8aa3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">use two closest mip levels with anisotropic filtering <br /></td></tr>
<tr class="separator:gad946c7507945675cfb577ddc1d8aa3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Wrapping Modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpd4bab60539cc0678ea1bd9f0ceca6b68"></a>Wrap mode describes what happens when texture coordinates describe a value outside the usual [0,1] range in (s,t)-space where a texture is defined. </p>
</td></tr>
<tr class="memitem:ga028613ac71211cca1e160a29287257ea"><td class="memItemLeft" align="right" valign="top"><a id="ga028613ac71211cca1e160a29287257ea" name="ga028613ac71211cca1e160a29287257ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WRAP_PERIODIC</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga028613ac71211cca1e160a29287257ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">the texture repeats itself outside the [0,1] range <br /></td></tr>
<tr class="separator:ga028613ac71211cca1e160a29287257ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f38c9fb0b5f06d27175fcb6a20d5411"><td class="memItemLeft" align="right" valign="top"><a id="ga8f38c9fb0b5f06d27175fcb6a20d5411" name="ga8f38c9fb0b5f06d27175fcb6a20d5411"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WRAP_BLACK</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga8f38c9fb0b5f06d27175fcb6a20d5411"><td class="mdescLeft">&#160;</td><td class="mdescRight">return black outside the [0,1] range <br  />
 <br /></td></tr>
<tr class="separator:ga8f38c9fb0b5f06d27175fcb6a20d5411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e99fcdf48971ef8bf99fbd49789847"><td class="memItemLeft" align="right" valign="top"><a id="ga02e99fcdf48971ef8bf99fbd49789847" name="ga02e99fcdf48971ef8bf99fbd49789847"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WRAP_CLAMP</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga02e99fcdf48971ef8bf99fbd49789847"><td class="mdescLeft">&#160;</td><td class="mdescRight">clamp to the closest texture edge <br  />
 <br /></td></tr>
<tr class="separator:ga02e99fcdf48971ef8bf99fbd49789847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c93f9a47bdeff25e59faf0c73fcaa28"><td class="memItemLeft" align="right" valign="top"><a id="ga4c93f9a47bdeff25e59faf0c73fcaa28" name="ga4c93f9a47bdeff25e59faf0c73fcaa28"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WRAP_MIRROR</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga4c93f9a47bdeff25e59faf0c73fcaa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror the image across the boundaries <br  />
 <br /></td></tr>
<tr class="separator:ga4c93f9a47bdeff25e59faf0c73fcaa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4947bfb82af9e37ef1571d3eab1eec27"><td class="memItemLeft" align="right" valign="top"><a id="ga4947bfb82af9e37ef1571d3eab1eec27" name="ga4947bfb82af9e37ef1571d3eab1eec27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_WRAP_FILE</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga4947bfb82af9e37ef1571d3eab1eec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">use wrap mode found in the EXR file's metadata <br  />
 <br /></td></tr>
<tr class="separator:ga4947bfb82af9e37ef1571d3eab1eec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Texture Look-Up/Interpolation Modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpc0e92a3a79c0fac22cbf0a8087fd363f"></a>The look-up mode determines how we sample within a mimap level. </p>
</td></tr>
<tr class="memitem:ga91f77e2ec25daf7cdcd1db15cf7df013"><td class="memItemLeft" align="right" valign="top"><a id="ga91f77e2ec25daf7cdcd1db15cf7df013" name="ga91f77e2ec25daf7cdcd1db15cf7df013"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_CLOSEST</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga91f77e2ec25daf7cdcd1db15cf7df013"><td class="mdescLeft">&#160;</td><td class="mdescRight">force the closest texel <br  />
 <br /></td></tr>
<tr class="separator:ga91f77e2ec25daf7cdcd1db15cf7df013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02da9813b48e3c6e75d7afb6d95e8cd"><td class="memItemLeft" align="right" valign="top"><a id="gaf02da9813b48e3c6e75d7afb6d95e8cd" name="gaf02da9813b48e3c6e75d7afb6d95e8cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_BILINEAR</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf02da9813b48e3c6e75d7afb6d95e8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">force bilinear look-up within a mip level <br  />
 <br /></td></tr>
<tr class="separator:gaf02da9813b48e3c6e75d7afb6d95e8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dad299037789e3f8477033aa9f24e3b"><td class="memItemLeft" align="right" valign="top"><a id="ga8dad299037789e3f8477033aa9f24e3b" name="ga8dad299037789e3f8477033aa9f24e3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_BICUBIC</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga8dad299037789e3f8477033aa9f24e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">force bicubic look-up within a mip level <br  />
 <br /></td></tr>
<tr class="separator:ga8dad299037789e3f8477033aa9f24e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19120d7ae9eee8c2178917b3b26f3cd"><td class="memItemLeft" align="right" valign="top"><a id="gae19120d7ae9eee8c2178917b3b26f3cd" name="gae19120d7ae9eee8c2178917b3b26f3cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_TEXTURE_SMART_BICUBIC</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gae19120d7ae9eee8c2178917b3b26f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">bicubic when maxifying, else use bilinear look-up <br /></td></tr>
<tr class="separator:gae19120d7ae9eee8c2178917b3b26f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Texture mapping system. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab4ce4e8fb131172956d1a4902f443894" name="gab4ce4e8fb131172956d1a4902f443894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4ce4e8fb131172956d1a4902f443894">&#9670;&nbsp;</a></span>AiTextureParamsSetDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiTextureParamsSetDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtTextureParams.html">AtTextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="structAtTextureParams.html" title="Structure that holds all of the available texture map look-up options.">AtTextureParams</a> object with default values. </p>
<p >The following are the default values:</p><ul>
<li>filter = <a class="el" href="group__ai__texture.html#gae19120d7ae9eee8c2178917b3b26f3cd">AI_TEXTURE_SMART_BICUBIC</a></li>
<li>mipmap_mode = <a class="el" href="group__ai__texture.html#gad1301eceb73fd099302eb269b867e660">AI_TEXTURE_MIPMODE_DEFAULT</a></li>
<li>mipmap_bias = 0</li>
<li>single_channel = false</li>
<li>fill = 1.0</li>
<li>flip_s/t = false</li>
<li>swap_st = false</li>
<li>scale_s/t = 1.0</li>
<li>wrap_s/t = <a class="el" href="group__ai__texture.html#ga028613ac71211cca1e160a29287257ea">AI_WRAP_PERIODIC</a></li>
<li>width_s/t = 1.0</li>
<li>blur_s/t = 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>A previously allocated <a class="el" href="structAtTextureParams.html" title="Structure that holds all of the available texture map look-up options.">AtTextureParams</a> object that will be filled in with default values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacadd2a82c3d4f6734d7b808a331d7d57" name="gacadd2a82c3d4f6734d7b808a331d7d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacadd2a82c3d4f6734d7b808a331d7d57">&#9670;&nbsp;</a></span>AiTextureHandleCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtTextureHandle.html">AtTextureHandle</a> * AiTextureHandleCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>texture_color_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a handle for a given texture filename. </p>
<p >Make sure to release this resource by calling <a class="el" href="group__ai__texture.html#ga591a08b36ec756f610c4c162ad2624a6" title="Destroy an existing texture handle and its associated resources.">AiTextureHandleDestroy()</a> in the shader's <code>node_finish</code> method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__texture.html#ga591a08b36ec756f610c4c162ad2624a6" title="Destroy an existing texture handle and its associated resources.">AiTextureHandleDestroy()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramname">texture_color_space</td><td>The name of the texture's color space, can be set to "auto" to use a reasonable default, or left empty to skip all transformations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle for the texture map </dd></dl>

</div>
</div>
<a id="ga51a803e4ec2fc23a68f096360baadb86" name="ga51a803e4ec2fc23a68f096360baadb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a803e4ec2fc23a68f096360baadb86">&#9670;&nbsp;</a></span>AiTextureHandleAccess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtRGBA.html">AtRGBA</a> AiTextureHandleAccess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtTextureHandle.html">AtTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtTextureParams.html">AtTextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a texture look-up through a handle. </p>
<p >A texture look-up is performed based on the state of the incoming <a class="el" href="structAtShaderGlobals.html" title="Shader globals data structure.">AtShaderGlobals</a> structure. The look-up is performed for the coordinates <code>sg-&gt;u</code> and <code>sg-&gt;v</code>. The accompanying texture-mapping parameters determine how the look-up is performed, such as the filter/interpolation mode, the mipmap-mode, the wrapping mode, etc...</p>
<p >There are some global options (attached to the 'options' node) which can affect the texturing engine. These are:</p><ul>
<li><code>texture_max_open_files</code> &ndash; The maximum number of open files maintained by the texture cache.</li>
<li><code>texture_max_memory_MB</code> &ndash; The maximum memory used for the texture cache.</li>
<li><code>texture_searchpath</code> &ndash; List of colon-separated optional search paths for locating texture files. Any substring of the form "[FOO]" will replaced by the value of the FOO environment variable.</li>
<li><code>texture_automip</code> &ndash; The texture engine will auto-mipmap un-mipmapped files on the fly.</li>
<li><code>texture_autotile</code> &ndash; The texture engine will auto-tile any un-tiled images on the fly (this parameter contains the tile size).</li>
<li><code>texture_conservative_lookups</code> &ndash; If set to true, then err on the side of blurring as opposed to aliasing.</li>
</ul>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>The current shading state associated with the look-up </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">handle</td><td>The texture handle, created through <a class="el" href="group__ai__texture.html#gacadd2a82c3d4f6734d7b808a331d7d57" title="Create a handle for a given texture filename.">AiTextureHandleCreate()</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>The texture mapping parameters structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">success</td><td>If non-NULL is passed, the boolean pointed to by this pointer will indicate whether texture access was successful or not. Also, if non-NULL, the function assumes that the user takes control of the error handling and it won't print any error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color of the texture look-up. In the case of a problem with a look-up, then the color associated with <code>error_color_bad_texture</code> on the 'options' node is returned. </dd></dl>

</div>
</div>
<a id="ga591a08b36ec756f610c4c162ad2624a6" name="ga591a08b36ec756f610c4c162ad2624a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga591a08b36ec756f610c4c162ad2624a6">&#9670;&nbsp;</a></span>AiTextureHandleDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiTextureHandleDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtTextureHandle.html">AtTextureHandle</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an existing texture handle and its associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga736bd671a0b2c0624f607ac42dfb2ebf" name="ga736bd671a0b2c0624f607ac42dfb2ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736bd671a0b2c0624f607ac42dfb2ebf">&#9670;&nbsp;</a></span>AiTextureAccess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtRGBA.html">AtRGBA</a> AiTextureAccess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>texture_color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtTextureParams.html">AtTextureParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a texture look-up through a filename string. </p>
<p >This call is identical to <a class="el" href="group__ai__texture.html#ga51a803e4ec2fc23a68f096360baadb86" title="Perform a texture look-up through a handle.">AiTextureHandleAccess()</a> but using a filename string instead of a precomputed texture handle. Because the filename string has to be locked, hashed and mapped to a handle internally anyway, this API is less efficient than its handle-based counterpart. In fact we have seen serious performance degradation when rendering with many threads so we recommend using handles instead. The only situation where it <em>may</em> make sense to use filename-based look-ups is when the filename string is not known in advance and needs to be constructed per shading sample (perhaps coming from a shader network).</p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>The current shading state associated with the look-up </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture map </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">texture_color_space</td><td>The color space of the texture map. Can be set to "auto" to use a reasonable default, or left empty to skip all transformations. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>The texture mapping parameters structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">success</td><td>If non-NULL is passed, the boolean pointed to by this pointer will indicate whether texture access was successful or not. Also, if non-NULL, the function assumes that the user takes control of the error handling and it won't print any error message in the log file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color of the texture look-up. In the case of a problem with a look-up, then the color associated with <code>error_color_bad_texture</code> on the 'options' node is returned. </dd></dl>

</div>
</div>
<a id="gad9c713d9eb333c1b72493062bf53b233" name="gad9c713d9eb333c1b72493062bf53b233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c713d9eb333c1b72493062bf53b233">&#9670;&nbsp;</a></span>AiTextureLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_float</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>miplevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is currently an EXPERIMENTAL function and might be modified in future Arnold releases. </p>
<p >If you use this, your code might cease to compile with future versions of Arnold should we remove/modify this function.</p>
<p >Do a texture lookup over an entire texture named <code>filename</code>. <a class="el" href="group__ai__texture.html#ga736bd671a0b2c0624f607ac42dfb2ebf" title="Perform a texture look-up through a filename string.">AiTextureAccess()</a> / <a class="el" href="group__ai__texture.html#ga51a803e4ec2fc23a68f096360baadb86" title="Perform a texture look-up through a handle.">AiTextureHandleAccess()</a> should instead be used inside of shader_evaluate. While this function should be used when the entire texture needs to be read in and works even outside of <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a> blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture map </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">use_float</td><td><code>true</code> if image is of type <code>float*</code>, and false if it is of type <code>unsigned char*</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">miplevel</td><td>The mipmap level to read, with 0 being the highest resolution. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">image</td><td>Resulting image data. Underlying data is allocated by caller. Caller should make sure it has the proper number of channels and resolution. These can be found using <code><a class="el" href="group__ai__texture.html#ga20058b81e8943fc75757597f67bcf3fc" title="Query the number of channels in the specified image.">AiTextureGetNumChannels()</a></code> and <code><a class="el" href="group__ai__texture.html#gadd302b0cb28564612b3065c06874a439" title="Query resolution info about a texture.">AiTextureGetResolution()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lookup was successful. </dd></dl>

</div>
</div>
<a id="gadd302b0cb28564612b3065c06874a439" name="gadd302b0cb28564612b3065c06874a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd302b0cb28564612b3065c06874a439">&#9670;&nbsp;</a></span>AiTextureGetResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureGetResolution </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query resolution info about a texture. </p>
<p >This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a></p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">width</td><td>The width of the texture is written here </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>The height of the texture is written here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the resolution was successfully queried. </dd></dl>

</div>
</div>
<a id="ga20058b81e8943fc75757597f67bcf3fc" name="ga20058b81e8943fc75757597f67bcf3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20058b81e8943fc75757597f67bcf3fc">&#9670;&nbsp;</a></span>AiTextureGetNumChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureGetNumChannels </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>num_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of channels in the specified image. </p>
<p >This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a></p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_channels</td><td>The number of channels in the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the number of channels were successfully queried. </dd></dl>

</div>
</div>
<a id="gaf6b91970166c8ef59498088aaf432048" name="gaf6b91970166c8ef59498088aaf432048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b91970166c8ef59498088aaf432048">&#9670;&nbsp;</a></span>AiTextureGetChannelName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiTextureGetChannelName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the name of a channel in the specified image. </p>
<p >This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a></p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramname">channel_index</td><td>The index of the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the channel doesn't exist, otherwise the name as a string. </dd></dl>

</div>
</div>
<a id="gacdc604db3e929eddbb48a8431a62dee8" name="gacdc604db3e929eddbb48a8431a62dee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc604db3e929eddbb48a8431a62dee8">&#9670;&nbsp;</a></span>AiTextureGetFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureGetFormat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the format of the specified image. </p>
<p >This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a></p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format</td><td>The pixel format of the image, one of <code>AI_TYPE_UINT</code>, <code>AI_TYPE_INT</code> or <code>AI_TYPE_FLOAT</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the format was successfully queried. </dd></dl>

</div>
</div>
<a id="ga9a60ee488d5adaf6c4356efde42e93d2" name="ga9a60ee488d5adaf6c4356efde42e93d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a60ee488d5adaf6c4356efde42e93d2">&#9670;&nbsp;</a></span>AiTextureGetBitDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureGetBitDepth </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>bit_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the bit depth of the specified image. </p>
<p >This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a></p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bit_depth</td><td>The bit depth of the pixels in the image. For example, a JPEG image will return a bit depth of 8 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the bit depth was successfully queried. </dd></dl>

</div>
</div>
<a id="ga657fca426f012e47550735917b364f54" name="ga657fca426f012e47550735917b364f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga657fca426f012e47550735917b364f54">&#9670;&nbsp;</a></span>AiTextureGetMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureGetMatrices </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>world_to_screen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtMatrix.html">AtMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>world_to_camera</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the matrices associated with the specified texture. </p>
<p >This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a></p>
<p >The texture file is kept open after this call in order to speed future queries. Use <a class="el" href="group__ai__texture.html#ga820456eec4b40f996d06852c16c3100b" title="Invalidate a specific texture from the cache.">AiTextureInvalidate()</a> if the file needs to be closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">world_to_screen</td><td>World-to-screen matrix describing the full projection of the 3D view onto a [-1...1]x[-1...1] 2D domain. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">world_to_camera</td><td>World-to-camera matrix describing the camera position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the matrices were successfully queried. </dd></dl>

</div>
</div>
<a id="ga820456eec4b40f996d06852c16c3100b" name="ga820456eec4b40f996d06852c16c3100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga820456eec4b40f996d06852c16c3100b">&#9670;&nbsp;</a></span>AiTextureInvalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiTextureInvalidate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate a specific texture from the cache. </p>
<p >This will invalidate all associated texture data in the cache and close the file. This can be called from outside <a class="el" href="group__ai__render.html#ga78b907622403b0e19ebc9ee41985364a" title="Marks the beginning of a block which uses the Arnold rendering interface API.">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API.">AiEnd()</a>, but it is not allowed while a universe is being rendered, in which case it will emit a warning and do nothing. </p>

</div>
</div>
<a id="gab6b9c121ce04212a59dae68869afe63e" name="gab6b9c121ce04212a59dae68869afe63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b9c121ce04212a59dae68869afe63e">&#9670;&nbsp;</a></span>AiTextureGetTxFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="classAtString.html">AtString</a> AiTextureGetTxFileName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>texture_color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>render_color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the TX filename that would be generated from the source texture by auto TX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the texture </td></tr>
    <tr><td class="paramname">texture_color_space</td><td>Color space used by the texture </td></tr>
    <tr><td class="paramname">render_color_space</td><td>Color space used as target for rendering </td></tr>
    <tr><td class="paramname">universe</td><td>Universe containing a color manager used for color conversion (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the TX file that would be generated </dd></dl>

</div>
</div>
<a id="gab99f519590bb02ba54d86f2bd86c150b" name="gab99f519590bb02ba54d86f2bd86c150b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99f519590bb02ba54d86f2bd86c150b">&#9670;&nbsp;</a></span>AiTextureGetTxSourceFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="classAtString.html">AtString</a> AiTextureGetTxSourceFileName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tx_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return filename of the source texture used to generate a given TX file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_filename</td><td>The name of the TX file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the original source texture, empty if there was any error </dd></dl>

</div>
</div>
<a id="gac7bac1ada86dad09a128f651ef5ee78d" name="gac7bac1ada86dad09a128f651ef5ee78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7bac1ada86dad09a128f651ef5ee78d">&#9670;&nbsp;</a></span>AiTextureAutoTxFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="classAtString.html">AtString</a> AiTextureAutoTxFlags </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>texture_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>texture_color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the flags passed to the "maketx" command during auto TX generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture_file</td><td>The name of the texture </td></tr>
    <tr><td class="paramname">texture_color_space</td><td>Color space used by the texture </td></tr>
    <tr><td class="paramname">universe</td><td>Universe containing the color manager that will be used for color conversion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string with all flags passed to maketx </dd></dl>

</div>
</div>
<a id="gae355c553e0936cbc1bdde62958e2f848" name="gae355c553e0936cbc1bdde62958e2f848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae355c553e0936cbc1bdde62958e2f848">&#9670;&nbsp;</a></span>AiTextureTxFileNeedsUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTextureTxFileNeedsUpdate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>texture_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tx_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the TX file needs to be regenerated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture_file</td><td>The name of the source texture file </td></tr>
    <tr><td class="paramname">tx_filename</td><td>The name of the target TX file </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to be used for TX file generation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the TX file needs to be regenerated. False otherwise </dd></dl>

</div>
</div>
<a id="ga36c2954258162607a382f61b6d6acc1b" name="ga36c2954258162607a382f61b6d6acc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36c2954258162607a382f61b6d6acc1b">&#9670;&nbsp;</a></span>AiReadImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiReadImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtImage.html">AtImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in the image at <code>filename</code> into <code>image</code> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>Name of the image to be loaded </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">format</td><td>Pixel format of the image, one of <code>AI_TYPE_BYTE</code>, <code>AI_TYPE_USHORT</code>, <code>AI_TYPE_HALF</code>, <code>AI_TYPE_UINT</code> or <code>AI_TYPE_FLOAT</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">image</td><td>Resulting image data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>optional parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image was loaded successfully. </dd></dl>

</div>
</div>
<a id="ga28d2f8e70f8dfd9c365f637bc196fcab" name="ga28d2f8e70f8dfd9c365f637bc196fcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d2f8e70f8dfd9c365f637bc196fcab">&#9670;&nbsp;</a></span>AiWriteImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiWriteImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtImage.html">AtImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the image in <code>image</code> out to the file specified by <code>filename</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to be writen to </td></tr>
    <tr><td class="paramname">image</td><td>The image to be writen out </td></tr>
    <tr><td class="paramname">params</td><td>optional parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image was writen to the file. </dd></dl>

</div>
</div>
<a id="ga2c2103c338b96b05976199fd8f210764" name="ga2c2103c338b96b05976199fd8f210764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2103c338b96b05976199fd8f210764">&#9670;&nbsp;</a></span>AiResizeImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiResizeImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtImage.html">AtImage</a> &amp;&#160;</td>
          <td class="paramname"><em>inImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtImage.html">AtImage</a> &amp;&#160;</td>
          <td class="paramname"><em>outImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the image in <code>inImage</code> into <code>outImage</code> , overwrites the <code>buffer</code> of <code>outImage</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">inImage</td><td>Image to be resized </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outImage</td><td>Resulting resized image. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>optional parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the resize was successful. </dd></dl>

</div>
</div>
<a id="ga648cd1c51668159ce775bc34e3cff5cd" name="ga648cd1c51668159ce775bc34e3cff5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648cd1c51668159ce775bc34e3cff5cd">&#9670;&nbsp;</a></span>AiMakeTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMakeTx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously runs a maketx job in the background. </p>
<p >Both AiMakeTx and our supplied maketx binary will already include the flags: " --opaque-detect --constant-color-detect --monochrome-detect --fixnan box3 --oiio --attrib tiff:half 1"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The original input texture, such as "my_texture.png". This can also be an empty string and instead the filename is included as part of the flags. </td></tr>
    <tr><td class="paramname">flags</td><td>The remaining flags one would normally pass into maketx. For instance, it could be: "--unpremult --oiio -u" </td></tr>
    <tr><td class="paramname">universe</td><td>Universe that contains the color manager to be used (null for default universe)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__ai__texture.html#ga648cd1c51668159ce775bc34e3cff5cd" title="Asynchronously runs a maketx job in the background.">AiMakeTx()</a>, <a class="el" href="group__ai__texture.html#gae3b776781ede8493a56661f580106ee1" title="This function will block until at least one job has been finished.">AiMakeTxWaitJob()</a>, and <a class="el" href="group__ai__texture.html#ga317c166055d20e889d246a901bc3edc9" title="Abort pending maketx jobs.">AiMakeTxAbort()</a> are not thread safe and should not be called from multiple threads at the same time </p>

</div>
</div>
<a id="gae3b776781ede8493a56661f580106ee1" name="gae3b776781ede8493a56661f580106ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3b776781ede8493a56661f580106ee1">&#9670;&nbsp;</a></span>AiMakeTxWaitJob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API unsigned AiMakeTxWaitJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a> *&amp;&#160;</td>
          <td class="paramname"><em>statuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&amp;&#160;</td>
          <td class="paramname"><em>source_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>num_submitted_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will block until at least one job has been finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statuses</td><td>Will end up containing an array of AtMakeTxStatus. </td></tr>
    <tr><td class="paramname">source_files</td><td>An array containing the source filenames that have been submitted to Arnold. </td></tr>
    <tr><td class="paramname">num_submitted_textures</td><td>The size of the above arrays that Arnold used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many textures still need to be generated. If all the textures have been processed, it will return 0. Example usage: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; num_textures; ++i)</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_function" href="group__ai__texture.html#ga648cd1c51668159ce775bc34e3cff5cd">AiMakeTx</a>(textures[i], <span class="stringliteral">&quot; -u&quot;</span>);</div>
<div class="line">   printf(<span class="stringliteral">&quot;submitted %d of %d textures for updating\n&quot;</span>, i, num_textures);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_enumeration" href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a> *status;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>** source_filenames;</div>
<div class="line"><span class="keywordtype">unsigned</span> num_submitted_textures;</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keywordtype">int</span> num_jobs_left = <a class="code hl_function" href="group__ai__texture.html#gae3b776781ede8493a56661f580106ee1">AiMakeTxWaitJob</a>(status, source_filenames, num_submitted_textures))</div>
<div class="line">   <a class="code hl_function" href="group__ai__msg.html#ga92ec2c84a8b0b88c01e106071729e790">AiMsgInfo</a>(<span class="stringliteral">&quot;%d of %u texture updates remaining.&quot;</span>, num_jobs_left, num_submitted_textures);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; num_submitted_textures; ++i)</div>
<div class="line">   <span class="keywordflow">if</span> (status[i] == AiTxUpdated)</div>
<div class="line">      printf(<span class="stringliteral">&quot;%s was updated\n&quot;</span>, source_filenames[i]);</div>
<div class="line">   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status[i] == AiTxError)</div>
<div class="line">      printf(<span class="stringliteral">&quot;%s could not be updated\n&quot;</span>, source_filenames[i]);</div>
<div class="line">   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status[i] == AiTxUpdate_unneeded)</div>
<div class="line">      printf(<span class="stringliteral">&quot;%s did not need to be updated\n&quot;</span>, source_filenames[i]);</div>
<div class="line">   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status[i] == AiTxAborted)</div>
<div class="line">      printf(<span class="stringliteral">&quot;%s was aborted\n&quot;</span>, source_filenames[i]);</div>
<div class="ttc" id="agroup__ai__msg_html_ga92ec2c84a8b0b88c01e106071729e790"><div class="ttname"><a href="group__ai__msg.html#ga92ec2c84a8b0b88c01e106071729e790">AiMsgInfo</a></div><div class="ttdeci">AI_API void AiMsgInfo(const char *format,...)</div><div class="ttdoc">Send an information message to the log.</div><div class="ttdef"><b>Definition:</b> ai_msg.cpp:201</div></div>
<div class="ttc" id="agroup__ai__texture_html_ga648cd1c51668159ce775bc34e3cff5cd"><div class="ttname"><a href="group__ai__texture.html#ga648cd1c51668159ce775bc34e3cff5cd">AiMakeTx</a></div><div class="ttdeci">AI_API void AiMakeTx(const char *filename, const char *flags, const AtUniverse *universe=NULL)</div><div class="ttdoc">Asynchronously runs a maketx job in the background.</div><div class="ttdef"><b>Definition:</b> ai_maketx.cpp:54</div></div>
<div class="ttc" id="agroup__ai__texture_html_gac148c943c29fdb40e89283fb4f50a3da"><div class="ttname"><a href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a></div><div class="ttdeci">AtMakeTxStatus</div><div class="ttdoc">Status of AiMakeTx jobs.</div><div class="ttdef"><b>Definition:</b> ai_texture.h:151</div></div>
<div class="ttc" id="agroup__ai__texture_html_gae3b776781ede8493a56661f580106ee1"><div class="ttname"><a href="group__ai__texture.html#gae3b776781ede8493a56661f580106ee1">AiMakeTxWaitJob</a></div><div class="ttdeci">AI_API unsigned AiMakeTxWaitJob(AtMakeTxStatus *&amp;statuses, const char **&amp;source_files, unsigned int &amp;num_submitted_textures)</div><div class="ttdoc">This function will block until at least one job has been finished.</div><div class="ttdef"><b>Definition:</b> ai_maketx.cpp:159</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga317c166055d20e889d246a901bc3edc9" name="ga317c166055d20e889d246a901bc3edc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317c166055d20e889d246a901bc3edc9">&#9670;&nbsp;</a></span>AiMakeTxAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMakeTxAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__texture.html#gac148c943c29fdb40e89283fb4f50a3da">AtMakeTxStatus</a> *&amp;&#160;</td>
          <td class="paramname"><em>statuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&amp;&#160;</td>
          <td class="paramname"><em>source_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>num_submitted_textures</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort pending maketx jobs. </p>
<p >It's possible that currently running maketx jobs (as opposed to jobs that haven't yet been started and are waiting to be run) will not be aborted and instead might finish sometime after <a class="el" href="group__ai__texture.html#ga317c166055d20e889d246a901bc3edc9" title="Abort pending maketx jobs.">AiMakeTxAbort()</a> has already returned. The next call to <a class="el" href="group__ai__texture.html#ga648cd1c51668159ce775bc34e3cff5cd" title="Asynchronously runs a maketx job in the background.">AiMakeTx()</a> will block until all preexisting jobs have completed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab0c2ee5a526fe7e37c671f590d06a640" name="gab0c2ee5a526fe7e37c671f590d06a640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0c2ee5a526fe7e37c671f590d06a640">&#9670;&nbsp;</a></span>fill</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AtTextureParams::fill</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>value for nonexistent channels (e.g. </p>
<p >alpha) <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
