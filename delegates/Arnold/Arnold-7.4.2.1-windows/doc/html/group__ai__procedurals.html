<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Procedural API</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of custom Arnold procedural nodes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtProceduralNodeMethods.html">AtProceduralNodeMethods</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa696e941da4d2b5808be31441cb23711"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#gaa696e941da4d2b5808be31441cb23711">AI_PROCEDURAL_NODE_EXPORT_METHODS</a>(tag)</td></tr>
<tr class="memdesc:gaa696e941da4d2b5808be31441cb23711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural node methods exporter.  <a href="group__ai__procedurals.html#gaa696e941da4d2b5808be31441cb23711">More...</a><br /></td></tr>
<tr class="separator:gaa696e941da4d2b5808be31441cb23711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6171443a5d45517e4abb1eef826847"><td class="memItemLeft" align="right" valign="top"><a id="gafa6171443a5d45517e4abb1eef826847" name="gafa6171443a5d45517e4abb1eef826847"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>procedural_init</b>&#160;&#160;&#160;static int ProceduralInit(<a class="el" href="structAtNode.html">AtNode</a>* node, void** user_ptr)</td></tr>
<tr class="separator:gafa6171443a5d45517e4abb1eef826847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71d67be09953a2ec4d4df88e1120ff0"><td class="memItemLeft" align="right" valign="top"><a id="gae71d67be09953a2ec4d4df88e1120ff0" name="gae71d67be09953a2ec4d4df88e1120ff0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>procedural_cleanup</b>&#160;&#160;&#160;static int ProceduralCleanup(const <a class="el" href="structAtNode.html">AtNode</a>* node, void* user_ptr)</td></tr>
<tr class="separator:gae71d67be09953a2ec4d4df88e1120ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa1c05ed6fd5788e9b50cffd570cf8d"><td class="memItemLeft" align="right" valign="top"><a id="ga7fa1c05ed6fd5788e9b50cffd570cf8d" name="ga7fa1c05ed6fd5788e9b50cffd570cf8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>procedural_num_nodes</b>&#160;&#160;&#160;static int ProceduralNumNodes(const <a class="el" href="structAtNode.html">AtNode</a>* node, void* user_ptr)</td></tr>
<tr class="separator:ga7fa1c05ed6fd5788e9b50cffd570cf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad387c3863ada0e672f1f92bfdce8e94e"><td class="memItemLeft" align="right" valign="top"><a id="gad387c3863ada0e672f1f92bfdce8e94e" name="gad387c3863ada0e672f1f92bfdce8e94e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>procedural_get_node</b>&#160;&#160;&#160;static <a class="el" href="structAtNode.html">AtNode</a>* ProceduralGetNode(const <a class="el" href="structAtNode.html">AtNode</a>* node, void* user_ptr, int i)</td></tr>
<tr class="separator:gad387c3863ada0e672f1f92bfdce8e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e2af7b626c4da7d32f706a96f6ea546"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga2e2af7b626c4da7d32f706a96f6ea546">procedural_update</a></td></tr>
<tr class="separator:ga2e2af7b626c4da7d32f706a96f6ea546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5eeb3691d940709550e05ee1663fec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga4f5eeb3691d940709550e05ee1663fec">procedural_finish</a></td></tr>
<tr class="separator:ga4f5eeb3691d940709550e05ee1663fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f238c07037221eebb6fffb7e6f8c6ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga2f238c07037221eebb6fffb7e6f8c6ec">procedural_viewport</a></td></tr>
<tr class="separator:ga2f238c07037221eebb6fffb7e6f8c6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gada0f51d3c111b02fef3cf1a9c9e6d02a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a>) (<a class="el" href="structAtNode.html">AtNode</a> *node, void **user_ptr)</td></tr>
<tr class="memdesc:gada0f51d3c111b02fef3cf1a9c9e6d02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural init method.  <a href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">More...</a><br /></td></tr>
<tr class="separator:gada0f51d3c111b02fef3cf1a9c9e6d02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga241c14baad4c5003b51f0195b2debcc0"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga241c14baad4c5003b51f0195b2debcc0">AtProcCleanup</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, void *user_ptr)</td></tr>
<tr class="memdesc:ga241c14baad4c5003b51f0195b2debcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural cleanup method.  <a href="group__ai__procedurals.html#ga241c14baad4c5003b51f0195b2debcc0">More...</a><br /></td></tr>
<tr class="separator:ga241c14baad4c5003b51f0195b2debcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16889bd521791dc3d6316d4a3faa4d00"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">AtProcNumNodes</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, void *user_ptr)</td></tr>
<tr class="memdesc:ga16889bd521791dc3d6316d4a3faa4d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural node count method.  <a href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">More...</a><br /></td></tr>
<tr class="separator:ga16889bd521791dc3d6316d4a3faa4d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9e2a6273cd6c5485eb6ff436eeb558"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structAtNode.html">AtNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga5c9e2a6273cd6c5485eb6ff436eeb558">AtProcGetNode</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, void *user_ptr, int i)</td></tr>
<tr class="memdesc:ga5c9e2a6273cd6c5485eb6ff436eeb558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural node fetching method.  <a href="group__ai__procedurals.html#ga5c9e2a6273cd6c5485eb6ff436eeb558">More...</a><br /></td></tr>
<tr class="separator:ga5c9e2a6273cd6c5485eb6ff436eeb558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492b7b10d002ae8aecdae514557bd667"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga492b7b10d002ae8aecdae514557bd667">AtProcViewport</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, <a class="el" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a> mode, const AtParamValueMap *params)</td></tr>
<tr class="memdesc:ga492b7b10d002ae8aecdae514557bd667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural viewport representation method.  <a href="group__ai__procedurals.html#ga492b7b10d002ae8aecdae514557bd667">More...</a><br /></td></tr>
<tr class="separator:ga492b7b10d002ae8aecdae514557bd667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5022dfa4b2b93e6b8f36d9ac1bdd29"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga4c5022dfa4b2b93e6b8f36d9ac1bdd29">AtProcFuncPtr</a>) (<a class="el" href="structAtProceduralNodeMethods.html">AtProceduralNodeMethods</a> *methods)</td></tr>
<tr class="memdesc:ga4c5022dfa4b2b93e6b8f36d9ac1bdd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural function pointer entry-point symbol.  <a href="group__ai__procedurals.html#ga4c5022dfa4b2b93e6b8f36d9ac1bdd29">More...</a><br /></td></tr>
<tr class="separator:ga4c5022dfa4b2b93e6b8f36d9ac1bdd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1fbdf789b2f70dfe7815b008191c2c57"><td class="memItemLeft" align="right" valign="top"><a id="ga1fbdf789b2f70dfe7815b008191c2c57" name="ga1fbdf789b2f70dfe7815b008191c2c57"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a> { <b>AI_PROC_BOXES</b> = 0
, <b>AI_PROC_POINTS</b>
, <b>AI_PROC_POLYGONS</b>
 }</td></tr>
<tr class="memdesc:ga1fbdf789b2f70dfe7815b008191c2c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum with the different modes available for a procedural viewport representation. <br /></td></tr>
<tr class="separator:ga1fbdf789b2f70dfe7815b008191c2c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7ec78c1412dc4cefd5bf6de70663f44b"><td class="memItemLeft" align="right" valign="top">AI_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga7ec78c1412dc4cefd5bf6de70663f44b">AiProceduralViewport</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, <a class="el" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a> mode=AI_PROC_BOXES, const AtParamValueMap *params=NULL)</td></tr>
<tr class="memdesc:ga7ec78c1412dc4cefd5bf6de70663f44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural viewport representation method.  <a href="group__ai__procedurals.html#ga7ec78c1412dc4cefd5bf6de70663f44b">More...</a><br /></td></tr>
<tr class="separator:ga7ec78c1412dc4cefd5bf6de70663f44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad340bccafac60d936f0a156a959b7e"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga0ad340bccafac60d936f0a156a959b7e">AiProceduralExpand</a> (<a class="el" href="structAtNode.html">AtNode</a> *proc_node, const AtParamValueMap *params=NULL)</td></tr>
<tr class="memdesc:ga0ad340bccafac60d936f0a156a959b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure a procedural node is ready to be used for rendering.  <a href="group__ai__procedurals.html#ga0ad340bccafac60d936f0a156a959b7e">More...</a><br /></td></tr>
<tr class="separator:ga0ad340bccafac60d936f0a156a959b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9f01935ad215cdd02d3586eb8341436c"><td class="memItemLeft" align="right" valign="top"><a id="ga9f01935ad215cdd02d3586eb8341436c" name="ga9f01935ad215cdd02d3586eb8341436c"></a>
<a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtProceduralNodeMethods::Init</b></td></tr>
<tr class="memdesc:ga9f01935ad215cdd02d3586eb8341436c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called before expanding the procedural. <br /></td></tr>
<tr class="separator:ga9f01935ad215cdd02d3586eb8341436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga342eb6f599ba8d57d675ff417c4ba1fc"><td class="memItemLeft" align="right" valign="top"><a id="ga342eb6f599ba8d57d675ff417c4ba1fc" name="ga342eb6f599ba8d57d675ff417c4ba1fc"></a>
<a class="el" href="group__ai__procedurals.html#ga241c14baad4c5003b51f0195b2debcc0">AtProcCleanup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtProceduralNodeMethods::Cleanup</b></td></tr>
<tr class="memdesc:ga342eb6f599ba8d57d675ff417c4ba1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called last and should clean up any (temporary) memory used by the procedural. <br /></td></tr>
<tr class="separator:ga342eb6f599ba8d57d675ff417c4ba1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a49a53ef30c8c50a99410b19e144ea"><td class="memItemLeft" align="right" valign="top"><a id="gac0a49a53ef30c8c50a99410b19e144ea" name="gac0a49a53ef30c8c50a99410b19e144ea"></a>
<a class="el" href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">AtProcNumNodes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtProceduralNodeMethods::NumNodes</b></td></tr>
<tr class="memdesc:gac0a49a53ef30c8c50a99410b19e144ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called to find out how many nodes this procedural will generate. <br /></td></tr>
<tr class="separator:gac0a49a53ef30c8c50a99410b19e144ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d0898ad089428204f4a26abff17957"><td class="memItemLeft" align="right" valign="top"><a id="gaf1d0898ad089428204f4a26abff17957" name="gaf1d0898ad089428204f4a26abff17957"></a>
<a class="el" href="group__ai__procedurals.html#ga5c9e2a6273cd6c5485eb6ff436eeb558">AtProcGetNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtProceduralNodeMethods::GetNode</b></td></tr>
<tr class="memdesc:gaf1d0898ad089428204f4a26abff17957"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called NumNodes times, once for each node the procedural creates. <br /></td></tr>
<tr class="separator:gaf1d0898ad089428204f4a26abff17957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efebabbe5e1c87dfb1d38d72901fd7c"><td class="memItemLeft" align="right" valign="top"><a id="ga0efebabbe5e1c87dfb1d38d72901fd7c" name="ga0efebabbe5e1c87dfb1d38d72901fd7c"></a>
<a class="el" href="group__ai__procedurals.html#ga492b7b10d002ae8aecdae514557bd667">AtProcViewport</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtProceduralNodeMethods::ProceduralViewport</b></td></tr>
<tr class="memdesc:ga0efebabbe5e1c87dfb1d38d72901fd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called to get a viewport representation of the given procedural node. <br /></td></tr>
<tr class="separator:ga0efebabbe5e1c87dfb1d38d72901fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Implementation of custom Arnold procedural nodes. </p>
<p >This API is used to create geometry procedurally at render time, rather than upfront. This is accomplished by providing the renderer some callback functions which are called during scene initialization, before rendering. Procedural nodes should only contain geometry, shaders and lights.</p>
<p >Note that procedurals can recursively create other procedural nodes.</p>
<p >Procedurals are loaded during the pre-render initialization process. This process runs single-threaded by default, but setting the metadata "parallel_init" to true will allow multiple instances of the same procedural to be initialized in parallel when "options.parallel_node_init" is true (the default)</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a></div>
<div class="line">{</div>
<div class="line"> ...</div>
<div class="line">   <span class="comment">// Set procedural to run in parallel</span></div>
<div class="line">   AiMetaDataSetBool(nentry, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;parallel_init&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"> ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ai__nodes_html_gadec5d9ecd55d964c1a30151fffa8e575"><div class="ttname"><a href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a></div><div class="ttdeci">#define node_parameters</div><div class="ttdoc">Parameter declaration method.</div><div class="ttdef"><b>Definition:</b> ai_nodes.h:72</div></div>
</div><!-- fragment --><p >So, in order to benefit from this parallel initialization, it is necessary that the code in a procedural node is properly designed to be re-entrant. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa696e941da4d2b5808be31441cb23711" name="gaa696e941da4d2b5808be31441cb23711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa696e941da4d2b5808be31441cb23711">&#9670;&nbsp;</a></span>AI_PROCEDURAL_NODE_EXPORT_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_PROCEDURAL_NODE_EXPORT_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">AI_INSTANCE_COMMON_SHAPE_METHODS                \</div>
<div class="line">procedural_init;                                \</div>
<div class="line">procedural_cleanup;                             \</div>
<div class="line">procedural_num_nodes;                           \</div>
<div class="line">procedural_get_node;                            \</div>
<div class="line">static <a class="code hl_struct" href="structAtProceduralNodeMethods.html">AtProceduralNodeMethods</a> ai_proc_mtds = { \</div>
<div class="line">   ProceduralInit,                              \</div>
<div class="line">   ProceduralCleanup,                           \</div>
<div class="line">   ProceduralNumNodes,                          \</div>
<div class="line">   ProceduralGetNode,                           \</div>
<div class="line">   NULL,                                        \</div>
<div class="line">};                                              \</div>
<div class="line">static <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_mtds = {           \</div>
<div class="line">   &amp;ai_common_mtds,                             \</div>
<div class="line">   &amp;ai_proc_mtds                                \</div>
<div class="line">};                                              \</div>
<div class="line">const <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a>* tag = &amp;ai_node_mtds;</div>
<div class="ttc" id="astructAtNodeMethods_html"><div class="ttname"><a href="structAtNodeMethods.html">AtNodeMethods</a></div><div class="ttdoc">Node methods.</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:86</div></div>
<div class="ttc" id="astructAtProceduralNodeMethods_html"><div class="ttname"><a href="structAtProceduralNodeMethods.html">AtProceduralNodeMethods</a></div><div class="ttdef"><b>Definition:</b> ai_procedural.h:167</div></div>
</div><!-- fragment -->
<p>Procedural node methods exporter. </p>

</div>
</div>
<a id="ga2e2af7b626c4da7d32f706a96f6ea546" name="ga2e2af7b626c4da7d32f706a96f6ea546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e2af7b626c4da7d32f706a96f6ea546">&#9670;&nbsp;</a></span>procedural_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define procedural_update</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> Update(AtRenderSession* render_session, <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node); \</div>
<div class="line">AI_OPTIONAL_METHOD_INSTALL(ai_common_mtds, Update)                 \</div>
<div class="line">static <span class="keywordtype">void</span> Update(AtRenderSession* render_session, <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node)</div>
<div class="ttc" id="astructAtNode_html"><div class="ttname"><a href="structAtNode.html">AtNode</a></div><div class="ttdoc">This represents a node in Arnold.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4f5eeb3691d940709550e05ee1663fec" name="ga4f5eeb3691d940709550e05ee1663fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5eeb3691d940709550e05ee1663fec">&#9670;&nbsp;</a></span>procedural_finish</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define procedural_finish</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> Finish(<a class="code hl_struct" href="structAtNode.html">AtNode</a>* node);                  \</div>
<div class="line">AI_OPTIONAL_METHOD_INSTALL(ai_common_mtds, Finish) \</div>
<div class="line">static <span class="keywordtype">void</span> Finish(<a class="code hl_struct" href="structAtNode.html">AtNode</a>* node)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2f238c07037221eebb6fffb7e6f8c6ec" name="ga2f238c07037221eebb6fffb7e6f8c6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f238c07037221eebb6fffb7e6f8c6ec">&#9670;&nbsp;</a></span>procedural_viewport</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define procedural_viewport</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> ProceduralViewport(<span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node, <a class="code hl_struct" href="structAtUniverse.html">AtUniverse</a>* universe, <a class="code hl_enumeration" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a> mode, <span class="keyword">const</span> AtParamValueMap* params); \</div>
<div class="line">AI_OPTIONAL_METHOD_INSTALL(ai_proc_mtds, ProceduralViewport) \</div>
<div class="line">static <span class="keywordtype">int</span> ProceduralViewport(<span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node, <a class="code hl_struct" href="structAtUniverse.html">AtUniverse</a>* universe, <a class="code hl_enumeration" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a> mode, <span class="keyword">const</span> AtParamValueMap* params)</div>
<div class="ttc" id="agroup__ai__procedurals_html_ga1fbdf789b2f70dfe7815b008191c2c57"><div class="ttname"><a href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a></div><div class="ttdeci">AtProcViewportMode</div><div class="ttdoc">Enum with the different modes available for a procedural viewport representation.</div><div class="ttdef"><b>Definition:</b> ai_procedural.h:133</div></div>
<div class="ttc" id="astructAtUniverse_html"><div class="ttname"><a href="structAtUniverse.html">AtUniverse</a></div><div class="ttdoc">This represents a universe in Arnold.</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gada0f51d3c111b02fef3cf1a9c9e6d02a" name="gada0f51d3c111b02fef3cf1a9c9e6d02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0f51d3c111b02fef3cf1a9c9e6d02a">&#9670;&nbsp;</a></span>AtProcInit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcInit) (<a class="el" href="structAtNode.html">AtNode</a> *node, void **user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural init method. </p>
<p >This method will be called first and should perform any initialization required by your procedural. You probably want to create new nodes inside this method but you should return them through <a class="el" href="group__ai__procedurals.html#ga5c9e2a6273cd6c5485eb6ff436eeb558">AtProcGetNode</a> and correctly return the number of created nodes from <a class="el" href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">AtProcNumNodes</a>, otherwise the behavior is undefined. Alternatively, if you know ahead of time exactly how many nodes you are going to create, you can create them in <a class="el" href="group__ai__procedurals.html#ga5c9e2a6273cd6c5485eb6ff436eeb558">AtProcGetNode</a> too.</p>
<p >This method may be called concurrently with other uses of the same procedural plugin, unless "options.enable_threaded_procedurals" is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_ptr</td><td>This is a general-purpose, user-supplied data pointer that Arnold will pass along to the other procedural methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a id="ga241c14baad4c5003b51f0195b2debcc0" name="ga241c14baad4c5003b51f0195b2debcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga241c14baad4c5003b51f0195b2debcc0">&#9670;&nbsp;</a></span>AtProcCleanup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcCleanup) (const <a class="el" href="structAtNode.html">AtNode</a> *node, void *user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural cleanup method. </p>
<p >This method will be called last and should perform any cleanup required by your procedural. Make sure you release any memory you allocated that is no longer needed by Arnold.</p>
<p >This method may be called concurrently with other uses of the same procedural plugin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a id="ga16889bd521791dc3d6316d4a3faa4d00" name="ga16889bd521791dc3d6316d4a3faa4d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16889bd521791dc3d6316d4a3faa4d00">&#9670;&nbsp;</a></span>AtProcNumNodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcNumNodes) (const <a class="el" href="structAtNode.html">AtNode</a> *node, void *user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural node count method. </p>
<p >This method will be called after initialization and should report the exact number of nodes to be created. Alternatively, when the total number of nodes is not known beforehand, it might return -1, and then Arnold will call the <a class="el" href="group__ai__procedurals.html#ga5c9e2a6273cd6c5485eb6ff436eeb558">AtProcGetNode</a> method until it returns NULL to indicate no more nodes are available.</p>
<p >This method may be called concurrently with other uses of the same procedural plugin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the procedural </dd></dl>

</div>
</div>
<a id="ga5c9e2a6273cd6c5485eb6ff436eeb558" name="ga5c9e2a6273cd6c5485eb6ff436eeb558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c9e2a6273cd6c5485eb6ff436eeb558">&#9670;&nbsp;</a></span>AtProcGetNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structAtNode.html">AtNode</a> *(* AtProcGetNode) (const <a class="el" href="structAtNode.html">AtNode</a> *node, void *user_ptr, int i)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural node fetching method. </p>
<p >This method will be called once for each node to be created (as determined by <a class="el" href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">AtProcNumNodes</a>). Note that if you created any node in <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a>, they also should be returned here, otherwise the behaviour would be undefined.</p>
<p >If -1 was returned by <a class="el" href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">AtProcNumNodes</a>, this method should return NULL when all nodes have been returned and there are no more available.</p>
<p >This method may be called concurrently with other uses of the same procedural plugin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a> </td></tr>
    <tr><td class="paramname">i</td><td>Node index, in the range 0 to <a class="el" href="group__ai__procedurals.html#ga16889bd521791dc3d6316d4a3faa4d00">AtProcNumNodes</a> - 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The i'th node in the procedural </dd></dl>

</div>
</div>
<a id="ga492b7b10d002ae8aecdae514557bd667" name="ga492b7b10d002ae8aecdae514557bd667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga492b7b10d002ae8aecdae514557bd667">&#9670;&nbsp;</a></span>AtProcViewport</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcViewport) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, <a class="el" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a> mode, const AtParamValueMap *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural viewport representation method. </p>
<p >This method can be called to obtain a simplified representation of a procedural, made up of nodes that will be created in the given universe.</p>
<p >This is an example implementation for a simple custom procedural: </p><div class="fragment"><div class="line">procedural_viewport</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (mode == AI_PROC_BOXES)</div>
<div class="line">   {</div>
<div class="line">      <a class="code hl_struct" href="structAtNode.html">AtNode</a>* bbox_node = <a class="code hl_function" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe">AiNode</a>(universe, <span class="stringliteral">&quot;box&quot;</span>, <span class="stringliteral">&quot;bbox0&quot;</span>);</div>
<div class="line">      AiNodeSetVec(bbox_node, <span class="stringliteral">&quot;min&quot;</span>, -5, -5, -5);</div>
<div class="line">      AiNodeSetVec(bbox_node, <span class="stringliteral">&quot;max&quot;</span>, 5, 5, 5);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="group__ai__render.html#gga0822b96341848b9f492093e53cccb6c3a8c4226fc69833b9f3b26e1ab90f88198">AI_SUCCESS</a>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ai__nodes_html_ga0ec954bbf54e8e47e0f3706c49a174fe"><div class="ttname"><a href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe">AiNode</a></div><div class="ttdeci">AI_API AtNode * AiNode(AtUniverse *universe, const AtString nentry_name, const AtString name=AtString(), const AtNode *parent=NULL)</div><div class="ttdoc">Create a fresh instantiation of a node in a specific Arnold universe.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:281</div></div>
<div class="ttc" id="agroup__ai__render_html_gga0822b96341848b9f492093e53cccb6c3a8c4226fc69833b9f3b26e1ab90f88198"><div class="ttname"><a href="group__ai__render.html#gga0822b96341848b9f492093e53cccb6c3a8c4226fc69833b9f3b26e1ab90f88198">AI_SUCCESS</a></div><div class="ttdeci">@ AI_SUCCESS</div><div class="ttdoc">no error</div><div class="ttdef"><b>Definition:</b> ai_render.h:45</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramname">universe</td><td>The universe where the new nodes will be created </td></tr>
    <tr><td class="paramname">mode</td><td>The type of primitives used for the viewport representation </td></tr>
    <tr><td class="paramname">params</td><td>List of optional parameters to be interpreted by the procedurals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>AI_SUCCESS</code> if no error, an error value otherwise </dd></dl>

</div>
</div>
<a id="ga4c5022dfa4b2b93e6b8f36d9ac1bdd29" name="ga4c5022dfa4b2b93e6b8f36d9ac1bdd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c5022dfa4b2b93e6b8f36d9ac1bdd29">&#9670;&nbsp;</a></span>AtProcFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcFuncPtr) (<a class="el" href="structAtProceduralNodeMethods.html">AtProceduralNodeMethods</a> *methods)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural function pointer entry-point symbol. </p>
<p >A function pointer of this type can be set in the procedural funcptr parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">methods</td><td>List of procedural methods (some of which are optional) to be supplied by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7ec78c1412dc4cefd5bf6de70663f44b" name="ga7ec78c1412dc4cefd5bf6de70663f44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec78c1412dc4cefd5bf6de70663f44b">&#9670;&nbsp;</a></span>AiProceduralViewport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API int AiProceduralViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__procedurals.html#ga1fbdf789b2f70dfe7815b008191c2c57">AtProcViewportMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>AI_PROC_BOXES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural viewport representation method. </p>
<p >Call this method to get a simplified representation of geometry, either directly or from inside a procedural for a DCC viewport. The nodes are created in the given universe, and mode determines the type of representation (for example, bounding boxes, points, or polygons). The optional params allows you to pass in a variable number of paramater values to the method.</p>
<p >This is an example of some code to get this representation from a procedural "proc": </p><div class="fragment"><div class="line"><span class="comment">// Create new universe to store the proxy representation</span></div>
<div class="line"><a class="code hl_struct" href="structAtUniverse.html">AtUniverse</a>* view_universe = <a class="code hl_function" href="group__ai__universe.html#ga31b30200833aac1a32444651a0ca2db5">AiUniverse</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain bounding-box representation (one box for each object in the procedural)</span></div>
<div class="line">AtParamValueMap* params = <a class="code hl_function" href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a>();</div>
<div class="line">AiParamValueMapSetInt(params, <a class="code hl_class" href="classAtString.html">AtString</a>(<span class="stringliteral">&quot;param&quot;</span>), 0);  <span class="comment">// Example parameter</span></div>
<div class="line"><a class="code hl_function" href="group__ai__procedurals.html#ga7ec78c1412dc4cefd5bf6de70663f44b">AiProceduralViewport</a>(proc, view_universe, AI_PROC_BOXES, params);</div>
<div class="line"><a class="code hl_function" href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a>(params);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After that, we can iterate over those nodes and get any kind of information</span></div>
<div class="line">AtNodeIterator* it = <a class="code hl_function" href="group__ai__universe.html#ga7e9a681d265bf5ce15f4964a008f2ecc">AiUniverseGetNodeIterator</a>(view_universe, <a class="code hl_define" href="group__ai__node__entry.html#ga5da98c230027a66005c322e0b72a94e6">AI_NODE_SHAPE</a>);</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">AiNodeIteratorFinished</a>(it))</div>
<div class="line">{</div>
<div class="line">   <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node = <a class="code hl_function" href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238">AiNodeIteratorGetNext</a>(it);</div>
<div class="line">   printf(<span class="stringliteral">&quot;Node name: %s\n&quot;</span>, <a class="code hl_function" href="group__ai__nodes.html#ga31dddf920dac4c97ffd9cbf8729fa439">AiNodeGetName</a>(node));</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">AiNodeIteratorDestroy</a>(it);</div>
<div class="ttc" id="aclassAtString_html"><div class="ttname"><a href="classAtString.html">AtString</a></div><div class="ttdoc">Arnold String allows for fast string comparisons.</div><div class="ttdef"><b>Definition:</b> ai_string.h:54</div></div>
<div class="ttc" id="agroup__ai__map_html_ga79ba0a87866541a1029201b9df5bddf1"><div class="ttname"><a href="group__ai__map.html#ga79ba0a87866541a1029201b9df5bddf1">AiParamValueMap</a></div><div class="ttdeci">AI_API AtParamValueMap * AiParamValueMap()</div><div class="ttdoc">Creates a new map.</div><div class="ttdef"><b>Definition:</b> ai_map.cpp:46</div></div>
<div class="ttc" id="agroup__ai__map_html_gab06bffff6c01ce8b403d107e4325052e"><div class="ttname"><a href="group__ai__map.html#gab06bffff6c01ce8b403d107e4325052e">AiParamValueMapDestroy</a></div><div class="ttdeci">AI_API void AiParamValueMapDestroy(AtParamValueMap *map)</div><div class="ttdoc">Destroys a map object.</div><div class="ttdef"><b>Definition:</b> ai_map.cpp:55</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_ga5da98c230027a66005c322e0b72a94e6"><div class="ttname"><a href="group__ai__node__entry.html#ga5da98c230027a66005c322e0b72a94e6">AI_NODE_SHAPE</a></div><div class="ttdeci">#define AI_NODE_SHAPE</div><div class="ttdoc">Geometry nodes (sphere, polymesh, etc)</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:41</div></div>
<div class="ttc" id="agroup__ai__nodes_html_ga31dddf920dac4c97ffd9cbf8729fa439"><div class="ttname"><a href="group__ai__nodes.html#ga31dddf920dac4c97ffd9cbf8729fa439">AiNodeGetName</a></div><div class="ttdeci">AI_API AI_PURE const char * AiNodeGetName(const AtNode *node)</div><div class="ttdoc">Return the node's name.</div><div class="ttdef"><b>Definition:</b> ai_nodes.cpp:191</div></div>
<div class="ttc" id="agroup__ai__procedurals_html_ga7ec78c1412dc4cefd5bf6de70663f44b"><div class="ttname"><a href="group__ai__procedurals.html#ga7ec78c1412dc4cefd5bf6de70663f44b">AiProceduralViewport</a></div><div class="ttdeci">AI_API int AiProceduralViewport(const AtNode *node, AtUniverse *universe, AtProcViewportMode mode=AI_PROC_BOXES, const AtParamValueMap *params=NULL)</div><div class="ttdoc">Procedural viewport representation method.</div><div class="ttdef"><b>Definition:</b> ai_procedural.cpp:6</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga31b30200833aac1a32444651a0ca2db5"><div class="ttname"><a href="group__ai__universe.html#ga31b30200833aac1a32444651a0ca2db5">AiUniverse</a></div><div class="ttdeci">AI_API AtUniverse * AiUniverse()</div><div class="ttdoc">Creates a new universe that can be used independently of the default universe.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:90</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga7e9a681d265bf5ce15f4964a008f2ecc"><div class="ttname"><a href="group__ai__universe.html#ga7e9a681d265bf5ce15f4964a008f2ecc">AiUniverseGetNodeIterator</a></div><div class="ttdeci">AI_API AtNodeIterator * AiUniverseGetNodeIterator(const AtUniverse *universe, unsigned int node_mask)</div><div class="ttdoc">Creates a new node iterator for the given Arnold universe and resets it to the first node.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:220</div></div>
<div class="ttc" id="agroup__ai__universe_html_ga96d69986fc556e8a69c400d355558238"><div class="ttname"><a href="group__ai__universe.html#ga96d69986fc556e8a69c400d355558238">AiNodeIteratorGetNext</a></div><div class="ttdeci">AI_API AtNode * AiNodeIteratorGetNext(AtNodeIterator *iter)</div><div class="ttdoc">Returns current node and points node iterator to the next node.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:513</div></div>
<div class="ttc" id="agroup__ai__universe_html_gac14e2b776f7e32dcb7346f64061f28ff"><div class="ttname"><a href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">AiNodeIteratorDestroy</a></div><div class="ttdeci">AI_API void AiNodeIteratorDestroy(AtNodeIterator *iter)</div><div class="ttdoc">Destroys a node iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:488</div></div>
<div class="ttc" id="agroup__ai__universe_html_gaed6b120df6cb2b6b57dc700d04d5f118"><div class="ttname"><a href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">AiNodeIteratorFinished</a></div><div class="ttdeci">AI_API AI_PURE bool AiNodeIteratorFinished(const AtNodeIterator *iter)</div><div class="ttdoc">Returns true if there are no more nodes to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_universe.cpp:524</div></div>
</div><!-- fragment --><p >Optional parameters allow further configuration of the representation: </p><table class="doxtable">
<tr>
<th>Supported optional parameters </th></tr>
<tr>
<td><em>None yet</em> </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>This is the source node itself </td></tr>
    <tr><td class="paramname">universe</td><td>The universe where the new nodes will be created. A valid universe pointer needs to be passed. If null, this function will return with an error </td></tr>
    <tr><td class="paramname">mode</td><td>The type of primitives used for the viewport representation </td></tr>
    <tr><td class="paramname">params</td><td>List of optional parameters to be interpreted by the procedurals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AI_SUCCESS if no error, an error value otherwise </dd></dl>

</div>
</div>
<a id="ga0ad340bccafac60d936f0a156a959b7e" name="ga0ad340bccafac60d936f0a156a959b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad340bccafac60d936f0a156a959b7e">&#9670;&nbsp;</a></span>AiProceduralExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiProceduralExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>proc_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtParamValueMap *&#160;</td>
          <td class="paramname"><em>params</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure a procedural node is ready to be used for rendering. </p>
<p >This method initializes and updates a procedural node, making sure all its children are loaded. If called during render, it will ensure the procedural contents are also updated and ready for render.</p>
<p >One way this API can be useful is when a procedural needs to access the contents of another procedural during its initialization. e.g. procedural1 tries to create an instance of a node contained in procedural2. This could be problematic with parallel scene initialization, since it doesn't guarantee a specific ordering, and procedural1 might end up being initialized before procedural2. In order to fix this, procedural2 can be explicitly initialized using this API, before accessing its contents.</p>
<p >If this API is called before a render session was created, the target procedural needs to handle this case and avoid accessing the non-existent render session. Built-in procedurals are safe to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc_node</td><td>The procedural node to be expanded </td></tr>
    <tr><td class="paramname">params</td><td>Optional AtParamValueMap to pass custom arguments for the expansion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
