<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Volume Plugin API</div></div>
</div><!--header-->
<div class="contents">

<p>Interaction with custom volumes, implicit surfaces and formats at render time.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtVolumeData.html">AtVolumeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume data, as returned by <a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a>.  <a href="structAtVolumeData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtVolumeNodeMethods.html">AtVolumeNodeMethods</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0805689e7b5b71f23aa9fa31f1bb189f"><td class="memItemLeft" align="right" valign="top"><a id="ga0805689e7b5b71f23aa9fa31f1bb189f" name="ga0805689e7b5b71f23aa9fa31f1bb189f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeData::private_info</b></td></tr>
<tr class="memdesc:ga0805689e7b5b71f23aa9fa31f1bb189f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin private data, used how the plugin likes. <br /></td></tr>
<tr class="separator:ga0805689e7b5b71f23aa9fa31f1bb189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada54142b4079ea0f8209402375c219af"><td class="memItemLeft" align="right" valign="top"><a id="gada54142b4079ea0f8209402375c219af" name="gada54142b4079ea0f8209402375c219af"></a>
<a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeData::bbox</b></td></tr>
<tr class="memdesc:gada54142b4079ea0f8209402375c219af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding box for this volume, plugin is responsible for also including volume_padding from the node. <br /></td></tr>
<tr class="separator:gada54142b4079ea0f8209402375c219af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0487825b597d857757d6c16d8386bd"><td class="memItemLeft" align="right" valign="top"><a id="ga4a0487825b597d857757d6c16d8386bd" name="ga4a0487825b597d857757d6c16d8386bd"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeData::auto_step_size</b></td></tr>
<tr class="memdesc:ga4a0487825b597d857757d6c16d8386bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommended step size for ray marching through this data. <br /></td></tr>
<tr class="separator:ga4a0487825b597d857757d6c16d8386bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee96d6fdd07ef25a9e5108bffa74b60"><td class="memItemLeft" align="right" valign="top"><a id="ga0ee96d6fdd07ef25a9e5108bffa74b60" name="ga0ee96d6fdd07ef25a9e5108bffa74b60"></a>
<a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeNodeMethods::Create</b></td></tr>
<tr class="memdesc:ga0ee96d6fdd07ef25a9e5108bffa74b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to load/create a volume. <br /></td></tr>
<tr class="separator:ga0ee96d6fdd07ef25a9e5108bffa74b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5e3171a039f89dd8db0ea3e5f60fa2"><td class="memItemLeft" align="right" valign="top"><a id="ga6f5e3171a039f89dd8db0ea3e5f60fa2" name="ga6f5e3171a039f89dd8db0ea3e5f60fa2"></a>
<a class="el" href="group__ai__volumes.html#gadb3a6a56172481e64ed59614faec50cd">AtVolumeUpdate</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeNodeMethods::Update</b></td></tr>
<tr class="memdesc:ga6f5e3171a039f89dd8db0ea3e5f60fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to update a volume before render passes or on scene changes. <br /></td></tr>
<tr class="separator:ga6f5e3171a039f89dd8db0ea3e5f60fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e64ab632a54b6a08487de6be08e2c"><td class="memItemLeft" align="right" valign="top"><a id="ga305e64ab632a54b6a08487de6be08e2c" name="ga305e64ab632a54b6a08487de6be08e2c"></a>
<a class="el" href="group__ai__volumes.html#ga8797d2844cc7b3243d7159a0055feec1">AtVolumeCleanup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeNodeMethods::Cleanup</b></td></tr>
<tr class="memdesc:ga305e64ab632a54b6a08487de6be08e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to clean up a volume when it's no longer needed. <br /></td></tr>
<tr class="separator:ga305e64ab632a54b6a08487de6be08e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edee3d9a0212f90d78734740a944d78"><td class="memItemLeft" align="right" valign="top"><a id="ga5edee3d9a0212f90d78734740a944d78" name="ga5edee3d9a0212f90d78734740a944d78"></a>
<a class="el" href="group__ai__volumes.html#ga0fafb8d898f5a2a8feecc45155a6c9b5">AtVolumeRayExtents</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeNodeMethods::RayExtents</b></td></tr>
<tr class="memdesc:ga5edee3d9a0212f90d78734740a944d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to get all tightly-bounded extents along a ray where the volume exists. <br /></td></tr>
<tr class="separator:ga5edee3d9a0212f90d78734740a944d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b81d095a2efbf51859bb5a7e5625457"><td class="memItemLeft" align="right" valign="top"><a id="ga2b81d095a2efbf51859bb5a7e5625457" name="ga2b81d095a2efbf51859bb5a7e5625457"></a>
<a class="el" href="group__ai__volumes.html#ga1b7fb17d1935b415fd42316ea8566276">AtVolumeSample</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeNodeMethods::Sample</b></td></tr>
<tr class="memdesc:ga2b81d095a2efbf51859bb5a7e5625457"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to sample a volume's named channel using a given point and interpolation. <br /></td></tr>
<tr class="separator:ga2b81d095a2efbf51859bb5a7e5625457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d6508140f78ff7da3e3024c743baf5"><td class="memItemLeft" align="right" valign="top"><a id="gaf5d6508140f78ff7da3e3024c743baf5" name="gaf5d6508140f78ff7da3e3024c743baf5"></a>
<a class="el" href="group__ai__volumes.html#gafdb45913a7cd192ce6c340b7ff7798ad">AtVolumeGradient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumeNodeMethods::Gradient</b></td></tr>
<tr class="memdesc:gaf5d6508140f78ff7da3e3024c743baf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to sample the gradient of a volume's named channel using a given point and interpolation. <br /></td></tr>
<tr class="separator:gaf5d6508140f78ff7da3e3024c743baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Volume interpolation quality</h2></td></tr>
<tr class="memitem:ga75af376f2bdc390088bc4121bba26b7e"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td></tr>
<tr class="memdesc:ga75af376f2bdc390088bc4121bba26b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin volume creation.  <a href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">More...</a><br /></td></tr>
<tr class="separator:ga75af376f2bdc390088bc4121bba26b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb3a6a56172481e64ed59614faec50cd"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gadb3a6a56172481e64ed59614faec50cd">AtVolumeUpdate</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td></tr>
<tr class="memdesc:gadb3a6a56172481e64ed59614faec50cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin volume update.  <a href="group__ai__volumes.html#gadb3a6a56172481e64ed59614faec50cd">More...</a><br /></td></tr>
<tr class="separator:gadb3a6a56172481e64ed59614faec50cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8797d2844cc7b3243d7159a0055feec1"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga8797d2844cc7b3243d7159a0055feec1">AtVolumeCleanup</a>) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td></tr>
<tr class="memdesc:ga8797d2844cc7b3243d7159a0055feec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin volume cleanup method.  <a href="group__ai__volumes.html#ga8797d2844cc7b3243d7159a0055feec1">More...</a><br /></td></tr>
<tr class="separator:ga8797d2844cc7b3243d7159a0055feec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7fb17d1935b415fd42316ea8566276"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga1b7fb17d1935b415fd42316ea8566276">AtVolumeSample</a>) (const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="classAtString.html">AtString</a> channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="classAtParamValue.html">AtParamValue</a> *value, uint8_t *type)</td></tr>
<tr class="memdesc:ga1b7fb17d1935b415fd42316ea8566276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin sample method.  <a href="group__ai__volumes.html#ga1b7fb17d1935b415fd42316ea8566276">More...</a><br /></td></tr>
<tr class="separator:ga1b7fb17d1935b415fd42316ea8566276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb45913a7cd192ce6c340b7ff7798ad"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gafdb45913a7cd192ce6c340b7ff7798ad">AtVolumeGradient</a>) (const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="classAtString.html">AtString</a> channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="structAtVector.html">AtVector</a> *gradient)</td></tr>
<tr class="memdesc:gafdb45913a7cd192ce6c340b7ff7798ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin gradient method.  <a href="group__ai__volumes.html#gafdb45913a7cd192ce6c340b7ff7798ad">More...</a><br /></td></tr>
<tr class="separator:gafdb45913a7cd192ce6c340b7ff7798ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fafb8d898f5a2a8feecc45155a6c9b5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga0fafb8d898f5a2a8feecc45155a6c9b5">AtVolumeRayExtents</a>) (const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const AtVolumeIntersectionInfo *info, uint16_t tid, float time, const <a class="el" href="structAtVector.html">AtVector</a> *origin, const <a class="el" href="structAtVector.html">AtVector</a> *direction, float t0, float t1)</td></tr>
<tr class="memdesc:ga0fafb8d898f5a2a8feecc45155a6c9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin method for submitting extents along a ray where there is data.  <a href="group__ai__volumes.html#ga0fafb8d898f5a2a8feecc45155a6c9b5">More...</a><br /></td></tr>
<tr class="separator:ga0fafb8d898f5a2a8feecc45155a6c9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410fbbf47e5b9094293e6546a2f82f88"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> (const AtVolumeIntersectionInfo *info, float t0, float t1)</td></tr>
<tr class="memdesc:ga410fbbf47e5b9094293e6546a2f82f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a ray interval/extent for volume integration.  <a href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">More...</a><br /></td></tr>
<tr class="separator:ga410fbbf47e5b9094293e6546a2f82f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga625c67acf585cdf1ed6ada2604377e13"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga625c67acf585cdf1ed6ada2604377e13">AiVolumeMergeIntersection</a> (const AtVolumeIntersectionInfo *info, float t0, float t1, uint32_t prim_id)</td></tr>
<tr class="memdesc:ga625c67acf585cdf1ed6ada2604377e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a ray interval/extent for volume integration.  <a href="group__ai__volumes.html#ga625c67acf585cdf1ed6ada2604377e13">More...</a><br /></td></tr>
<tr class="separator:ga625c67acf585cdf1ed6ada2604377e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b02fa988aa8e2226a76871aa3fb51e9"><td class="memItemLeft" align="right" valign="top">AI_API AtArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga2b02fa988aa8e2226a76871aa3fb51e9">AiVolumeFileGetChannels</a> (const char *filename)</td></tr>
<tr class="memdesc:ga2b02fa988aa8e2226a76871aa3fb51e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of channel names in a volume file.  <a href="group__ai__volumes.html#ga2b02fa988aa8e2226a76871aa3fb51e9">More...</a><br /></td></tr>
<tr class="separator:ga2b02fa988aa8e2226a76871aa3fb51e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ad19a33cde3db2d8d2a33c5848b865"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga68ad19a33cde3db2d8d2a33c5848b865">AiVolumeFileGetBBox</a> (const char *filename, const AtArray *channels)</td></tr>
<tr class="memdesc:ga68ad19a33cde3db2d8d2a33c5848b865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bounding box for specified channels in a volume file.  <a href="group__ai__volumes.html#ga68ad19a33cde3db2d8d2a33c5848b865">More...</a><br /></td></tr>
<tr class="separator:ga68ad19a33cde3db2d8d2a33c5848b865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb44d2a905b83a4991d692b5c836d51"><td class="memItemLeft" align="right" valign="top"><a id="ga2fb44d2a905b83a4991d692b5c836d51" name="ga2fb44d2a905b83a4991d692b5c836d51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_VOLUME_INTERP_CLOSEST</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2fb44d2a905b83a4991d692b5c836d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">closest data from the volume <br /></td></tr>
<tr class="separator:ga2fb44d2a905b83a4991d692b5c836d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0220a799d98f756e0daa4617233f35"><td class="memItemLeft" align="right" valign="top"><a id="ga2c0220a799d98f756e0daa4617233f35" name="ga2c0220a799d98f756e0daa4617233f35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_VOLUME_INTERP_TRILINEAR</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga2c0220a799d98f756e0daa4617233f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">trilinearly sampled volume <br /></td></tr>
<tr class="separator:ga2c0220a799d98f756e0daa4617233f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"><td class="memItemLeft" align="right" valign="top"><a id="ga4bbde2a4d76bfc4d5acaf9b6bca28d4c" name="ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_VOLUME_INTERP_TRICUBIC</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tricubicly sampled volume <br /></td></tr>
<tr class="separator:ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2af04371e1085888ef435b8a55e9607"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gaa2af04371e1085888ef435b8a55e9607">AI_VOLUME_NODE_EXPORT_METHODS</a>(tag)</td></tr>
<tr class="memdesc:gaa2af04371e1085888ef435b8a55e9607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume node methods exporter.  <a href="group__ai__volumes.html#gaa2af04371e1085888ef435b8a55e9607">More...</a><br /></td></tr>
<tr class="separator:gaa2af04371e1085888ef435b8a55e9607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc727c737e9e9c6315acb13addb8c87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga9fc727c737e9e9c6315acb13addb8c87">volume_create</a></td></tr>
<tr class="separator:ga9fc727c737e9e9c6315acb13addb8c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cf0a5d0e448fa34f3e3f239875b47a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga43cf0a5d0e448fa34f3e3f239875b47a">volume_update</a></td></tr>
<tr class="separator:ga43cf0a5d0e448fa34f3e3f239875b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebe67c42f359e3e468d0e54a805f8eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gacebe67c42f359e3e468d0e54a805f8eb">volume_cleanup</a></td></tr>
<tr class="separator:gacebe67c42f359e3e468d0e54a805f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72c946c0999a59d42818bf9c521082af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga72c946c0999a59d42818bf9c521082af">volume_ray_extents</a></td></tr>
<tr class="separator:ga72c946c0999a59d42818bf9c521082af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1359c98dd155097179d6206dfff8cfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gab1359c98dd155097179d6206dfff8cfb">volume_sample</a></td></tr>
<tr class="separator:gab1359c98dd155097179d6206dfff8cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02732a53d995b91405a554d170ca5675"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga02732a53d995b91405a554d170ca5675">volume_gradient</a></td></tr>
<tr class="separator:ga02732a53d995b91405a554d170ca5675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Interaction with custom volumes, implicit surfaces and formats at render time. </p>
<p >This is accomplished by providing the renderer some callback functions which are called as needed (when the object is hit by a ray). The plugins are intended to provide tight ray intervals surrounding actual volumetric or implicit surface data, as well as sampling methods for sampling data channels from the volume or implicit surface.</p>
<p >Note that the plugins have a thread-locked part: init and cleanup, while the rest of the callbacks may be called concurrently from multiple threads. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa2af04371e1085888ef435b8a55e9607" name="gaa2af04371e1085888ef435b8a55e9607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2af04371e1085888ef435b8a55e9607">&#9670;&nbsp;</a></span>AI_VOLUME_NODE_EXPORT_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_VOLUME_NODE_EXPORT_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">AI_INSTANCE_COMMON_SHAPE_METHODS             \</div>
<div class="line">volume_create;                               \</div>
<div class="line">volume_update;                               \</div>
<div class="line">volume_cleanup;                              \</div>
<div class="line">volume_ray_extents;                          \</div>
<div class="line">volume_sample;                               \</div>
<div class="line">volume_gradient;                             \</div>
<div class="line">static <a class="code hl_struct" href="structAtVolumeNodeMethods.html">AtVolumeNodeMethods</a> ai_vol_mtds = {   \</div>
<div class="line">   VolumeCreate,                             \</div>
<div class="line">   VolumeUpdate,                             \</div>
<div class="line">   VolumeCleanup,                            \</div>
<div class="line">   VolumeRayExtents,                         \</div>
<div class="line">   VolumeSample,                             \</div>
<div class="line">   VolumeGradient                            \</div>
<div class="line">};                                           \</div>
<div class="line">static <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_mtds = {        \</div>
<div class="line">   &amp;ai_common_mtds,                          \</div>
<div class="line">   &amp;ai_vol_mtds                              \</div>
<div class="line">};                                           \</div>
<div class="line">const <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a>* tag = &amp;ai_node_mtds;</div>
<div class="ttc" id="astructAtNodeMethods_html"><div class="ttname"><a href="structAtNodeMethods.html">AtNodeMethods</a></div><div class="ttdoc">Node methods.</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:86</div></div>
<div class="ttc" id="astructAtVolumeNodeMethods_html"><div class="ttname"><a href="structAtVolumeNodeMethods.html">AtVolumeNodeMethods</a></div><div class="ttdef"><b>Definition:</b> ai_volume.h:188</div></div>
</div><!-- fragment -->
<p>Volume node methods exporter. </p>

</div>
</div>
<a id="ga9fc727c737e9e9c6315acb13addb8c87" name="ga9fc727c737e9e9c6315acb13addb8c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fc727c737e9e9c6315acb13addb8c87">&#9670;&nbsp;</a></span>volume_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_create</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> VolumeCreate(<span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node,   \</div>
<div class="line">                         <a class="code hl_struct" href="structAtVolumeData.html">AtVolumeData</a>* data)</div>
<div class="ttc" id="astructAtNode_html"><div class="ttname"><a href="structAtNode.html">AtNode</a></div><div class="ttdoc">This represents a node in Arnold.</div></div>
<div class="ttc" id="astructAtVolumeData_html"><div class="ttname"><a href="structAtVolumeData.html">AtVolumeData</a></div><div class="ttdoc">Volume data, as returned by AtVolumeCreate.</div><div class="ttdef"><b>Definition:</b> ai_volume.h:53</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga43cf0a5d0e448fa34f3e3f239875b47a" name="ga43cf0a5d0e448fa34f3e3f239875b47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cf0a5d0e448fa34f3e3f239875b47a">&#9670;&nbsp;</a></span>volume_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_update</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> VolumeUpdate(<span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node,   \</div>
<div class="line">                         <a class="code hl_struct" href="structAtVolumeData.html">AtVolumeData</a>* data)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gacebe67c42f359e3e468d0e54a805f8eb" name="gacebe67c42f359e3e468d0e54a805f8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacebe67c42f359e3e468d0e54a805f8eb">&#9670;&nbsp;</a></span>volume_cleanup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_cleanup</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> VolumeCleanup(<span class="keyword">const</span> <a class="code hl_struct" href="structAtNode.html">AtNode</a>* node,  \</div>
<div class="line">                          <a class="code hl_struct" href="structAtVolumeData.html">AtVolumeData</a>* data)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga72c946c0999a59d42818bf9c521082af" name="ga72c946c0999a59d42818bf9c521082af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72c946c0999a59d42818bf9c521082af">&#9670;&nbsp;</a></span>volume_ray_extents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_ray_extents</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> VolumeRayExtents(<span class="keyword">const</span> <a class="code hl_struct" href="structAtVolumeData.html">AtVolumeData</a>* data,             \</div>
<div class="line">                             <span class="keyword">const</span> AtVolumeIntersectionInfo* info, \</div>
<div class="line">                             uint16_t tid,                         \</div>
<div class="line">                             <span class="keywordtype">float</span> time,                           \</div>
<div class="line">                             <span class="keyword">const</span> <a class="code hl_struct" href="structAtVector.html">AtVector</a>* origin,               \</div>
<div class="line">                             <span class="keyword">const</span> <a class="code hl_struct" href="structAtVector.html">AtVector</a>* direction,            \</div>
<div class="line">                             <span class="keywordtype">float</span> t0,                             \</div>
<div class="line">                             <span class="keywordtype">float</span> t1)</div>
<div class="ttc" id="astructAtVector_html"><div class="ttname"><a href="structAtVector.html">AtVector</a></div><div class="ttdoc">3D point (single precision)</div><div class="ttdef"><b>Definition:</b> ai_vector.h:30</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gab1359c98dd155097179d6206dfff8cfb" name="gab1359c98dd155097179d6206dfff8cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1359c98dd155097179d6206dfff8cfb">&#9670;&nbsp;</a></span>volume_sample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_sample</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> VolumeSample(<span class="keyword">const</span> <a class="code hl_struct" href="structAtVolumeData.html">AtVolumeData</a>* data,   \</div>
<div class="line">                         <span class="keyword">const</span> <a class="code hl_class" href="classAtString.html">AtString</a> channel,     \</div>
<div class="line">                         <span class="keyword">const</span> <a class="code hl_struct" href="structAtShaderGlobals.html">AtShaderGlobals</a>* sg,  \</div>
<div class="line">                         <span class="keywordtype">int</span> interp,                 \</div>
<div class="line">                         <a class="code hl_class" href="classAtParamValue.html">AtParamValue</a> *value,        \</div>
<div class="line">                         uint8_t *type)</div>
<div class="ttc" id="aclassAtParamValue_html"><div class="ttname"><a href="classAtParamValue.html">AtParamValue</a></div><div class="ttdoc">Actual parameter value for each supported type.</div><div class="ttdef"><b>Definition:</b> ai_params.h:106</div></div>
<div class="ttc" id="aclassAtString_html"><div class="ttname"><a href="classAtString.html">AtString</a></div><div class="ttdoc">Arnold String allows for fast string comparisons.</div><div class="ttdef"><b>Definition:</b> ai_string.h:54</div></div>
<div class="ttc" id="astructAtShaderGlobals_html"><div class="ttname"><a href="structAtShaderGlobals.html">AtShaderGlobals</a></div><div class="ttdoc">Shader globals data structure.</div><div class="ttdef"><b>Definition:</b> ai_shaderglobals.h:45</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga02732a53d995b91405a554d170ca5675" name="ga02732a53d995b91405a554d170ca5675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02732a53d995b91405a554d170ca5675">&#9670;&nbsp;</a></span>volume_gradient</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_gradient</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> VolumeGradient(<span class="keyword">const</span> <a class="code hl_struct" href="structAtVolumeData.html">AtVolumeData</a>* data,   \</div>
<div class="line">                           <span class="keyword">const</span> <a class="code hl_class" href="classAtString.html">AtString</a> channel,     \</div>
<div class="line">                           <span class="keyword">const</span> <a class="code hl_struct" href="structAtShaderGlobals.html">AtShaderGlobals</a>* sg,  \</div>
<div class="line">                           <span class="keywordtype">int</span> interp,                 \</div>
<div class="line">                           <a class="code hl_struct" href="structAtVector.html">AtVector</a>* gradient)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga75af376f2bdc390088bc4121bba26b7e" name="ga75af376f2bdc390088bc4121bba26b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75af376f2bdc390088bc4121bba26b7e">&#9670;&nbsp;</a></span>AtVolumeCreate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumeCreate) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin volume creation. </p>
<p >This method will be called for each volume node before usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Owner node where the volume was requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Volume data with all fields to be set by the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if volume creation succeeded </dd></dl>

</div>
</div>
<a id="gadb3a6a56172481e64ed59614faec50cd" name="gadb3a6a56172481e64ed59614faec50cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb3a6a56172481e64ed59614faec50cd">&#9670;&nbsp;</a></span>AtVolumeUpdate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumeUpdate) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin volume update. </p>
<p >This method will be called for each volume node before each render pass or scene change, so that the volume can be update accordingly. If not provided, the volume will be destroyed and recreated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Owner node where the volume was requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Volume data with all fields to be set by the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if volume data was modified </dd></dl>

</div>
</div>
<a id="ga8797d2844cc7b3243d7159a0055feec1" name="ga8797d2844cc7b3243d7159a0055feec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8797d2844cc7b3243d7159a0055feec1">&#9670;&nbsp;</a></span>AtVolumeCleanup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumeCleanup) (const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin volume cleanup method. </p>
<p >This method will be called once for each volume that was created by a call to <a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a> to allow a chance to clean up any private data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Volume data returned from <a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a id="ga1b7fb17d1935b415fd42316ea8566276" name="ga1b7fb17d1935b415fd42316ea8566276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7fb17d1935b415fd42316ea8566276">&#9670;&nbsp;</a></span>AtVolumeSample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumeSample) (const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="classAtString.html">AtString</a> channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="classAtParamValue.html">AtParamValue</a> *value, uint8_t *type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin sample method. </p>
<p >This method will be called concurrently to sample data from a given channel with the specified interpolation. Implementors should use sg-&gt;Po as the sampling position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Volume data returned from <a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">channel</td><td>Data channel name from the volume or implicit surface </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>Shader globals for the sampling context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">interp</td><td>Volume interpolation quality, one of <code>AI_VOLUME_INTERP_*</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Resulting sampled value, matching the type output in out_type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>Resulting value type, one of <code>AI_TYPE_FLOAT</code>, <code>AI_TYPE_VECTOR2</code>, <code>AI_TYPE_RGB</code>, <code>AI_TYPE_RGBA</code>, or <code>AI_TYPE_VECTOR</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a id="gafdb45913a7cd192ce6c340b7ff7798ad" name="gafdb45913a7cd192ce6c340b7ff7798ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb45913a7cd192ce6c340b7ff7798ad">&#9670;&nbsp;</a></span>AtVolumeGradient</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumeGradient) (const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="classAtString.html">AtString</a> channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="structAtVector.html">AtVector</a> *gradient)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin gradient method. </p>
<p >This method will be called concurrently to sample the gradient from a given channel with the specified interpolation. Implementors should use sg-&gt;Po as the sampling position. Note that this is generally only used for implicit surfaces, so if the plugin is only outputting density volume data this method can just return false and do no other work. Also note that this will also only make sense for scalar channels, such as signed distance fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Volume data returned from AtVolumePluginCreateVolume </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">channel</td><td>Data channel name from the volume or implicit surface </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>Shader globals for the sampling context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">interp</td><td>Volume interpolation quality, one of <code>AI_VOLUME_INTERP_*</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradient</td><td>Resulting sampled gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a id="ga0fafb8d898f5a2a8feecc45155a6c9b5" name="ga0fafb8d898f5a2a8feecc45155a6c9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fafb8d898f5a2a8feecc45155a6c9b5">&#9670;&nbsp;</a></span>AtVolumeRayExtents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* AtVolumeRayExtents) (const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const AtVolumeIntersectionInfo *info, uint16_t tid, float time, const <a class="el" href="structAtVector.html">AtVector</a> *origin, const <a class="el" href="structAtVector.html">AtVector</a> *direction, float t0, float t1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin method for submitting extents along a ray where there is data. </p>
<p >For each ray interval where there is volumetric data to be integrated this callback should call <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> to submit the extent along the ray. Any extra distance from the node's volume_padding parameter must be accounted for and added to each interval. Note that for implicits, the ray extents should encompass the interval where there is data such as signed-distance field values, like in narrow-band level sets. The implicit solver will then find the true ray intersection with the surface.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any ray extents submitted that overlap will have the shaders run more than once for each extent. If shaders should only be run once, then those extents should be merged and submitted just once to <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Volume data returned from <a class="el" href="group__ai__volumes.html#ga75af376f2bdc390088bc4121bba26b7e">AtVolumeCreate</a> </td></tr>
    <tr><td class="paramname">info</td><td>Opaque ptr to intersection info passed to <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> </td></tr>
    <tr><td class="paramname">tid</td><td>Current thread ID, use for thread-local access as needed </td></tr>
    <tr><td class="paramname">time</td><td>Time at which the volume is being sampled (for motion blur) </td></tr>
    <tr><td class="paramname">origin</td><td>Ray origin in object space </td></tr>
    <tr><td class="paramname">direction</td><td>Ray direction, normalized and in object space </td></tr>
    <tr><td class="paramname">t0</td><td>Start of the source ray interval in which to check for extents </td></tr>
    <tr><td class="paramname">t1</td><td>End of the source ray interval in which to check for extents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga410fbbf47e5b9094293e6546a2f82f88" name="ga410fbbf47e5b9094293e6546a2f82f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410fbbf47e5b9094293e6546a2f82f88">&#9670;&nbsp;</a></span>AiVolumeAddIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiVolumeAddIntersection </td>
          <td>(</td>
          <td class="paramtype">const AtVolumeIntersectionInfo *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a ray interval/extent for volume integration. </p>
<p >This is only useable from <a class="el" href="group__ai__volumes.html#ga0fafb8d898f5a2a8feecc45155a6c9b5">AtVolumeRayExtents</a>, where a valid pointer to AtVolumeIntersectionInfo is provided. This call may be made as many times as necessary to tightly describe where the volume data exists along the ray, but note that if overlapping extents are submitted they will be independently integrated (and shaded more than once in the overlapping areas). If you need them integrated just once, you should use <a class="el" href="group__ai__volumes.html#ga625c67acf585cdf1ed6ada2604377e13">AiVolumeMergeIntersection</a> instead.</p>
<p >Note that this same function is used to find implicit surface intersections, when the plugin provides such surfaces instead of heterogeneous volumes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Private intersection information </td></tr>
    <tr><td class="paramname">t0</td><td>Beginning of ray extent </td></tr>
    <tr><td class="paramname">t1</td><td>End of ray extent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga625c67acf585cdf1ed6ada2604377e13" name="ga625c67acf585cdf1ed6ada2604377e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga625c67acf585cdf1ed6ada2604377e13">&#9670;&nbsp;</a></span>AiVolumeMergeIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiVolumeMergeIntersection </td>
          <td>(</td>
          <td class="paramtype">const AtVolumeIntersectionInfo *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prim_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a ray interval/extent for volume integration. </p>
<p >This is only useable from <a class="el" href="group__ai__volumes.html#ga0fafb8d898f5a2a8feecc45155a6c9b5">AtVolumeRayExtents</a>, where a valid pointer to AtVolumeIntersectionInfo is provided. This call may be made as many times as necessary to tightly describe where the volume data exists along the ray, but note that if overlapping extents are submitted they will be merged and integrated just once over any overlapping ranges that match in primitive ID and step size. If you want overlapping ranges to be integrated and shaded separately, you should use <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> instead.</p>
<p >Note that this same function is used to find implicit surface intersections, when the plugin provides such surfaces instead of heterogeneous volumes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Private intersection information </td></tr>
    <tr><td class="paramname">t0</td><td>Beginning of ray extent </td></tr>
    <tr><td class="paramname">t1</td><td>End of ray extent </td></tr>
    <tr><td class="paramname">prim_id</td><td>Primitive ID or index for the part of the object, where separate parts will not be merged together. If in doubt, use zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b02fa988aa8e2226a76871aa3fb51e9" name="ga2b02fa988aa8e2226a76871aa3fb51e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b02fa988aa8e2226a76871aa3fb51e9">&#9670;&nbsp;</a></span>AiVolumeFileGetChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtArray * AiVolumeFileGetChannels </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of channel names in a volume file. </p>
<p >Currently supports the OpenVDB file format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to volume file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String array of channel names, must be freed with <code>AiArrayDestroy</code>. </dd></dl>

</div>
</div>
<a id="ga68ad19a33cde3db2d8d2a33c5848b865" name="ga68ad19a33cde3db2d8d2a33c5848b865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ad19a33cde3db2d8d2a33c5848b865">&#9670;&nbsp;</a></span>AiVolumeFileGetBBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtBBox.html">AtBBox</a> AiVolumeFileGetBBox </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtArray *&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get bounding box for specified channels in a volume file. </p>
<p >Currently supports the OpenVDB file format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to volume file. </td></tr>
    <tr><td class="paramname">channels</td><td>String array of channel names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounding box. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
