<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.4.2.1 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Operator API</div></div>
</div><!--header-->
<div class="contents">

<p>Operator node creation and operation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtOperatorNodeMethods.html">AtOperatorNodeMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup method for child data which is passed to other operators.  <a href="structAtOperatorNodeMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga54e38409d64eeae666b75a67d52a8984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga54e38409d64eeae666b75a67d52a8984">AI_OPERATOR_COMMON_NODE_METHODS</a></td></tr>
<tr class="memdesc:ga54e38409d64eeae666b75a67d52a8984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exporter for the methods shared with the standard node interface.  <a href="group__ai__operator.html#ga54e38409d64eeae666b75a67d52a8984">More...</a><br /></td></tr>
<tr class="separator:ga54e38409d64eeae666b75a67d52a8984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b3f3e19f9bce56aa89454a8d96c8fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga82b3f3e19f9bce56aa89454a8d96c8fa">AI_OPERATOR_NODE_EXPORT_METHODS</a>(tag)</td></tr>
<tr class="separator:ga82b3f3e19f9bce56aa89454a8d96c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420a026c2acd88ff0ef3c29c77f81f40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga420a026c2acd88ff0ef3c29c77f81f40">AI_OPERATOR_NODE_INTERNAL_METHODS</a>(tag)</td></tr>
<tr class="separator:ga420a026c2acd88ff0ef3c29c77f81f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf207aa6d4a92f4592dac7cf5074a1127"><td class="memItemLeft" align="right" valign="top"><a id="gaf207aa6d4a92f4592dac7cf5074a1127" name="gaf207aa6d4a92f4592dac7cf5074a1127"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>operator_init</b>&#160;&#160;&#160;static bool OperatorInit(<a class="el" href="structAtNode.html">AtNode</a>* op, void** user_data)</td></tr>
<tr class="separator:gaf207aa6d4a92f4592dac7cf5074a1127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c779b71c242f13597f2f8bcfdaef07c"><td class="memItemLeft" align="right" valign="top"><a id="ga0c779b71c242f13597f2f8bcfdaef07c" name="ga0c779b71c242f13597f2f8bcfdaef07c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>operator_cleanup</b>&#160;&#160;&#160;static bool OperatorCleanup(<a class="el" href="structAtNode.html">AtNode</a>* op, void* user_data)</td></tr>
<tr class="separator:ga0c779b71c242f13597f2f8bcfdaef07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf845241ecd4fdb1f2c2247bda12f985d"><td class="memItemLeft" align="right" valign="top"><a id="gaf845241ecd4fdb1f2c2247bda12f985d" name="gaf845241ecd4fdb1f2c2247bda12f985d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>operator_cook</b>&#160;&#160;&#160;static bool OperatorCook(<a class="el" href="structAtNode.html">AtNode</a>* node, <a class="el" href="structAtNode.html">AtNode</a>* op, void* child_data, void* user_data, const AtArray* matching_params, AtCookContext* cook_context)</td></tr>
<tr class="separator:gaf845241ecd4fdb1f2c2247bda12f985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6fb748edfd297ed8d0364a0a42783e"><td class="memItemLeft" align="right" valign="top"><a id="ga0b6fb748edfd297ed8d0364a0a42783e" name="ga0b6fb748edfd297ed8d0364a0a42783e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>operator_post_cook</b>&#160;&#160;&#160;static bool OperatorPostCook(<a class="el" href="structAtNode.html">AtNode</a>* op, void* user_data)</td></tr>
<tr class="separator:ga0b6fb748edfd297ed8d0364a0a42783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga18be93d996cc2c1be4281005b09c7ba6"><td class="memItemLeft" align="right" valign="top"><a id="ga18be93d996cc2c1be4281005b09c7ba6" name="ga18be93d996cc2c1be4281005b09c7ba6"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtOpCleanupChildData</b>) (void *child_data)</td></tr>
<tr class="separator:ga18be93d996cc2c1be4281005b09c7ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d0c136d042535d8f1fb90ba2b42692"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">AtOpInit</a>) (<a class="el" href="structAtNode.html">AtNode</a> *op, void **user_data)</td></tr>
<tr class="memdesc:ga04d0c136d042535d8f1fb90ba2b42692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator init method.  <a href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">More...</a><br /></td></tr>
<tr class="separator:ga04d0c136d042535d8f1fb90ba2b42692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a3b1982ef4158fb5b6298ef7be5c28"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga45a3b1982ef4158fb5b6298ef7be5c28">AtOpCleanup</a>) (<a class="el" href="structAtNode.html">AtNode</a> *op, void *user_data)</td></tr>
<tr class="memdesc:ga45a3b1982ef4158fb5b6298ef7be5c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator cleanup method.  <a href="group__ai__operator.html#ga45a3b1982ef4158fb5b6298ef7be5c28">More...</a><br /></td></tr>
<tr class="separator:ga45a3b1982ef4158fb5b6298ef7be5c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc58492255b0e29d69b74e3f05cbff82"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#gabc58492255b0e29d69b74e3f05cbff82">AtOpCook</a>) (<a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtNode.html">AtNode</a> *op, void *child_data, void *user_data, const AtArray *matching_params, AtCookContext *cook_context)</td></tr>
<tr class="memdesc:gabc58492255b0e29d69b74e3f05cbff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator cook method which operates on the cooked node.  <a href="group__ai__operator.html#gabc58492255b0e29d69b74e3f05cbff82">More...</a><br /></td></tr>
<tr class="separator:gabc58492255b0e29d69b74e3f05cbff82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga641798d483bf9be2b3e7703a0577afbd"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga641798d483bf9be2b3e7703a0577afbd">AtOpPostCook</a>) (<a class="el" href="structAtNode.html">AtNode</a> *op, void *user_data)</td></tr>
<tr class="memdesc:ga641798d483bf9be2b3e7703a0577afbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator post cook method which is called once per operator instance after all the cook calls for all operators are finished.  <a href="group__ai__operator.html#ga641798d483bf9be2b3e7703a0577afbd">More...</a><br /></td></tr>
<tr class="separator:ga641798d483bf9be2b3e7703a0577afbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adb855809efc7977e2ac9a445cd7d97"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga2adb855809efc7977e2ac9a445cd7d97">AtOpFuncPtr</a>) (<a class="el" href="structAtOperatorNodeMethods.html">AtOperatorNodeMethods</a> *methods)</td></tr>
<tr class="memdesc:ga2adb855809efc7977e2ac9a445cd7d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator function pointer entry-point symbol.  <a href="group__ai__operator.html#ga2adb855809efc7977e2ac9a445cd7d97">More...</a><br /></td></tr>
<tr class="separator:ga2adb855809efc7977e2ac9a445cd7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga84a7a21c7fe46df4eb73423b840ceabd"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga84a7a21c7fe46df4eb73423b840ceabd">AiOpSetTarget</a> (<a class="el" href="structAtUniverse.html">AtUniverse</a> *universe, <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga84a7a21c7fe46df4eb73423b840ceabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target operator in a given Arnold universe.  <a href="group__ai__operator.html#ga84a7a21c7fe46df4eb73423b840ceabd">More...</a><br /></td></tr>
<tr class="separator:ga84a7a21c7fe46df4eb73423b840ceabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea869c6433dc9d18ea7b9e77cbf7588"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#gaeea869c6433dc9d18ea7b9e77cbf7588">AiOpGetTarget</a> (const <a class="el" href="structAtUniverse.html">AtUniverse</a> *universe)</td></tr>
<tr class="memdesc:gaeea869c6433dc9d18ea7b9e77cbf7588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target operator node in a given universe, if any.  <a href="group__ai__operator.html#gaeea869c6433dc9d18ea7b9e77cbf7588">More...</a><br /></td></tr>
<tr class="separator:gaeea869c6433dc9d18ea7b9e77cbf7588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1cbc9127267e151bea542d7a393ab7"><td class="memItemLeft" align="right" valign="top">AI_API AtArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga2d1cbc9127267e151bea542d7a393ab7">AiOpGetInputs</a> (<a class="el" href="structAtNode.html">AtNode</a> *op)</td></tr>
<tr class="memdesc:ga2d1cbc9127267e151bea542d7a393ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get operator nodes connected to the inputs on a given operator node.  <a href="group__ai__operator.html#ga2d1cbc9127267e151bea542d7a393ab7">More...</a><br /></td></tr>
<tr class="separator:ga2d1cbc9127267e151bea542d7a393ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bf237afde8172f87583bb7311c9865"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga49bf237afde8172f87583bb7311c9865">AiOpLink</a> (<a class="el" href="structAtNode.html">AtNode</a> *from, <a class="el" href="structAtNode.html">AtNode</a> *to, int index=-1)</td></tr>
<tr class="memdesc:ga49bf237afde8172f87583bb7311c9865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect an operator to a given input index on an operator.  <a href="group__ai__operator.html#ga49bf237afde8172f87583bb7311c9865">More...</a><br /></td></tr>
<tr class="separator:ga49bf237afde8172f87583bb7311c9865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04265c50a6bb01247e5d0e4dba85c81b"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga04265c50a6bb01247e5d0e4dba85c81b">AiOpUnlinkInputByIndex</a> (<a class="el" href="structAtNode.html">AtNode</a> *to, unsigned int index)</td></tr>
<tr class="memdesc:ga04265c50a6bb01247e5d0e4dba85c81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink an input connection on an operator for a given index.  <a href="group__ai__operator.html#ga04265c50a6bb01247e5d0e4dba85c81b">More...</a><br /></td></tr>
<tr class="separator:ga04265c50a6bb01247e5d0e4dba85c81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf01e647ea60710aef014a585081723"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#gafaf01e647ea60710aef014a585081723">AiOpUnlink</a> (<a class="el" href="structAtNode.html">AtNode</a> *from, <a class="el" href="structAtNode.html">AtNode</a> *to)</td></tr>
<tr class="memdesc:gafaf01e647ea60710aef014a585081723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink connected operators.  <a href="group__ai__operator.html#gafaf01e647ea60710aef014a585081723">More...</a><br /></td></tr>
<tr class="separator:gafaf01e647ea60710aef014a585081723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54db98694025c14b884e83d878b5c618"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga54db98694025c14b884e83d878b5c618">AiOpSetChildData</a> (<a class="el" href="structAtNode.html">AtNode</a> *op, void *child_data=NULL, AtOpCleanupChildData cleanup=NULL)</td></tr>
<tr class="memdesc:ga54db98694025c14b884e83d878b5c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set child data on an operator.  <a href="group__ai__operator.html#ga54db98694025c14b884e83d878b5c618">More...</a><br /></td></tr>
<tr class="separator:ga54db98694025c14b884e83d878b5c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed2726c32c211243b86c548816a56d6"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga5ed2726c32c211243b86c548816a56d6">AiOpMatchNodeSelection</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="classAtString.html">AtString</a> selection, bool relative=true, <a class="el" href="structAtNode.html">AtNode</a> *target=NULL)</td></tr>
<tr class="memdesc:ga5ed2726c32c211243b86c548816a56d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a node, including its name and parameters, match a given selection expression.  <a href="group__ai__operator.html#ga5ed2726c32c211243b86c548816a56d6">More...</a><br /></td></tr>
<tr class="separator:ga5ed2726c32c211243b86c548816a56d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603a27d1d77dd1b567ca72297ce49048"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__operator.html#ga603a27d1d77dd1b567ca72297ce49048">AiOpCookContextGetCookScope</a> (AtCookContext *cook_context)</td></tr>
<tr class="memdesc:ga603a27d1d77dd1b567ca72297ce49048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cook scope which is represented by the node that the operator graph is connected to.  <a href="group__ai__operator.html#ga603a27d1d77dd1b567ca72297ce49048">More...</a><br /></td></tr>
<tr class="separator:ga603a27d1d77dd1b567ca72297ce49048"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac4f0d23f8595c3f81521c2f3bc25e36f"><td class="memItemLeft" align="right" valign="top"><a id="gac4f0d23f8595c3f81521c2f3bc25e36f" name="gac4f0d23f8595c3f81521c2f3bc25e36f"></a>
<a class="el" href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">AtOpInit</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtOperatorNodeMethods::Init</b></td></tr>
<tr class="separator:gac4f0d23f8595c3f81521c2f3bc25e36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631a932941247ffe9353d6f5a38ed13a"><td class="memItemLeft" align="right" valign="top"><a id="ga631a932941247ffe9353d6f5a38ed13a" name="ga631a932941247ffe9353d6f5a38ed13a"></a>
<a class="el" href="group__ai__operator.html#ga45a3b1982ef4158fb5b6298ef7be5c28">AtOpCleanup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtOperatorNodeMethods::Cleanup</b></td></tr>
<tr class="separator:ga631a932941247ffe9353d6f5a38ed13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad68d1ff224cac2ca92dae38190d3e9f7"><td class="memItemLeft" align="right" valign="top"><a id="gad68d1ff224cac2ca92dae38190d3e9f7" name="gad68d1ff224cac2ca92dae38190d3e9f7"></a>
<a class="el" href="group__ai__operator.html#gabc58492255b0e29d69b74e3f05cbff82">AtOpCook</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtOperatorNodeMethods::Cook</b></td></tr>
<tr class="separator:gad68d1ff224cac2ca92dae38190d3e9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8699cffeb5848877c97c5565465a4b7"><td class="memItemLeft" align="right" valign="top"><a id="gab8699cffeb5848877c97c5565465a4b7" name="gab8699cffeb5848877c97c5565465a4b7"></a>
<a class="el" href="group__ai__operator.html#ga641798d483bf9be2b3e7703a0577afbd">AtOpPostCook</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtOperatorNodeMethods::PostCook</b></td></tr>
<tr class="separator:gab8699cffeb5848877c97c5565465a4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Operator node creation and operation. </p>
<p >This API is used to create graphs of operator nodes which can procedurally perform scene inspection, creation, and late binding modifications at render time.</p>
<p >The operator graph defines a non-destructive set of operations, where the graph is evaluated from a given node in the graph, denoted as target operator. The target operator is defined in the options and can be set using <a class="el" href="group__ai__operator.html#ga84a7a21c7fe46df4eb73423b840ceabd">AiOpSetTarget</a>. Any graphs not connected to the target operator will be ignored.</p>
<p >An operator that is connected to the target will be initialized and cooked if it needs to do any work. That is determined based on the presence of a selection parameter and if the operator is enabled. An enabled operator without a selection will always be initialized and cooked at least once, otherwise it's only initialized and cooked if the selection expression matches one or more nodes in the scene.</p>
<p >Operators can recursively create other operator nodes and optionally pass child data to them (see <a class="el" href="group__ai__operator.html#ga54db98694025c14b884e83d878b5c618">AiOpSetChildData</a>. Operators can also declare their own user data, where it is initialized/used in <a class="el" href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">AtOpInit</a>, used in <a class="el" href="group__ai__operator.html#gabc58492255b0e29d69b74e3f05cbff82">AtOpCook</a>, and deleted in <a class="el" href="group__ai__operator.html#ga45a3b1982ef4158fb5b6298ef7be5c28">AtOpCleanup</a>. Note that no information flows through the graph.</p>
<p >Operators are evaluated during the pre-render initialization process which is done in parallel. It is therefore important that the code in an operator node is designed to be re-entrant. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga54e38409d64eeae666b75a67d52a8984" name="ga54e38409d64eeae666b75a67d52a8984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e38409d64eeae666b75a67d52a8984">&#9670;&nbsp;</a></span>AI_OPERATOR_COMMON_NODE_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_OPERATOR_COMMON_NODE_METHODS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a>;                                \</div>
<div class="line">static <a class="code hl_struct" href="structAtCommonMethods.html">AtCommonMethods</a> ai_common_mtds = {       \</div>
<div class="line">   NULL,                                        \</div>
<div class="line">   NULL,                                        \</div>
<div class="line">   Parameters,                                  \</div>
<div class="line">   NULL,                                        \</div>
<div class="line">   NULL,                                        \</div>
<div class="line">   NULL                                         \</div>
<div class="line">};</div>
<div class="ttc" id="agroup__ai__nodes_html_gadec5d9ecd55d964c1a30151fffa8e575"><div class="ttname"><a href="group__ai__nodes.html#gadec5d9ecd55d964c1a30151fffa8e575">node_parameters</a></div><div class="ttdeci">#define node_parameters</div><div class="ttdoc">Parameter declaration method.</div><div class="ttdef"><b>Definition:</b> ai_nodes.h:72</div></div>
<div class="ttc" id="astructAtCommonMethods_html"><div class="ttname"><a href="structAtCommonMethods.html">AtCommonMethods</a></div><div class="ttdoc">Methods common to all nodes.</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:73</div></div>
</div><!-- fragment -->
<p>Exporter for the methods shared with the standard node interface. </p>

</div>
</div>
<a id="ga82b3f3e19f9bce56aa89454a8d96c8fa" name="ga82b3f3e19f9bce56aa89454a8d96c8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82b3f3e19f9bce56aa89454a8d96c8fa">&#9670;&nbsp;</a></span>AI_OPERATOR_NODE_EXPORT_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_OPERATOR_NODE_EXPORT_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">AI_OPERATOR_COMMON_NODE_METHODS                 \</div>
<div class="line">operator_init;                                  \</div>
<div class="line">operator_cleanup;                               \</div>
<div class="line">operator_cook;                                  \</div>
<div class="line">operator_post_cook;                             \</div>
<div class="line">static <a class="code hl_struct" href="structAtOperatorNodeMethods.html">AtOperatorNodeMethods</a> ai_op_mtds = {     \</div>
<div class="line">   OperatorInit,                                \</div>
<div class="line">   OperatorCleanup,                             \</div>
<div class="line">   OperatorCook,                                \</div>
<div class="line">   OperatorPostCook                             \</div>
<div class="line">};                                              \</div>
<div class="line">static <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_mtds = {           \</div>
<div class="line">   &amp;ai_common_mtds,                             \</div>
<div class="line">   &amp;ai_op_mtds                                  \</div>
<div class="line">};                                              \</div>
<div class="line">const <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a>* tag = &amp;ai_node_mtds;</div>
<div class="ttc" id="astructAtNodeMethods_html"><div class="ttname"><a href="structAtNodeMethods.html">AtNodeMethods</a></div><div class="ttdoc">Node methods.</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:86</div></div>
<div class="ttc" id="astructAtOperatorNodeMethods_html"><div class="ttname"><a href="structAtOperatorNodeMethods.html">AtOperatorNodeMethods</a></div><div class="ttdoc">Cleanup method for child data which is passed to other operators.</div><div class="ttdef"><b>Definition:</b> ai_operator.h:157</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga420a026c2acd88ff0ef3c29c77f81f40" name="ga420a026c2acd88ff0ef3c29c77f81f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420a026c2acd88ff0ef3c29c77f81f40">&#9670;&nbsp;</a></span>AI_OPERATOR_NODE_INTERNAL_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_OPERATOR_NODE_INTERNAL_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">AI_INSTANCE_COMMON_METHODS                      \</div>
<div class="line">static <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_internal_mtds = {  \</div>
<div class="line">   &amp;ai_common_mtds,                             \</div>
<div class="line">   NULL                                         \</div>
<div class="line">};                                              \</div>
<div class="line">const <a class="code hl_struct" href="structAtNodeMethods.html">AtNodeMethods</a>* tag = &amp;ai_node_internal_mtds;</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga04d0c136d042535d8f1fb90ba2b42692" name="ga04d0c136d042535d8f1fb90ba2b42692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04d0c136d042535d8f1fb90ba2b42692">&#9670;&nbsp;</a></span>AtOpInit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtOpInit) (<a class="el" href="structAtNode.html">AtNode</a> *op, void **user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator init method. </p>
<p >This method will be called first if the operator needs to do any work to perform any initialization required by the operator.</p>
<p >The operator is only initialized once in a batch session but in an IPR session this method is called every time the operator is dirtied. This method may be called concurrently with other uses of the same operator plugin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator node (itself) </td></tr>
    <tr><td class="paramname">user_data</td><td>general-purpose, user-supplied data pointer that Arnold will pass along to the other operator methods </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

</div>
</div>
<a id="ga45a3b1982ef4158fb5b6298ef7be5c28" name="ga45a3b1982ef4158fb5b6298ef7be5c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a3b1982ef4158fb5b6298ef7be5c28">&#9670;&nbsp;</a></span>AtOpCleanup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtOpCleanup) (<a class="el" href="structAtNode.html">AtNode</a> *op, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator cleanup method. </p>
<p >This method is called if the operator node is deleted or if the render session has finished, where it should perform any cleanup required by the operator. Make sure to release any memory you allocated that is no longer needed by Arnold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator node (itself) </td></tr>
    <tr><td class="paramname">user_data</td><td>general-purpose, user-supplied data pointer as returned from <a class="el" href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">AtOpInit</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

</div>
</div>
<a id="gabc58492255b0e29d69b74e3f05cbff82" name="gabc58492255b0e29d69b74e3f05cbff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc58492255b0e29d69b74e3f05cbff82">&#9670;&nbsp;</a></span>AtOpCook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtOpCook) (<a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtNode.html">AtNode</a> *op, void *child_data, void *user_data, const AtArray *matching_params, AtCookContext *cook_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator cook method which operates on the cooked node. </p>
<p >The cooked node is either the operator itself (no selection parameter), or any node in the scene which matches the selection expression.</p>
<p >Therefore, this method is called one or more times if the operator needs to do any work, depending on how many nodes it has to operate on. The operator may cook multiple nodes concurrently.</p>
<p >This method may have access to user data and child data when cooking. The user data is a general-purpose pointer that is used by this operator and is initialized and cleaned up as part of the operator's life cycle. The child data is a general-purpose pointer that can be passed to an operator after creating it, where the cleanup method provided is called when the child data is cleaned up (see AtOpCleanupChildData).</p>
<p >Selection expressions support wildcards when matching parameter names and selections can match multiple parameters. The matched parameter names are accessible to allow customizing the operator's behavior based on the matched parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node being cooked </td></tr>
    <tr><td class="paramname">op</td><td>operator node (itself) </td></tr>
    <tr><td class="paramname">child_data</td><td>general-purpose data pointer that may be passed here by the operator's creator </td></tr>
    <tr><td class="paramname">user_data</td><td>general-purpose, user-supplied data pointer as returned from <a class="el" href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">AtOpInit</a>. </td></tr>
    <tr><td class="paramname">matching_params</td><td>names of parameters that matched the selection expression </td></tr>
    <tr><td class="paramname">cook_context</td><td>context specific information about the cook (see e.g. AtOpCookContextGetCookReference) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

</div>
</div>
<a id="ga641798d483bf9be2b3e7703a0577afbd" name="ga641798d483bf9be2b3e7703a0577afbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga641798d483bf9be2b3e7703a0577afbd">&#9670;&nbsp;</a></span>AtOpPostCook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtOpPostCook) (<a class="el" href="structAtNode.html">AtNode</a> *op, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator post cook method which is called once per operator instance after all the cook calls for all operators are finished. </p>
<p >The method is only called if an operator was cooked by being part of a graph that was connected to the options or a procedural.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator node (itself) </td></tr>
    <tr><td class="paramname">user_data</td><td>general-purpose, user-supplied data pointer as returned from <a class="el" href="group__ai__operator.html#ga04d0c136d042535d8f1fb90ba2b42692">AtOpInit</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

</div>
</div>
<a id="ga2adb855809efc7977e2ac9a445cd7d97" name="ga2adb855809efc7977e2ac9a445cd7d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2adb855809efc7977e2ac9a445cd7d97">&#9670;&nbsp;</a></span>AtOpFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtOpFuncPtr) (<a class="el" href="structAtOperatorNodeMethods.html">AtOperatorNodeMethods</a> *methods)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator function pointer entry-point symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">methods</td><td>List of operator methods </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga84a7a21c7fe46df4eb73423b840ceabd" name="ga84a7a21c7fe46df4eb73423b840ceabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84a7a21c7fe46df4eb73423b840ceabd">&#9670;&nbsp;</a></span>AiOpSetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiOpSetTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target operator in a given Arnold universe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe where the target operator is set (NULL for default universe) </td></tr>
    <tr><td class="paramname">node</td><td>pointer to the node used as a target operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeea869c6433dc9d18ea7b9e77cbf7588" name="gaeea869c6433dc9d18ea7b9e77cbf7588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeea869c6433dc9d18ea7b9e77cbf7588">&#9670;&nbsp;</a></span>AiOpGetTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiOpGetTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtUniverse.html">AtUniverse</a> *&#160;</td>
          <td class="paramname"><em>universe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target operator node in a given universe, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">universe</td><td>universe to get the target operator from (NULL for default universe) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the target operator node if it's defined, NULL otherwise </dd></dl>

</div>
</div>
<a id="ga2d1cbc9127267e151bea542d7a393ab7" name="ga2d1cbc9127267e151bea542d7a393ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d1cbc9127267e151bea542d7a393ab7">&#9670;&nbsp;</a></span>AiOpGetInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtArray * AiOpGetInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get operator nodes connected to the inputs on a given operator node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of operator nodes which are connected as inputs on the operator node </dd></dl>

</div>
</div>
<a id="ga49bf237afde8172f87583bb7311c9865" name="ga49bf237afde8172f87583bb7311c9865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49bf237afde8172f87583bb7311c9865">&#9670;&nbsp;</a></span>AiOpLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiOpLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect an operator to a given input index on an operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>operator node whose output connects to an input on the 'to' operator </td></tr>
    <tr><td class="paramname">to</td><td>operator node whose input is connected to </td></tr>
    <tr><td class="paramname">index</td><td>input index if defined, otherwise a new input is appended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the operator nodes were successfully linked, false otherwise </dd></dl>

</div>
</div>
<a id="ga04265c50a6bb01247e5d0e4dba85c81b" name="ga04265c50a6bb01247e5d0e4dba85c81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04265c50a6bb01247e5d0e4dba85c81b">&#9670;&nbsp;</a></span>AiOpUnlinkInputByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiOpUnlinkInputByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink an input connection on an operator for a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator node </td></tr>
    <tr><td class="paramname">index</td><td>input index to unlink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was successfully unlinked, false otherwise </dd></dl>

</div>
</div>
<a id="gafaf01e647ea60710aef014a585081723" name="gafaf01e647ea60710aef014a585081723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf01e647ea60710aef014a585081723">&#9670;&nbsp;</a></span>AiOpUnlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiOpUnlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink connected operators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>operator node whose output connects to an input on the 'to' operator </td></tr>
    <tr><td class="paramname">to</td><td>operator node whose input is connected to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the connection was successfully unlinked, false otherwise </dd></dl>

</div>
</div>
<a id="ga54db98694025c14b884e83d878b5c618" name="ga54db98694025c14b884e83d878b5c618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54db98694025c14b884e83d878b5c618">&#9670;&nbsp;</a></span>AiOpSetChildData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiOpSetChildData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtOpCleanupChildData&#160;</td>
          <td class="paramname"><em>cleanup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set child data on an operator. </p>
<p >This is typically done when an operator creates another operator and wants to pass certain information to it. The lifetime of the operator that created the data might differ from the child data so a corresponding cleanup function for the data is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator node receiving the child data </td></tr>
    <tr><td class="paramname">child_data</td><td>data that should be passed to the operator </td></tr>
    <tr><td class="paramname">AtOpCleanupChildData</td><td>function pointer to clean up the child data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ed2726c32c211243b86c548816a56d6" name="ga5ed2726c32c211243b86c548816a56d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed2726c32c211243b86c548816a56d6">&#9670;&nbsp;</a></span>AiOpMatchNodeSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiOpMatchNodeSelection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>selection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a node, including its name and parameters, match a given selection expression. </p>
<p >If a target operator node is specified then the operator and any upstream operators are processed when aggregating relevant graph information used for matching such as collections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node that is matched against a selection </td></tr>
    <tr><td class="paramname">selection</td><td>selection expression used to match </td></tr>
    <tr><td class="paramname">relative</td><td>if true the selection is assumed to be relative to the node's parent, if any </td></tr>
    <tr><td class="paramname">target</td><td>optional target operator node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node matches the selection expression, false otherwise </dd></dl>

</div>
</div>
<a id="ga603a27d1d77dd1b567ca72297ce49048" name="ga603a27d1d77dd1b567ca72297ce49048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603a27d1d77dd1b567ca72297ce49048">&#9670;&nbsp;</a></span>AiOpCookContextGetCookScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a> * AiOpCookContextGetCookScope </td>
          <td>(</td>
          <td class="paramtype">AtCookContext *&#160;</td>
          <td class="paramname"><em>cook_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cook scope which is represented by the node that the operator graph is connected to. </p>
<p >If the operator is cooked as part of a graph that is connected to the options node then the scope is global and this function returns null. However, if the operator graph is connected to a procedural then the scope is locally relative to it, where the procedural node is returned.</p>
<p >This allows an operator to behave differently depending on what the expected scope is, which is determined by what graph the operator find itself in. The same operator instance can be used by different graphs, where each graph can be connected to different nodes which have an operator input. Therefore, the scope for the an operator instance can vary between cooks.</p>
<dl class="section return"><dt>Returns</dt><dd>the node that the current cook scope is relative to, null if the scope is global </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
