#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class ArnoldUsdLuxLightFilter "ArnoldUsdLuxLightFilter"
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class ArnoldNodeGraph "ArnoldNodeGraph"
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "ArnoldCameraAPI"
{
    float primvars:arnold:exposure = 0
    string primvars:arnold:filtermap = ""
    token primvars:arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] primvars:arnold:look_at
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    token primvars:arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float primvars:arnold:rolling_shutter_duration = 0
    float2[] primvars:arnold:screen_window_max
    float2[] primvars:arnold:screen_window_min
    float2[] primvars:arnold:shutter_curve
    token primvars:arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] primvars:arnold:up
}

class "ArnoldLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldShapeAPI"
{
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shader
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class "ArnoldColorManagerAPI"
{
    string primvars:arnold:color_space_linear = ""
    string primvars:arnold:color_space_narrow = ""
    asset primvars:arnold:config = @@
    bool primvars:arnold:ignore_environment_variable = 0
    float[] primvars:arnold:linear_chromaticities
}

class "ArnoldOptionsAPI"
{
    float primvars:arnold:AA_adaptive_threshold = 0.015
    float primvars:arnold:AA_sample_clamp = 1e30
    bool primvars:arnold:AA_sample_clamp_affects_aovs = 0
    int primvars:arnold:AA_samples = 1
    int primvars:arnold:AA_samples_max = 20
    int primvars:arnold:AA_seed = 1
    bool primvars:arnold:abort_on_error = 1
    bool primvars:arnold:abort_on_license_fail = 1
    string[] primvars:arnold:aov_shaders
    string primvars:arnold:atmosphere = ""
    int primvars:arnold:auto_transparency_depth = 10
    string primvars:arnold:background = ""
    uchar primvars:arnold:background_visibility = 255
    token primvars:arnold:bucket_scanning = "spiral" (
        allowedTokens = ["top", "left", "random", "spiral", "hilbert", "list"]
    )
    int primvars:arnold:bucket_size = 64
    float2[] primvars:arnold:buckets
    string primvars:arnold:color_manager = ""
    bool primvars:arnold:curves_rr_aggressive = 1
    int primvars:arnold:curves_rr_start_depth = 0
    bool primvars:arnold:dielectric_priorities = 1
    bool primvars:arnold:enable_adaptive_sampling = 0
    bool primvars:arnold:enable_dependency_graph = 0
    bool primvars:arnold:enable_deprecated_hair_absorption = 0
    bool primvars:arnold:enable_fast_ipr = 1
    bool primvars:arnold:enable_microfacet_multiscatter = 1
    bool primvars:arnold:enable_new_point_light_sampler = 1
    bool primvars:arnold:enable_new_quad_light_sampler = 1
    bool primvars:arnold:enable_procedural_cache = 1
    bool primvars:arnold:enable_progressive_render = 0
    color3f primvars:arnold:error_color_bad_pixel = (0, 0, 1)
    color3f primvars:arnold:error_color_bad_shader = (1, 0, 1)
    color3f primvars:arnold:error_color_bad_texture = (1, 0, 0)
    token primvars:arnold:fis_filter = "none" (
        allowedTokens = ["none", "triangle", "blackman_harris", "gaussian"]
    )
    float primvars:arnold:fis_filter_width = 3
    bool primvars:arnold:force_non_progressive_sampling = 0
    float primvars:arnold:fps = 24
    float primvars:arnold:frame = 0
    int primvars:arnold:GI_diffuse_depth = 0
    int primvars:arnold:GI_diffuse_samples = 2
    int primvars:arnold:GI_specular_depth = 0
    int primvars:arnold:GI_specular_samples = 2
    int primvars:arnold:GI_sss_samples = 2
    int primvars:arnold:GI_total_depth = 10
    int primvars:arnold:GI_transmission_depth = 2
    int primvars:arnold:GI_transmission_samples = 2
    int primvars:arnold:GI_volume_depth = 0
    int primvars:arnold:GI_volume_samples = 2
    bool primvars:arnold:GLS_glossy_enable = 1
    int primvars:arnold:gpu_default_min_memory_MB = 512
    string primvars:arnold:gpu_default_names = "*"
    int primvars:arnold:gpu_max_texture_resolution = 0
    bool primvars:arnold:ignore_atmosphere = 0
    bool primvars:arnold:ignore_bump = 0
    bool primvars:arnold:ignore_displacement = 0
    bool primvars:arnold:ignore_dof = 0
    bool primvars:arnold:ignore_imagers = 0
    bool primvars:arnold:ignore_lights = 0
    string[] primvars:arnold:ignore_list
    bool primvars:arnold:ignore_motion = 0
    bool primvars:arnold:ignore_motion_blur = 0
    bool primvars:arnold:ignore_operators = 0
    bool primvars:arnold:ignore_shaders = 0
    bool primvars:arnold:ignore_shadows = 0
    bool primvars:arnold:ignore_smoothing = 0
    bool primvars:arnold:ignore_sss = 0
    bool primvars:arnold:ignore_subdivision = 0
    bool primvars:arnold:ignore_textures = 0
    float primvars:arnold:imager_overhead_target_percent = 1
    float primvars:arnold:indirect_sample_clamp = 10
    float primvars:arnold:indirect_specular_blur = 1
    string[] primvars:arnold:light_path_expressions
    int primvars:arnold:light_samples = 0
    float primvars:arnold:low_light_threshold = 0.001
    float primvars:arnold:luminaire_bias = 0.000001
    uchar primvars:arnold:max_subdivisions = 255
    float primvars:arnold:meters_per_unit = 1
    float primvars:arnold:nits_per_unit = 1000
    string primvars:arnold:operator = ""
    string primvars:arnold:osl_includepath = ""
    string[] primvars:arnold:outputs
    bool primvars:arnold:parallel_node_init = 1
    float primvars:arnold:pixel_aspect_ratio = 1
    string primvars:arnold:plugin_searchpath = ""
    bool primvars:arnold:procedural_auto_instancing = 1
    token primvars:arnold:procedural_instancing_optimization = "conservative" (
        allowedTokens = ["none", "conservative", "exhaustive"]
    )
    string primvars:arnold:procedural_searchpath = ""
    float primvars:arnold:reference_time = 0
    int primvars:arnold:region_max_x = -2147483648
    int primvars:arnold:region_max_y = -2147483648
    int primvars:arnold:region_min_x = -2147483648
    int primvars:arnold:region_min_y = -2147483648
    token primvars:arnold:render_device = "CPU" (
        allowedTokens = ["CPU", "GPU"]
    )
    token primvars:arnold:render_device_fallback = "error" (
        allowedTokens = ["error", "CPU"]
    )
    string primvars:arnold:scene_units_name = ""
    string primvars:arnold:shader_override = ""
    bool primvars:arnold:skip_background_atmosphere = 0
    bool primvars:arnold:skip_license_check = 0
    bool primvars:arnold:stochastic_volume_interpolation = 1
    string primvars:arnold:subdiv_dicing_camera = ""
    bool primvars:arnold:subdiv_frustum_culling = 0
    float primvars:arnold:subdiv_frustum_padding = 0
    bool primvars:arnold:texture_accept_unmipped = 1
    bool primvars:arnold:texture_accept_untiled = 1
    bool primvars:arnold:texture_auto_generate_tx = 1
    string primvars:arnold:texture_auto_tx_path = ""
    bool primvars:arnold:texture_automip = 1
    int primvars:arnold:texture_autotile = 0
    bool primvars:arnold:texture_conservative_lookups = 1
    int primvars:arnold:texture_failure_retries = 0
    float primvars:arnold:texture_max_memory_MB = 4096
    int primvars:arnold:texture_max_open_files = 0
    float primvars:arnold:texture_max_sharpen = 1.5
    bool primvars:arnold:texture_per_file_stats = 0
    string primvars:arnold:texture_searchpath = ""
    bool primvars:arnold:texture_use_existing_tx = 1
    token primvars:arnold:thread_priority = "low" (
        allowedTokens = ["lowest", "low", "normal", "high"]
    )
    int primvars:arnold:threads = 0
    bool primvars:arnold:usd_legacy_distant_light_normalize = 0
    bool primvars:arnold:usd_legacy_translation = 0
}

class "ArnoldPerspCameraAPI"
{
    float primvars:arnold:aperture_aspect_ratio = 1
    float primvars:arnold:aperture_blade_curvature = 0
    int primvars:arnold:aperture_blades = 0
    float primvars:arnold:aperture_rotation = 0
    float[] primvars:arnold:aperture_size
    float primvars:arnold:exposure = 0
    string primvars:arnold:filtermap = ""
    bool primvars:arnold:flat_field_focus = 1
    float[] primvars:arnold:fov
    token primvars:arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float2[] primvars:arnold:lens_shift
    float2[] primvars:arnold:lens_tilt_angle
    vector3f[] primvars:arnold:look_at
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:plane_distance = 1
    vector3f[] primvars:arnold:position
    float primvars:arnold:radial_distortion = 0
    token primvars:arnold:radial_distortion_type = "cubic" (
        allowedTokens = ["cubic", "cubic_inverse"]
    )
    token primvars:arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float primvars:arnold:rolling_shutter_duration = 0
    float2[] primvars:arnold:screen_window_max
    float2[] primvars:arnold:screen_window_min
    float2[] primvars:arnold:shutter_curve
    token primvars:arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] primvars:arnold:up
    color4f primvars:arnold:uv_remap = (0, 0, 0, 0)
}

class "ArnoldOrthoCameraAPI"
{
    float primvars:arnold:exposure = 0
    string primvars:arnold:filtermap = ""
    token primvars:arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] primvars:arnold:look_at
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    token primvars:arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float primvars:arnold:rolling_shutter_duration = 0
    float2[] primvars:arnold:screen_window_max
    float2[] primvars:arnold:screen_window_min
    float2[] primvars:arnold:shutter_curve
    token primvars:arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] primvars:arnold:up
}

class "ArnoldPointLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldDistantLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    vector3f[] primvars:arnold:direction
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldQuadLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:portal = 0
    int primvars:arnold:resolution = 512
    float primvars:arnold:roundness = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:soft_edge = 0
    float primvars:arnold:spread = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldSkydomeLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:aov_indirect = 0
    float primvars:arnold:camera = 1
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    token primvars:arnold:portal_mode = "interior_only" (
        allowedTokens = ["off", "interior_only", "interior_exterior"]
    )
    int primvars:arnold:resolution = 1000
    int primvars:arnold:samples = 1
    string primvars:arnold:shader = ""
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldDiskLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    vector3f[] primvars:arnold:direction
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:spread = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldMeshLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldSphereAPI"
{
    vector3f[] primvars:arnold:center
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class "ArnoldCylinderAPI"
{
    float primvars:arnold:bevel_angle = 0.5
    float primvars:arnold:bevel_width = 0
    vector3f primvars:arnold:bottom = (0, 0, -0.5)
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    vector3f primvars:arnold:top = (0, 0, 0.5)
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class "ArnoldConeAPI"
{
    vector3f primvars:arnold:bottom = (0, 0, -0.5)
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    vector3f primvars:arnold:top = (0, 0, 0.5)
    float primvars:arnold:top_radius = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class "ArnoldPolymeshAPI"
{
    uchar primvars:arnold:autobump_visibility = 1
    uint[] primvars:arnold:crease_idxs
    float[] primvars:arnold:crease_sharpness
    bool primvars:arnold:disp_autobump = 0
    float primvars:arnold:disp_height = 1
    string[] primvars:arnold:disp_map
    float primvars:arnold:disp_padding = 0
    float primvars:arnold:disp_zero_value = 0
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:nlist
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar[] primvars:arnold:shidxs
    uchar primvars:arnold:sidedness = 255
    bool primvars:arnold:smoothing = 1
    float primvars:arnold:step_size = 0
    float primvars:arnold:subdiv_adaptive_error = 0
    token primvars:arnold:subdiv_adaptive_metric = "metric_auto" (
        allowedTokens = ["metric_auto", "edge_length", "flatness"]
    )
    token primvars:arnold:subdiv_adaptive_space = "raster" (
        allowedTokens = ["raster", "object"]
    )
    bool primvars:arnold:subdiv_frustum_ignore = 0
    uchar primvars:arnold:subdiv_iterations = 1
    bool primvars:arnold:subdiv_smooth_derivs = 0
    token primvars:arnold:subdiv_type = "none" (
        allowedTokens = ["none", "catclark", "linear"]
    )
    token primvars:arnold:subdiv_uv_smoothing = "pin_corners" (
        allowedTokens = ["pin_corners", "pin_borders", "linear", "smooth"]
    )
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uint[] primvars:arnold:uvidxs
    float2[] primvars:arnold:uvlist
    uchar primvars:arnold:visibility = 255
    vector3f[] primvars:arnold:vlist
    float primvars:arnold:volume_padding = 0
}

class "ArnoldBoxAPI"
{
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class "ArnoldCurvesAPI"
{
    token primvars:arnold:basis = "bezier" (
        allowedTokens = ["bezier", "b-spline", "catmull-rom", "linear"]
    )
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:min_pixel_width = 0
    token primvars:arnold:mode = "ribbon" (
        allowedTokens = ["ribbon", "thick", "oriented"]
    )
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    vector3f[] primvars:arnold:orientations
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar[] primvars:arnold:shidxs
    uchar primvars:arnold:sidedness = 255
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    float2[] primvars:arnold:uvs
    uchar primvars:arnold:visibility = 255
    token primvars:arnold:wrap_mode = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
    )
}

class "ArnoldPointsAPI"
{
    float[] primvars:arnold:aspect
    string primvars:arnold:file_attribute_point = ""
    string primvars:arnold:file_attribute_radius = ""
    string primvars:arnold:file_attribute_velocity = ""
    bool primvars:arnold:file_compress = 1
    uchar[] primvars:arnold:file_data
    string primvars:arnold:file_grid = ""
    asset primvars:arnold:file_name = @@
    float primvars:arnold:file_velocity_fps = 24
    float primvars:arnold:file_velocity_scale = 1
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:min_pixel_width = 0
    token primvars:arnold:mode = "disk" (
        allowedTokens = ["disk", "sphere", "quad"]
    )
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    float[] primvars:arnold:rotation
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldOptions "ArnoldOptions"
{
    float arnold:AA_adaptive_threshold = 0.015
    float arnold:AA_sample_clamp = 1e30
    bool arnold:AA_sample_clamp_affects_aovs = 0
    int arnold:AA_samples = 1
    int arnold:AA_samples_max = 20
    int arnold:AA_seed = 1
    bool arnold:abort_on_error = 1
    bool arnold:abort_on_license_fail = 1
    string[] arnold:aov_shaders
    string arnold:atmosphere = ""
    int arnold:auto_transparency_depth = 10
    string arnold:background = ""
    uchar arnold:background_visibility = 255
    token arnold:bucket_scanning = "spiral" (
        allowedTokens = ["top", "left", "random", "spiral", "hilbert", "list"]
    )
    int arnold:bucket_size = 64
    float2[] arnold:buckets
    string arnold:camera = ""
    string arnold:color_manager = ""
    bool arnold:curves_rr_aggressive = 1
    int arnold:curves_rr_start_depth = 0
    bool arnold:dielectric_priorities = 1
    bool arnold:enable_adaptive_sampling = 0
    bool arnold:enable_dependency_graph = 0
    bool arnold:enable_deprecated_hair_absorption = 0
    bool arnold:enable_fast_ipr = 1
    bool arnold:enable_microfacet_multiscatter = 1
    bool arnold:enable_new_point_light_sampler = 1
    bool arnold:enable_new_quad_light_sampler = 1
    bool arnold:enable_procedural_cache = 1
    bool arnold:enable_progressive_render = 0
    color3f arnold:error_color_bad_pixel = (0, 0, 1)
    color3f arnold:error_color_bad_shader = (1, 0, 1)
    color3f arnold:error_color_bad_texture = (1, 0, 0)
    token arnold:fis_filter = "none" (
        allowedTokens = ["none", "triangle", "blackman_harris", "gaussian"]
    )
    float arnold:fis_filter_width = 3
    bool arnold:force_non_progressive_sampling = 0
    float arnold:fps = 24
    float arnold:frame = 0
    int arnold:GI_diffuse_depth = 0
    int arnold:GI_diffuse_samples = 2
    int arnold:GI_specular_depth = 0
    int arnold:GI_specular_samples = 2
    int arnold:GI_sss_samples = 2
    int arnold:GI_total_depth = 10
    int arnold:GI_transmission_depth = 2
    int arnold:GI_transmission_samples = 2
    int arnold:GI_volume_depth = 0
    int arnold:GI_volume_samples = 2
    bool arnold:GLS_glossy_enable = 1
    int arnold:gpu_default_min_memory_MB = 512
    string arnold:gpu_default_names = "*"
    int arnold:gpu_max_texture_resolution = 0
    bool arnold:ignore_atmosphere = 0
    bool arnold:ignore_bump = 0
    bool arnold:ignore_displacement = 0
    bool arnold:ignore_dof = 0
    bool arnold:ignore_imagers = 0
    bool arnold:ignore_lights = 0
    string[] arnold:ignore_list
    bool arnold:ignore_motion = 0
    bool arnold:ignore_motion_blur = 0
    bool arnold:ignore_operators = 0
    bool arnold:ignore_shaders = 0
    bool arnold:ignore_shadows = 0
    bool arnold:ignore_smoothing = 0
    bool arnold:ignore_sss = 0
    bool arnold:ignore_subdivision = 0
    bool arnold:ignore_textures = 0
    float arnold:imager_overhead_target_percent = 1
    float arnold:indirect_sample_clamp = 10
    float arnold:indirect_specular_blur = 1
    string[] arnold:light_path_expressions
    int arnold:light_samples = 0
    float arnold:low_light_threshold = 0.001
    float arnold:luminaire_bias = 0.000001
    uchar arnold:max_subdivisions = 255
    float arnold:meters_per_unit = 1
    float arnold:nits_per_unit = 1000
    string arnold:operator = ""
    string arnold:osl_includepath = ""
    string[] arnold:outputs
    bool arnold:parallel_node_init = 1
    float arnold:pixel_aspect_ratio = 1
    string arnold:plugin_searchpath = ""
    bool arnold:procedural_auto_instancing = 1
    token arnold:procedural_instancing_optimization = "conservative" (
        allowedTokens = ["none", "conservative", "exhaustive"]
    )
    string arnold:procedural_searchpath = ""
    float arnold:reference_time = 0
    int arnold:region_max_x = -2147483648
    int arnold:region_max_y = -2147483648
    int arnold:region_min_x = -2147483648
    int arnold:region_min_y = -2147483648
    token arnold:render_device = "CPU" (
        allowedTokens = ["CPU", "GPU"]
    )
    token arnold:render_device_fallback = "error" (
        allowedTokens = ["error", "CPU"]
    )
    string arnold:scene_units_name = ""
    string arnold:shader_override = ""
    bool arnold:skip_background_atmosphere = 0
    bool arnold:skip_license_check = 0
    bool arnold:stochastic_volume_interpolation = 1
    string arnold:subdiv_dicing_camera = ""
    bool arnold:subdiv_frustum_culling = 0
    float arnold:subdiv_frustum_padding = 0
    bool arnold:texture_accept_unmipped = 1
    bool arnold:texture_accept_untiled = 1
    bool arnold:texture_auto_generate_tx = 1
    string arnold:texture_auto_tx_path = ""
    bool arnold:texture_automip = 1
    int arnold:texture_autotile = 0
    bool arnold:texture_conservative_lookups = 1
    int arnold:texture_failure_retries = 0
    float arnold:texture_max_memory_MB = 4096
    int arnold:texture_max_open_files = 0
    float arnold:texture_max_sharpen = 1.5
    bool arnold:texture_per_file_stats = 0
    string arnold:texture_searchpath = ""
    bool arnold:texture_use_existing_tx = 1
    token arnold:thread_priority = "low" (
        allowedTokens = ["lowest", "low", "normal", "high"]
    )
    int arnold:threads = 0
    bool arnold:usd_legacy_distant_light_normalize = 0
    bool arnold:usd_legacy_translation = 0
    int arnold:xres = 320
    int arnold:yres = 240
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class ArnoldSphere "ArnoldSphere"
{
    vector3f[] arnold:center
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float[] arnold:radius
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldCylinder "ArnoldCylinder"
{
    float arnold:bevel_angle = 0.5
    float arnold:bevel_width = 0
    vector3f arnold:bottom = (0, 0, -0.5)
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:radius = 0.5
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    vector3f arnold:top = (0, 0, 0.5)
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldCone "ArnoldCone"
{
    vector3f arnold:bottom = (0, 0, -0.5)
    float arnold:bottom_radius = 0.5
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    vector3f arnold:top = (0, 0, 0.5)
    float arnold:top_radius = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldDisk "ArnoldDisk"
{
    float arnold:bevel_angle = 0.5
    float arnold:bevel_width = 0
    vector3f arnold:center = (0, 0, 0)
    float arnold:hole = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    vector3f arnold:normal = (0, 0, 1)
    bool arnold:opaque = 1
    float arnold:radius = 0.5
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldPlane "ArnoldPlane"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    vector3f arnold:normal = (0, 0, 1)
    bool arnold:opaque = 1
    vector3f arnold:point = (0, 0, 0)
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldNurbs "ArnoldNurbs"
{
    uchar arnold:autobump_visibility = 1
    float[] arnold:cvs
    int arnold:degree_u = 3
    int arnold:degree_v = 3
    bool arnold:disp_autobump = 0
    float arnold:disp_height = 0
    string arnold:disp_map = ""
    float arnold:disp_padding = 0
    float arnold:disp_zero_value = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    float[] arnold:knots_u
    float[] arnold:knots_v
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    bool arnold:smoothing = 1
    float arnold:step_size = 0
    int arnold:tesselate_u = 5
    int arnold:tesselate_v = 5
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldBox "ArnoldBox"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    vector3f arnold:max = (0.5, 0.5, 0.5)
    vector3f arnold:min = (-0.5, -0.5, -0.5)
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldImplicit "ArnoldImplicit"
{
    string arnold:field = ""
    string arnold:field_channel = "field"
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    vector3f arnold:max = (0, 0, 0)
    vector3f arnold:min = (0, 0, 0)
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    uint arnold:samples = 10
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    token arnold:solver = "uniform" (
        allowedTokens = ["uniform", "levelset"]
    )
    float arnold:step_size = 0
    float arnold:threshold = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldGinstance "ArnoldGinstance"
{
    uint arnold:id = 0
    bool arnold:inherit_xform = 1
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:node = ""
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldProcedural "ArnoldProcedural"
{
    bool arnold:auto_instancing = 1
    string arnold:data = ""
    asset arnold:filename = @@
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldVolume "ArnoldVolume"
{
    bool arnold:compress = 1
    uchar[] arnold:filedata
    asset arnold:filename = @@
    string[] arnold:grids
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_scale = 1
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    float arnold:velocity_fps = 24
    string[] arnold:velocity_grids
    float arnold:velocity_outlier_threshold = 0.001
    float arnold:velocity_scale = 1
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldVolumeImplicit "ArnoldVolumeImplicit"
{
    bool arnold:compress = 1
    string arnold:field = ""
    string arnold:field_channel = "field"
    uchar[] arnold:filedata
    asset arnold:filename = @@
    string[] arnold:grids
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    vector3f arnold:max = (0, 0, 0)
    vector3f arnold:min = (0, 0, 0)
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    uint arnold:samples = 10
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    token arnold:solver = "uniform" (
        allowedTokens = ["uniform", "levelset"]
    )
    float arnold:step_scale = 1
    float arnold:step_size = 0
    float arnold:threshold = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    float arnold:velocity_fps = 24
    string[] arnold:velocity_grids
    float arnold:velocity_outlier_threshold = 0.001
    float arnold:velocity_scale = 1
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldInstancer "ArnoldInstancer"
{
    uint arnold:id = 0
    matrix4d[] arnold:instance_matrix
    string[] arnold:instance_shader
    uchar[] arnold:instance_visibility
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    uint[] arnold:node_idxs
    string[] arnold:nodes
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldAlembic "ArnoldAlembic"
{
    uint arnold:deform_keys = 0
    bool arnold:exclude_xform = 0
    bool arnold:expand_hidden = 0
    asset arnold:filename = @@
    bool arnold:flip_v = 0
    float arnold:fps = 24
    float arnold:frame = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:layers
    string[] arnold:light_group
    bool arnold:make_instance = 1
    string arnold:material_attribute = ""
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:nameprefix = ""
    string arnold:namespace = ""
    string[] arnold:objectpath
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    bool arnold:pull_user_params = 0
    string arnold:radius_attribute = ""
    float arnold:radius_default = 0.02
    float arnold:radius_scale = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    string arnold:scene_camera = ""
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    uint arnold:transform_keys = 0
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_instance_cache = 1
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    bool arnold:velocity_ignore = 0
    float arnold:velocity_scale = 1
    uchar arnold:visibility = 255
    bool arnold:visibility_ignore = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldProceduralCustom "ArnoldProceduralCustom"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    string arnold:node_entry = ""
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldUsd "ArnoldUsd"
{
    int arnold:cache_id = 0
    bool arnold:debug = 0
    string arnold:filename = ""
    float arnold:frame = 0
    bool arnold:hydra = 1
    uint arnold:id = 0
    bool arnold:interactive = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    string arnold:object_path = ""
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    string[] arnold:overrides
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    int arnold:threads = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

